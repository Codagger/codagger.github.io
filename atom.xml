<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风酥糖</title>
  
  <subtitle>fetasty</subtitle>
  <link href="https://fetasty.github.io/atom.xml" rel="self"/>
  
  <link href="https://fetasty.github.io/"/>
  <updated>2023-06-19T06:55:27.941Z</updated>
  <id>https://fetasty.github.io/</id>
  
  <author>
    <name>fetasty</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>健康生活清单</title>
    <link href="https://fetasty.github.io/posts/1ef19147/"/>
    <id>https://fetasty.github.io/posts/1ef19147/</id>
    <published>2022-03-07T13:28:25.000Z</published>
    <updated>2023-06-19T06:55:27.941Z</updated>
    
    <content type="html"><![CDATA[<p>现在多少年轻人都莫名其妙的大病或猝死，不好的生活习惯会让我们的身体一直处于亚健康状态，后面可能任何一个小的触发点都能是压垮骆驼的最后一根稻草，比如生个气喝个酒甚至猛然的剧烈运动一下都可能直接人没了</p><span id="more"></span><p>一份简单的健康生活清单，说着简单，但坚持做下来不简单</p><ul><li>饮食<ul><li><span style="color: green">多喝水</span></li><li><span style="color: green">多吃蔬菜水果</span></li><li><span style="color: orange">少吃油炸烧烤腌制</span> (含致癌物)</li><li><span style="color: red"> 少吃游离糖，少吃零食，少喝奶茶</span>(高糖高热量，危害多到写不下)</li><li><span style="color: red"> 不饮酒，不喝含酒精饮料</span>(含酒精饮料为一级致癌物 (与黄曲霉素一个等级))</li></ul></li><li> 作息<ul><li><span style="color: green">早睡早起</span> (熬夜的危害实在太多了，都懒得写)</li><li><span style="color: green"> 保持午休</span> (30 分钟左右即可，双相睡眠对身体非常好)</li></ul></li><li> 活动<ul><li><span style="color: green">保持锻炼</span>(每周至少 3 次不少于 30 分钟的运动)</li><li><span style="color: red"> 不要长时间埋头，电脑垫高</span> (保护颈椎，出问题时才知道多严重)</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;现在多少年轻人都莫名其妙的大病或猝死，
不好的生活习惯会让我们的身体一直处于亚健康状态，
后面可能任何一个小的触发点都能是压垮骆驼的最后一根稻草，
比如生个气喝个酒甚至猛然的剧烈运动一下都可能直接人没了&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://fetasty.github.io/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ 中 const 与 constexpr 的区别</title>
    <link href="https://fetasty.github.io/posts/106f98c5/"/>
    <id>https://fetasty.github.io/posts/106f98c5/</id>
    <published>2022-03-07T13:25:57.000Z</published>
    <updated>2023-06-19T08:50:35.370Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址: <a href="https://www.cnblogs.com/fortunely/p/14550145.html">const 和 constexpr 区别与联系</a></p><p>提到 const 和 constexpr, 就需要引入常量表达式。常量表达式是指值不会改变，并且编译过程就能得到计算结果的表达式. =&gt; 编译阶段就能得到值，并且不能改变.</p><span id="more"></span><p><strong>const 修饰对象无法修改，constexpr 更侧重于修饰对象编译期确定且无法修改. </strong>具体区别，体现在以下两个方面：</p><h2 id="修饰变量">修饰变量</h2><p><strong>const 变量，表示一个变量无法改变，但初值并不确定，不能在编译阶段决定. </strong></p><p>比如，</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>(); <span class="comment">// 虽然sz无法改变, 但get_size()</span></span><br></pre></td></tr></tbody></table></figure><p>编译阶段无法确定值，也就是说 sz 不是常量表达式</p><p><strong>constexpr 变量，编译器在编译阶段验证变量是否为一个常量表达式.</strong></p><p>constexpr 侧重变量初值编译阶段确定，且无法修改.如果认定变量是一个常量表达式，就把它声明称 constexpr 类型.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mf = <span class="number">20</span>; <span class="comment">// 字面量20是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = mf + <span class="number">1</span>; <span class="comment">// mf + 1是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">size</span>(); <span class="comment">// 只有当size是constexpr函数时, 才是正确的</span></span><br></pre></td></tr></tbody></table></figure><h2 id="修饰指针">修饰指针</h2><p>const 修饰指针分为两种情况：顶层 const, 底层 const.</p><p><strong>顶层 const 代表指针变量自身无法修改；底层 const 代表指针所指对象无法修改.</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i; <span class="comment">// 顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;i; <span class="comment">// 底层const</span></span><br><span class="line"></span><br><span class="line">p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>); <span class="comment">// 错误, 顶层const指针自身无法修改</span></span><br><span class="line">p2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">30</span>); <span class="comment">// 正确, 底层const指针可以修改</span></span><br><span class="line">*p1 = <span class="number">40</span>; <span class="comment">// 正确, 顶层const指针指向的对象可以修改</span></span><br><span class="line">*p2 = <span class="number">40</span>; <span class="comment">// 错误, 底层const指针指向的对象无法修改</span></span><br></pre></td></tr></tbody></table></figure><p>constexpr 修饰指针，仅对指针有效，与指针所指对象无关</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// j的定义必须放在函数体外</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数体内</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *pp1 = &amp;j; <span class="comment">// 等价于 int constexpr *pp1 = &amp;j;</span></span><br><span class="line">cout &lt;&lt; *pp1 &lt;&lt; endl; <span class="comment">// 30</span></span><br><span class="line">*pp1 = <span class="number">40</span>;</span><br><span class="line">cout &lt;&lt; j &lt;&lt; endl; <span class="comment">// 40</span></span><br><span class="line">pp1 = <span class="literal">nullptr</span>; <span class="comment">// 错误, constexpr指针无法修改</span></span><br></pre></td></tr></tbody></table></figure><h2 id="修饰函数">修饰函数</h2><p>const 修饰成员函数，通常称为 const 函数，表示该函数不会修改类的状态（即不会通过任何方式修改类数据成员）. 另外，const 类对象，只能调用 const 函数，确保不会修改类的数据成员.</p><p>constexpr 无法修饰成员函数，只能作为函数返回值类型，表明该函数返回的是一个编译期可确定的常量；constexpr被隐式隐式指定为内联函数，只能在类的声明中定义（.h 文件）.</p><p>参见 <a href="https://blog.csdn.net/lihao21/article/details/8634876">C++ 的 const 类成员函数</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>():<span class="built_in">curSize</span>(<span class="number">10</span>) {}</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setSize</span><span class="params">(<span class="type">int</span> size)</span> </span>{ size++; }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// const函数</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> curSize; }  <span class="comment">// 正确示例：不写任何数据成员</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>{ curSize = <span class="number">2</span>; <span class="keyword">return</span> curSize; }; <span class="comment">// 错误示例： const函数不能修改任何类的数据成员</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="built_in">setSize</span>(); <span class="keyword">return</span> curSize; } <span class="comment">// 错误示例：const函数不能调用任何可能导致类的数据成员改变的函数, 也就是说, 如果调用自身成员函数, 只能调用const函数</span></span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>{ <span class="keyword">return</span> curSize; }  <span class="comment">// 函数返回值为const类型：函数体可以修改数据成员, 但返回类型是const, 也就是调用者无法修改</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数返回值为constexpr类型</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">getMaxSize</span><span class="params">()</span> </span>{ <span class="keyword">return</span> INT_MAX; } <span class="comment">// 正确示例：返回常量值</span></span><br><span class="line">  <span class="comment">// 错误示例：vec.size()运行时确定, 不能在编译期决定</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">getMaxSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> vec.<span class="built_in">size</span>();</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 正确：虽然看起来返回的是变量, 但编译器可确定</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">getMaxSize</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> curSize;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// A.cpp</span></span><br><span class="line"><span class="comment">// 错误示例：constexpr被隐式指定为内联函数, 只能在.h 类内定义, 不能在类实现文件(.cpp)中定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">A::getMaxsize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;原文地址: &lt;a href=&quot;https://www.cnblogs.com/fortunely/p/14550145.html&quot;&gt;const 和 constexpr 区别与联系&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;提到 const 和 constexpr, 就需要引入常量表达式。常量表达式是指值不会改变，
并且编译过程就能得到计算结果的表达式. =&amp;gt; 编译阶段就能得到值，
并且不能改变.&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://fetasty.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://fetasty.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>添加糖 - 甜蜜杀手</title>
    <link href="https://fetasty.github.io/posts/90d1f41c/"/>
    <id>https://fetasty.github.io/posts/90d1f41c/</id>
    <published>2022-03-07T13:23:43.000Z</published>
    <updated>2023-06-19T06:55:27.941Z</updated>
    
    <content type="html"><![CDATA[<p>让人上瘾，又伤心、伤脑…… 这味调料家家都有，但劝你别多吃！</p><p>2022-03-01 14:00 来源： CCTV 回家吃饭</p><p>　　糖果、冰激凌、蛋糕、饼干、巧克力…… 甜食让不少人欲罢不能，情绪不好时来一口，感觉整个世界都明媚了；时下的网红饮品奶茶，更是被戏称为 “肥宅快乐水”, 深受年轻人的喜爱～</p><p>　　殊不知，大快朵颐的同时，甜食更像是一位隐形的 “甜蜜杀手”,不仅会让人慢慢 “上瘾”, 还会悄悄摧毁着你的身体！</p><span id="more"></span><h2 id="长期吃太多糖-从上到下毁全身">长期吃太多糖，从上到下毁全身</h2><p>　　2012 年 2 月，发表在国际顶级学术刊物《Nature》杂志的一篇题为《公共卫生：糖的毒性真相》的文章指出：糖就像烟草和酒精一样，而且糖的危害远在脂肪和卡路里之上！</p><h3 id="糖-会诱发多种癌症">1 糖，会诱发多种癌症</h3><p>　　长期高糖摄入会导致肥胖和胰岛素抵抗，造成内氧化应激、内分泌紊乱及免疫功能障碍，从而导致肿瘤的发生风险增加.</p><p>　　2020 年刊发在《美国临床营养学杂志》的一项研究，对 10 万余人进行了长达 5.9 年的随访，通过饮食记录大家吃糖的情况.结果发现：</p><p>　　①总糖摄入量与较高的总癌症风险相关，且这种联系主要来自乳腺癌；</p><p>　　②添加糖、蔗糖、含糖饮料中的糖等与癌症风险的增加显著相关性.</p><p>　　另外，瑞典科学家花 9 年时间对 8 万人进行了跟踪调查，结果显示，经常过量摄取甜食、果酱等高糖食物的人，患胰腺癌的风险要比其他人高出 70%~90%.</p><p>　　而除了人人敬而远之的癌症，吃糖过多还会带来以下危害：</p><h3 id="形成龋齿">2 形成龋齿</h3><p>　　摄入过多糖分食物，容易导致龋齿产生.因为在口腔中残留的糖分非常容易被细菌分解并发酵，从而产生酸性的物质，损坏牙釉质.</p><h3 id="加速皮肤老化">3 加速皮肤老化</h3><p>　　摄入太多糖分时，不仅容易使皮肤松弛，滋生皱纹，肤色暗黄且没有光泽；也会使得酪氨酸酶异常活跃，加快黑色素沉淀速度，使得皮肤暗沉，容易长斑；甚至易堵塞毛孔而形成痤疮.</p><h3 id="伤大脑">4 伤大脑</h3><p>　　吃太多糖，会伤害脑细胞，降低记忆力，简单来说就是吃糖过多会让人变笨.</p><h3 id="诱发心脏病">5 诱发心脏病</h3><p>　　进食含糖量过高的食品会使血液中的甘油三酯升高，从而增加患心血管疾病的风险.</p><p>　　另外，一项针对 11.8 万美国人的 34 年随访研究显示：每天饮用 2 次以上含糖饮料的人，死于心血管疾病的风险上升 31%.</p><h2 id="控糖-控的是添加糖">控糖，控的是 “添加糖”</h2><p>　　糖类是人体必须的三大营养物质之一，应该均衡地摄入.<strong>真正需要限制摄入的是 “添加糖”（游离糖）</strong>：</p><p>　　①添加在加工食品中的白糖、冰糖、红糖、黑糖.它们的主要成分都是蔗糖，加工原料均为甘蔗或甜菜，只是加工工艺不同.</p><p>　　②各种添加了果葡糖浆、葡萄糖浆、麦芽糖浆、淀粉糖浆的含糖饮品.</p><p>　　③水果汁和蜂蜜也属于要限制的糖类.水果榨汁过程中会损失大量膳食纤维，消化吸收会加快；蜂蜜主要是果糖和葡萄糖，属于应该控制的糖类.</p><p>　　世界卫生组织建议要终生控制游离糖摄入，但是现实中又很难做到完全不吃。所以，我们最好将每天的游离糖摄入量控制在 25g 以内.</p><h3 id="代糖-也别吃过量">代糖，也别吃过量</h3><p>　　现在不少商家会选择用糖醇或人工甜味剂替代添加糖，不牺牲风味的同时，实现限糖.</p><ol type="1"><li>糖醇</li></ol><p>　　糖醇养型合成甜味剂，我们在配料表中看到的赤藓糖醇、山梨糖醇、麦芽糖醇、甘露醇、木糖醇等配料，就是糖醇家族的成员，优势也非常明显：</p><p>　　①提供甜味的同时，提供的热量大多远低于蔗糖；</p><p>　　②摄入后不会引起血糖大幅度升高；</p><p>　　③在口腔中也不受微生物作用，不会引起龋齿.</p><ol start="2" type="1"><li>人工甜味剂</li></ol><p>　　人工甜味剂属于非营养型甜味剂，我们在配料表中看到的糖精、安赛蜜、阿斯巴甜等配料就属于这个类别.</p><p>　　和糖醇一样，人工甜味剂也能在一定程度上帮助人们降低热量和糖分的摄入，但是它绝不是放心之选 —— 其能起打开食欲的作用，在心理上反而会对那些又甜、又实际存在热量的食物产生更强烈的依赖，这样一来可能会间接促成食物和能量摄入超标的结局.</p><p>　　总的来说，不管是糖醇还是人工甜味剂，日常可以以少量、低频次的节奏去摄入，但不能毫无节制的食用.</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;让人上瘾，又伤心、伤脑…… 这味调料家家都有，但劝你别多吃！&lt;/p&gt;
&lt;p&gt;2022-03-01 14:00 来源： CCTV 回家吃饭&lt;/p&gt;
&lt;p&gt;　　糖果、冰激凌、蛋糕、饼干、巧克力…… 甜食让不少人欲罢不能，
情绪不好时来一口，感觉整个世界都明媚了；时下的网红饮品奶茶，
更是被戏称为 “肥宅快乐水”, 深受年轻人的喜爱～&lt;/p&gt;
&lt;p&gt;　　殊不知，大快朵颐的同时，甜食更像是一位隐形的 “甜蜜杀手”,
不仅会让人慢慢 “上瘾”, 还会悄悄摧毁着你的身体！&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://fetasty.github.io/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>dumpbin 查看 DLL 导出信息</title>
    <link href="https://fetasty.github.io/posts/e6310a89/"/>
    <id>https://fetasty.github.io/posts/e6310a89/</id>
    <published>2022-02-22T13:17:40.000Z</published>
    <updated>2023-06-19T08:48:51.670Z</updated>
    
    <content type="html"><![CDATA[<p>dumpbin 是 vs 提供的一个工具，可以用于查看 dll/exe 的信息，32 位还是 64 位，导出函数等</p><span id="more"></span><p><a href="https://blog.csdn.net/luoyu510183/article/details/93666808">https://blog.csdn.net/luoyu510183/article/details/93666808</a></p><p>如果导入 dll 时发现没有找到该函数，要根据 dll 的导出约定方式设置对应的导入方式，否则虽然函数名一样但实际上符号是不同的.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpbin /exports xxx.dll</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line">    <span class="comment">//extern "C" + _stdcall,函数导出符号为 _CreateNativeManager@0 : _+函数名+@+传参字节数</span></span><br><span class="line">    <span class="comment">//由于_stdcall是被调用方清理堆栈, 所以函数符号里面包含了传参的信息</span></span><br><span class="line">    _declspec(dllexport) <span class="function">NativeManager* _stdcall <span class="title">CreateNativeManager</span><span class="params">()</span></span>;</span><br><span class="line">    _declspec(dllexport) <span class="function"><span class="type">void</span> _stdcall <span class="title">ReleaseNativeManager</span><span class="params">()</span></span>;</span><br><span class="line">    _declspec(dllexport) <span class="built_in">void</span>(_stdcall ExSetLogHandler)(LogHandler handler);</span><br><span class="line">    <span class="comment">//extern "C" + _cdecl,函数导出符号为 ReleaseNativeManager2 : 函数名</span></span><br><span class="line">    <span class="comment">//由于_cdecl是调用方清理堆栈, 所以只需要函数名就可以</span></span><br><span class="line">    _declspec(dllexport) <span class="built_in">void</span>(_cdecl ReleaseNativeManager2)();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//不使用extern的情况下, 是C++的导出方式, 函数符号如下：</span></span><br><span class="line"><span class="comment">//?ReleaseNativeManager1@@YGXH@Z : ?+函数名+@@YG+返回类型+参数1类型...+@Z</span></span><br><span class="line"><span class="comment">//如果是_cdecl @YG变为@YA</span></span><br><span class="line"><span class="comment">//如果没有参数即参数为void,则以Z结尾, 例如：</span></span><br><span class="line"><span class="comment">//?ReleaseNativeManager3@@YAXXZ : ?+函数名+@@YA+返回类型+XZ</span></span><br><span class="line"><span class="comment">//以上 X表示 void类型, H表示int参数类型</span></span><br><span class="line">_declspec(dllexport) <span class="built_in">void</span>(_stdcall ReleaseNativeManager1)(<span class="type">int</span> num);</span><br><span class="line">_declspec(dllexport) <span class="built_in">void</span>(_cdecl ReleaseNativeManager3)();</span><br></pre></td></tr></tbody></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;dumpbin 是 vs 提供的一个工具，可以用于查看 dll/exe 的信息，32 位还是 64 位，
导出函数等&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://fetasty.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://fetasty.github.io/tags/C/"/>
    
    <category term="DLL" scheme="https://fetasty.github.io/tags/DLL/"/>
    
  </entry>
  
  <entry>
    <title>Python 中的可变对象与不可变对象</title>
    <link href="https://fetasty.github.io/posts/c3f5fb77/"/>
    <id>https://fetasty.github.io/posts/c3f5fb77/</id>
    <published>2022-02-21T12:18:46.000Z</published>
    <updated>2023-06-19T06:55:27.939Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中只存在 “引用传递” 这一种传递方式，准确来说应该是<strong>指针传递</strong> ,通过 <code>id()</code> 函数可以确定，参数传入前和传入后的地址值一样</p><p>所谓的对象可变与不可变，其实是看是否提供了修改自身对象的方法</p><span id="more"></span><p><strong>变量无类型，对象有类型</strong></p><p>不可变 (immutable) 对象类型 (指针地址不可变)</p><ul><li>int</li><li>float</li><li>decimal</li><li>complex</li><li>bool</li><li>str</li><li>tuple</li><li>range</li><li>frozenset</li><li>bytes</li></ul><p>可变 (mutable) 对象类型</p><ul><li>list</li><li>dict</li><li>set</li><li>bytearray</li></ul><p>user-defined classes (unless specifically made immutable)</p><p>Python 中的对象类型分为 <strong>可变类型</strong> 和<strong>不可变类型</strong></p><p>例如: Python 中的数字是不可变类型</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>    <span class="comment"># 变量 a 指向一个 Number 对象</span></span><br><span class="line">b = <span class="number">2</span>    <span class="comment"># 变量 b 和 a 指向同一个 Number 对象 此时 id(a) == id(b)</span></span><br><span class="line">a = <span class="number">1</span>    <span class="comment"># 变量 a 指向一个新的 Number 对象, 而并不是 a 原本指向的 Number 对象发生了改变！ 此时 id(a) != id(b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样, 函数参数传递时也是如此</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(num))    <span class="comment"># 第一次打印的 id 是与外部的参数的 id 一致 (引用传递, 准确来说是指针传递)</span></span><br><span class="line">    num += <span class="number">2</span>        <span class="comment"># 改变了 num 指向的对象, id(num) 发生了改变, 但不影响外部传入变量的地址</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(num))</span><br><span class="line"></span><br><span class="line">add(a)     <span class="comment"># 传递变量 a 其实是“引用传递”, 也就是将 a 指向的内存地址传递了</span></span><br></pre></td></tr></tbody></table></figure><p>即使对于可变类型，其实也是<strong>指针传递</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">lst</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">id</span>(lst)) <span class="comment"># 2263872110464</span></span><br><span class="line">  lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">id</span>(lst)) <span class="comment"># 2263872133184</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  l = [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">id</span>(l)) <span class="comment"># 2263872110464</span></span><br><span class="line">  <span class="built_in">print</span>(l) <span class="comment"># [9, 8, 7]</span></span><br><span class="line">  test(l) <span class="comment"># 函数中改变的</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">id</span>(l)) <span class="comment"># 2263872110464</span></span><br><span class="line">  <span class="built_in">print</span>(l) <span class="comment"># [9, 8, 7]</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>可变类型的 "可变", 体现在下面这种情况</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">lst</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(lst)) <span class="comment"># 2389391376256</span></span><br><span class="line">    lst.append(<span class="number">33</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(lst)) <span class="comment"># 2389391376256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    l = [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(l)) <span class="comment"># 2389391376256</span></span><br><span class="line">    <span class="built_in">print</span>(l) <span class="comment"># [9, 8, 7]</span></span><br><span class="line">    test(l)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(l)) <span class="comment"># 2389391376256</span></span><br><span class="line">    <span class="built_in">print</span>(l) <span class="comment"># [9, 8, 7, 33]</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>参考文章:</p><p><a href="https://www.cnblogs.com/shiyublog/p/10809953.html">https://www.cnblogs.com/shiyublog/p/10809953.html</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;Python 中只存在 “引用传递” 这一种传递方式，
准确来说应该是&lt;strong&gt;指针传递&lt;/strong&gt; ,
通过 &lt;code&gt;id()&lt;/code&gt; 函数可以确定，参数传入前和传入后的地址值一样&lt;/p&gt;
&lt;p&gt;所谓的对象可变与不可变，其实是看是否提供了修改自身对象的方法&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://fetasty.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://fetasty.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 临时改变 Path 搜索目录</title>
    <link href="https://fetasty.github.io/posts/285687f/"/>
    <id>https://fetasty.github.io/posts/285687f/</id>
    <published>2022-02-21T12:17:24.000Z</published>
    <updated>2023-06-19T06:55:27.939Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">r".\lib"</span>)</span><br><span class="line"><span class="keyword">import</span> mymodule <span class="comment"># lib目录下的自定义模块</span></span><br></pre></td></tr></tbody></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;sp</summary>
      
    
    
    
    <category term="Python" scheme="https://fetasty.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python 处理 C 语言结构</title>
    <link href="https://fetasty.github.io/posts/669ef2f3/"/>
    <id>https://fetasty.github.io/posts/669ef2f3/</id>
    <published>2022-02-21T12:15:43.000Z</published>
    <updated>2023-06-19T06:55:27.940Z</updated>
    
    <content type="html"><![CDATA[<p>Python 可以高效率开发，但涉及到运算密集部分，还是应该交给 C/C++,这里就涉及到数据交互的结构与格式问题</p><span id="more"></span><p>//todo 不够详细，例子不具体，内存布局与解析没讲明白</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStruct</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"v1"</span>, c_char),  <span class="comment"># c_byte</span></span><br><span class="line">        (<span class="string">"v2"</span>, c_char),  <span class="comment"># c_byte</span></span><br><span class="line">        (<span class="string">"v1_dire"</span>, c_char),  <span class="comment">#  c_byte</span></span><br><span class="line">        (<span class="string">"v2_dire"</span>, c_char)  <span class="comment">#  c_byte</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mys = MyStruct()</span><br><span class="line">mys.v1 = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(mys.v1))</span><br><span class="line">mys.v2 = <span class="number">30</span></span><br><span class="line">mys.v1_dire = <span class="number">0</span></span><br><span class="line">mys.v2_dire = <span class="number">0</span></span><br><span class="line">msg = struct.pack(<span class="string">'cccc'</span>, mys.v1, mys.v2, mys.v1_dire, mys.v2_dire)  <span class="comment"># BBBB</span></span><br><span class="line"><span class="built_in">print</span>(msg)</span><br><span class="line">ss = struct.unpack(<span class="string">'cccc'</span>, msg)  <span class="comment"># BBBB</span></span><br></pre></td></tr></tbody></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;Python 可以高效率开发，但涉及到运算密集部分，还是应该交给 C/C++,
这里就涉及到数据交互的结构与格式问题&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://fetasty.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ 中 new-delete 与 malloc-free 的比较</title>
    <link href="https://fetasty.github.io/posts/f8def853/"/>
    <id>https://fetasty.github.io/posts/f8def853/</id>
    <published>2022-02-20T14:36:32.000Z</published>
    <updated>2023-06-19T08:50:26.788Z</updated>
    
    <content type="html"><![CDATA[<p>new-delete 与 malloc-free</p><span id="more"></span><h2 id="newdelete-与-mallocfree-的比较">new&amp;delete 与malloc&amp;free 的比较</h2><ul><li><code>malloc/free</code> 是 C 语言的库函数</li><li><code>new/delete</code> <code>new[]/delete[]</code> 是 C++中的运算符</li><li><code>malloc/free</code> 只是申请内存空间，释放空间</li><li><code>new/delete</code> 不仅会申请内存空间，还会根据类型初始化内存空间，this 指针绑定，调用构造函数和析构函数进行初始化或者清理等操作</li></ul><p>这里有两张网上找到的图</p><ol type="1"><li><p><code>new/delete</code> 实现 <img data-src="/posts/f8def853/new_delete%E5%AE%9E%E7%8E%B0.png" class=""></p></li><li><p><code>new[]/delete[]</code> 实现</p><img data-src="/posts/f8def853/new_delete%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0.png" class=""></li></ol><p>不一定完全正确，但具有一定参考意义，<code>new[]</code> 文中说会多申请4 字节 空间，在开始位置存储对象个数，这里我在 64 位 编译环境下验证了一下，是前 8 字节 空间中存储的，应该与系统位数有关</p><p>测试环境: Win10 64 bit &amp; GCC 8.1.0 64 bit</p><p>这里定义一个 Test 类作测试</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="built_in">Test</span>()</span><br><span class="line">    {</span><br><span class="line">        x = ++index;</span><br><span class="line">        str = str + std::<span class="built_in">to_string</span>(x);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Test Constructor() this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Test Destructor() this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Test show x("</span> &lt;&lt; x &lt;&lt; <span class="string">"), str("</span> &lt;&lt; str &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string str {<span class="string">"sssaaa"</span>};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Test::index = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><p>测试:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">sizeof</span>(Test);</span><br><span class="line">    Test* p = <span class="keyword">new</span> Test[<span class="number">3</span>]();</span><br><span class="line">    <span class="type">uint64_t</span>* sp = (<span class="type">uint64_t</span>*)p - <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Test obj size: "</span> &lt;&lt; *sp &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Test Constructor() this=0x1d1e88</span><br><span class="line">Test Constructor() this=0x1d1eb0</span><br><span class="line">Test Constructor() this=0x1d1ed8</span><br><span class="line">Test obj size: 3</span><br><span class="line">Test Destructor() this=0x1d1ed8</span><br><span class="line">Test Destructor() this=0x1d1eb0</span><br><span class="line">Test Destructor() this=0x1d1e88</span><br></pre></td></tr></tbody></table></figure><p>如果我们修改一下上面的测试代码，更改一下前面的对象个数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">sizeof</span>(Test);</span><br><span class="line">    Test* p = <span class="keyword">new</span> Test[<span class="number">3</span>]();</span><br><span class="line">    <span class="type">uint64_t</span>* sp = (<span class="type">uint64_t</span>*)p - <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Test obj size: "</span> &lt;&lt; *sp &lt;&lt; std::endl;</span><br><span class="line">    *sp = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Test Constructor() this=0x6e1e88</span><br><span class="line">Test Constructor() this=0x6e1eb0</span><br><span class="line">Test Constructor() this=0x6e1ed8</span><br><span class="line">Test obj size: 3</span><br><span class="line">Test Destructor() this=0x6e1eb0</span><br><span class="line">Test Destructor() this=0x6e1e88</span><br></pre></td></tr></tbody></table></figure><p><code>delete[]</code> 只执行了两次析构</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;new-delete 与 malloc-free&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://fetasty.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://fetasty.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中使用 fstream 一次读取整个文件内容</title>
    <link href="https://fetasty.github.io/posts/3579021f/"/>
    <id>https://fetasty.github.io/posts/3579021f/</id>
    <published>2022-02-20T14:33:41.000Z</published>
    <updated>2023-06-19T08:50:23.272Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址 <a href="https://www.cnblogs.com/kex1n/p/4028428.html">https://www.cnblogs.com/kex1n/p/4028428.html</a></p><span id="more"></span><h2 id="读取到-char">读取到 char*</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::ifstream t; <span class="type">int</span> length; t.<span class="built_in">open</span>(<span class="string">"file.txt"</span>); <span class="comment">// open input file</span></span><br><span class="line">t.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::end); <span class="comment">// go to the end</span></span><br><span class="line">length = t.<span class="built_in">tellg</span>(); <span class="comment">// report location (this is the length)</span></span><br><span class="line">t.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::beg); <span class="comment">// go back to the beginning</span></span><br><span class="line">buffer = <span class="keyword">new</span> <span class="type">char</span>[length]; <span class="comment">// allocate memory for a buffer of appropriate dimension</span></span><br><span class="line">t.<span class="built_in">read</span>(buffer, length); <span class="comment">// read the whole file into the buffer</span></span><br><span class="line">t.<span class="built_in">close</span>(); <span class="comment">// close file handle</span></span><br><span class="line"><span class="comment">// ... do stuff with buffer here ...</span></span><br></pre></td></tr></tbody></table></figure><h2 id="读取到-stdstring">读取到 std::string</h2><p>方法一</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;streambuf&gt;</span></span></span><br><span class="line"><span class="function">std::ifstream <span class="title">t</span><span class="params">(<span class="string">"file.txt"</span>)</span></span>;</span><br><span class="line"><span class="function">std::string  <span class="title">str</span><span class="params">((std::istreambuf_iterator&lt;<span class="type">char</span>&gt;(t)), std::istreambuf_iterator&lt;<span class="type">char</span>&gt;())</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>方法二</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="function">std::ifstream  <span class="title">t</span><span class="params">(<span class="string">"file.txt"</span>)</span></span>;</span><br><span class="line">std::stringstream  buffer;</span><br><span class="line">buffer &lt;&lt; t.<span class="built_in">rdbuf</span>();</span><br><span class="line"><span class="function">std::string  <span class="title">contents</span><span class="params">(buffer.str())</span></span>;</span><br></pre></td></tr></tbody></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;原文地址 &lt;a href=&quot;https://www.cnblogs.com/kex1n/p/4028428.html&quot;&gt;https://www.cnblogs.com/kex1n/p/4028428.html&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://fetasty.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://fetasty.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中 lambda 使用注意事项</title>
    <link href="https://fetasty.github.io/posts/24017eff/"/>
    <id>https://fetasty.github.io/posts/24017eff/</id>
    <published>2022-02-20T14:32:43.000Z</published>
    <updated>2023-06-19T08:50:31.164Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/czyt1988/article/details/80149695">https://blog.csdn.net/czyt1988/article/details/80149695</a></p><ul><li><strong> 不要使用 lambda 以引用方式捕获局部变量</strong>！！！(悬挂引用)</li><li>lambda 捕获 this 时也需要注意，lambda 的调用时机是否在 this 的生命周期之外(类生命周期)</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/czyt1988/article/details/80149695&quot;&gt;https://blog.csdn.net/czyt1988/article/details/80149695&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    <category term="C++" scheme="https://fetasty.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://fetasty.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的 move 和 forward</title>
    <link href="https://fetasty.github.io/posts/be74f994/"/>
    <id>https://fetasty.github.io/posts/be74f994/</id>
    <published>2022-02-20T14:31:12.000Z</published>
    <updated>2023-06-19T08:50:11.139Z</updated>
    
    <content type="html"><![CDATA[<p>std::move 和 std::forward 仅仅是进行类型转换的函数（实际上是函数模板）.std::move 无条件的将其参数转换为右值，而 std::forward 只在必要情况下进行这个转换，就是这样.</p><span id="more"></span><ol type="1"><li>std::move 执行一个无条件的转化到右值。它本身并不移动任何东西；</li><li>std::forward 把其参数转换为右值，仅仅在那个参数被绑定到一个右值时；</li><li>std::move 和 std::forward 在运行时（runtime）都不做任何事.</li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;std::move 和 std::forward 仅仅是进行类型转换的函数（实际上是函数模板）.
std::move 无条件的将其参数转换为右值，
而 std::forward 只在必要情况下进行这个转换，就是这样.&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://fetasty.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://fetasty.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 数组长度可以为变量吗</title>
    <link href="https://fetasty.github.io/posts/7a9ccc43/"/>
    <id>https://fetasty.github.io/posts/7a9ccc43/</id>
    <published>2022-02-20T14:28:39.000Z</published>
    <updated>2023-06-19T08:51:09.763Z</updated>
    
    <content type="html"><![CDATA[<p>转载：原创程序喵大人 程序喵大人 (微信公众号) (收录于话题:C++ 精进之路)</p><p>推荐一下这个专题，讲 C++ 很棒</p><span id="more"></span><h2 id="c数组长度可以为变量吗">C++ 数组长度可以为变量吗？</h2><p>37 个</p><p>大家好，我是喵大人，今天跟大家分享的是关于 C++ 数组提出几点问题：</p><h3 id="预备">预备</h3><p>先看下这两段代码，并思考如下问题.</p><p>1、变量作为数组的长度可行吗？</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> num)</span> </span>{</span><br><span class="line">    <span class="type">int</span> array[num]; <span class="comment">// num &gt; 0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"num "</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"sizeof array "</span> &lt;&lt; <span class="built_in">sizeof</span>(array) &lt;&lt; endl;</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"array[0] "</span> &lt;&lt; array[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num <span class="number">6</span></span><br><span class="line"><span class="keyword">sizeof</span> array <span class="number">24</span></span><br><span class="line">array[<span class="number">0</span>] <span class="number">20</span></span><br></pre></td></tr></tbody></table></figure><p>2、访问超过长度的数组下标的值会发生什么？</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> array[<span class="number">10</span>];</span><br><span class="line">    array[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    array[<span class="number">20</span>] = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"sizeof array "</span> &lt;&lt; <span class="built_in">sizeof</span>(array) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"array[3] "</span> &lt;&lt; array[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"array[20] "</span> &lt;&lt; array[<span class="number">20</span>] &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> array <span class="number">40</span></span><br><span class="line">array[<span class="number">3</span>] <span class="number">1</span></span><br><span class="line">array[<span class="number">20</span>] <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><h3 id="分析">分析</h3><p><strong>首先分析问题 1</strong>,我们平时看书学习过程中总看见说 C++ 的数组长度一定要是常量且不能是变量，很多资料需要在编译期确定栈帧的大小，如果是变量就不能在编译器确定栈帧大小，但上述代码为什么可以正常运行呢？光看不如实践，先看这样一段代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func2a address "</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func2b address "</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func2c address "</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// func1();</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> num)</span> </span>{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func3a address "</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func3b address "</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func3c address "</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func2</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">(<span class="type">int</span> num)</span> </span>{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func4a address "</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func4b address "</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func4c address "</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func3</span>(num);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">func4</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func4a address <span class="number">0x7ffeb675f418</span></span><br><span class="line">func4b address <span class="number">0x7ffeb675f420</span></span><br><span class="line">func4c address <span class="number">0x7ffeb675f41c</span></span><br><span class="line">func3a address <span class="number">0x7ffeb675f3c8</span></span><br><span class="line">func3b address <span class="number">0x7ffeb675f3d0</span></span><br><span class="line">func3c address <span class="number">0x7ffeb675f3cc</span></span><br><span class="line">func2a address <span class="number">0x7ffeb675f378</span></span><br><span class="line">func2b address <span class="number">0x7ffeb675f380</span></span><br><span class="line">func2c address <span class="number">0x7ffeb675f37c</span></span><br></pre></td></tr></tbody></table></figure><p>再看这段代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func2a address "</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func2b address "</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func2c address "</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// func1();</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> num)</span> </span>{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b[num];</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func3a address "</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func3b address "</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func3c address "</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func2</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">(<span class="type">int</span> num)</span> </span>{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func4a address "</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func4b address "</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func4c address "</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func3</span>(num);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">func4</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func4a address <span class="number">0x7ffff2c76568</span></span><br><span class="line">func4b address <span class="number">0x7ffff2c76570</span></span><br><span class="line">func4c address <span class="number">0x7ffff2c7656c</span></span><br><span class="line">func3a address <span class="number">0x7ffff2c76510</span></span><br><span class="line">func3b address <span class="number">0x7ffff2c76360</span></span><br><span class="line">func3c address <span class="number">0x7ffff2c76514</span></span><br><span class="line">func2a address <span class="number">0x7ffff2c76328</span></span><br><span class="line">func2b address <span class="number">0x7ffff2c76330</span></span><br><span class="line">func2c address <span class="number">0x7ffff2c7632c</span></span><br></pre></td></tr></tbody></table></figure><p>func4a - func3a = 88</p><p>func3a - func2a = 488</p><p>从上面两段代码其实可以看出 C++ 是支持变量长度的数组的，说不支持的那是很古老的编译器，在如下链接中也可以找到答案.</p><p><a href="https://c-for-dummies.com/blog/?p=3488">https://c-for-dummies.com/blog/?p=3488</a></p><p><a href="https://www.drdobbs.com/the-new-cwhy-variable-length-arrays/184401444">https://www.drdobbs.com/the-new-cwhy-variable-length-arrays/184401444</a></p><p><a href="https://stackoverflow.com/questions/1887097/why-arent-variable-length-arrays-part-of-the-c-standard">https://stackoverflow.com/questions/1887097/why-arent-variable-length-arrays-part-of-the-c-standard</a></p><p>备注：尽管 C++ 目前支持变量长度的数组，但是不建议使用，因为数组使用的是栈内存，栈内存是有大小限制的，一般是 8192 字节，既然长度是变量，那就可能是任何值，就有可能超过 8192, 这样就会 stackoverflow, 所以动态内存最好使用堆内存.</p><p><strong>再分析问题 2：操作超过数组长度的内存会发生什么？</strong></p><p>看下面这段代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> array[<span class="number">10</span>];</span><br><span class="line">    array[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    array[<span class="number">40</span>] = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"sizeof array "</span> &lt;&lt; <span class="built_in">sizeof</span>(array) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"array[3] "</span> &lt;&lt; array[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"array[40] "</span> &lt;&lt; array[<span class="number">40</span>] &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> a[<span class="number">200</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; ++i) {</span><br><span class="line">        a[i] = <span class="number">100</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; ++i) {</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">"====================="</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"====================="</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; ++i) {</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">"====================="</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="number">3</span>eaa9392a3d9:/ubuntu/test_dir# ./a.out</span><br><span class="line"><span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span></span><br><span class="line">=====================</span><br><span class="line"><span class="keyword">sizeof</span> array <span class="number">40</span></span><br><span class="line">array[<span class="number">3</span>] <span class="number">1</span></span><br><span class="line">array[<span class="number">40</span>] <span class="number">3</span></span><br><span class="line">=====================</span><br><span class="line"><span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">3</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span></span><br><span class="line">=====================</span><br></pre></td></tr></tbody></table></figure><p>看代码输出，在函数内操作超过数组长度的内存没有什么影响，但是它却导致了上一级的数组 a [200] 里的内容被改变，因为数组使用的是栈内存，经过问题 1 的代码输出以及分析可以看出，栈帧内存是向下增长的，代码中操作了超过数组长度的内存地址，就影响到了之前栈帧的内存数据，导致之前栈内存数据出现错误，可能就会引发大 bug.</p><blockquote><p><strong>总结</strong></p></blockquote><p><strong>summary</strong></p><p>C++ 中数组长度可以是变量，但是不建议使用，因为数组使用的是栈内存，变量可以是个比较大的数，这样会导致 stack overflow, 建议使用堆内存.</p><p>操作超过数组长度的内存可以编译通过且表面上看不出来问题，但是会导致栈内存出现脏写，最终可能会引发难以排查的 bug,建议数组使用 std::array,操作超过长度的下标会抛异常有利于开发者及时发现错误.</p><p>▼</p><p>更多精彩推荐，请关注我们</p><p>▼</p><p><strong>代码精进之路 </strong></p><p>代码精进之路，我们一起成长！</p><p><img src="https://secure2.wostatic.cn/static/wtedawzen2SaSyA4ZQ87yB/image.png"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;转载：原创程序喵大人 程序喵大人 (微信公众号) (收录于话题:
C++ 精进之路)&lt;/p&gt;
&lt;p&gt;推荐一下这个专题，讲 C++ 很棒&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://fetasty.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://fetasty.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中使用智能指针管理数组</title>
    <link href="https://fetasty.github.io/posts/21ebbed9/"/>
    <id>https://fetasty.github.io/posts/21ebbed9/</id>
    <published>2022-02-20T14:27:59.000Z</published>
    <updated>2023-06-19T08:50:18.902Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 智能指针不仅能管理普通对象，也可以管理数组对象</p><span id="more"></span><p>以前只知道使用智能指针管理对象</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;A&gt; <span class="title">pA</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line"><span class="comment">// do something with pA or pA.Get()</span></span><br><span class="line"><span class="comment">// 超过作用域后, pA自动释放资源</span></span><br></pre></td></tr></tbody></table></figure><p>智能指针也可以用于管理数组</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>[]&gt; pArr;</span><br><span class="line">pArr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]); <span class="comment">// pArr 管理10个大小的int数组</span></span><br><span class="line">pArr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">64</span>]); <span class="comment">// 替换pArr的管理数组, 原来的10大小的数组将被自动释放</span></span><br></pre></td></tr></tbody></table></figure><p>以上代码管理数组对象的 <code>reset</code> 方法在 C++17 之前不可用</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特化 unique_ptr&lt;T[]&gt;的成员</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(U)</span> </span>= <span class="keyword">delete</span>;      <span class="comment">// C++17 前</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(U)</span> <span class="keyword">noexcept</span></span>;      <span class="comment">// C++17 起</span></span><br></pre></td></tr></tbody></table></figure><p>千万不要用普通的智能指针指向数组地址，否则可能内存泄漏！！</p><p><del><code>std::unique_ptr&lt;int&gt; p(new int[xx])</code></del>错误用法！</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;C++ 智能指针不仅能管理普通对象，也可以管理数组对象&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://fetasty.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://fetasty.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 内存复用_内存池_allocator</title>
    <link href="https://fetasty.github.io/posts/8fc5d182/"/>
    <id>https://fetasty.github.io/posts/8fc5d182/</id>
    <published>2022-02-20T14:26:59.000Z</published>
    <updated>2023-06-19T08:51:04.900Z</updated>
    
    <content type="html"><![CDATA[<p>最近几天写一些服务端的基础小工具学习到不少内容，特别是内存管理这块</p><p>这里记录一下，C++ 中的内存复用</p><span id="more"></span><h2 id="newdelete-的局限性">new/delete 的局限性</h2><p>写 C++ 的孩子都知道 C++ 中使用动态内存 (堆内存), 一般使用 new 和delete 这对关键字</p><p>与 malloc/free 不同，new 申请内存后还会初始化内存空间，调用构造函数；delete 会先调用析构函数，之后释放内存</p><p>一般我们都是需要对象的时候 new 一个，用完后 delete 掉，但是如果一种类型的对象会很频繁的被使用到，就会有大量的 new/delete操作</p><p>new 操作符内部一般用 malloc 实现，malloc向系统申请内存空间会有系统调用，如果很频繁的 new/delete会导致用户态和内核态切换较多，浪费性能，而且容易产生大量内存碎片</p><p>对于需要频繁使用的类对象，如果能重用一片内存区域，就不会有上述问题</p><h2 id="stdallocator-的使用-c11"><code>std::allocator</code> 的使用(C++11)</h2><p>C++ 11 提供了 <code>std::allocator</code> 类模板，它是所有标准库容器的默认分配器，默认分配器无状态，即任何给定的 allocator实例可交换，比较像等，且能解分配同一 allocator类型的任何其他实例所分配的内存</p><p>上面的介绍来自 cppreference 文档 std::allocator - <a href="http://cppreference.com">cppreference.com</a></p><p>不理解也无所谓，只用知道它最大的作用就是<strong>可以将内存的申请和类对象初始化，还有类对象析构和内存释放拆分开</strong></p><p>也就是说，使用 allocator 可以申请一个对象的内存空间之后，可以在这片相同的内存上多次构造 / 析构不同的对象，也就是内存重用</p><p>测试类</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="built_in">Test</span>()</span><br><span class="line">    {</span><br><span class="line">        x = ++index;</span><br><span class="line">        str = str + std::<span class="built_in">to_string</span>(x);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Test Constructor() this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Test Destructor() this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Test show x("</span> &lt;&lt; x &lt;&lt; <span class="string">"), str("</span> &lt;&lt; str &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string str {<span class="string">"sssaaa"</span>};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Test::index = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><p>测试代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::allocator&lt;Test&gt; alloc;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"allocate ------------ \n"</span>);</span><br><span class="line">    Test* p = alloc.<span class="built_in">allocate</span>(<span class="number">1</span>); <span class="comment">// 申请内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"construct ----------- \n"</span>);</span><br><span class="line">    alloc.<span class="built_in">construct</span>(p); <span class="comment">// 构造对象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"use object ------------ \n"</span>);</span><br><span class="line">    p-&gt;<span class="built_in">Show</span>(); <span class="comment">// 使用对象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"destruct ------------ \n"</span>);</span><br><span class="line">    alloc.<span class="built_in">destroy</span>(p); <span class="comment">// 销毁对象</span></span><br><span class="line">    <span class="comment">// 同一片内存的再次使用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"construct ----------- \n"</span>);</span><br><span class="line">    alloc.<span class="built_in">construct</span>(p); <span class="comment">// 构造对象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"use object ------------ \n"</span>);</span><br><span class="line">    p-&gt;<span class="built_in">Show</span>(); <span class="comment">// 使用对象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"destruct ------------ \n"</span>);</span><br><span class="line">    alloc.<span class="built_in">destroy</span>(p); <span class="comment">// 销毁对象</span></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"deallocate ------------ \n"</span>);</span><br><span class="line">    alloc.<span class="built_in">deallocate</span>(p, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结果</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">allocate ------------</span><br><span class="line">construct -----------</span><br><span class="line">Test Constructor() this=0x1d1a50</span><br><span class="line">use object ------------</span><br><span class="line">Test show x(1), str(sssaaa1)</span><br><span class="line">destruct ------------</span><br><span class="line">Test Destructor() this=0x1d1a50</span><br><span class="line">construct -----------</span><br><span class="line">Test Constructor() this=0x1d1a50</span><br><span class="line">use object ------------</span><br><span class="line">Test show x(2), str(sssaaa2)</span><br><span class="line">destruct ------------</span><br><span class="line">Test Destructor() this=0x1d1a50</span><br><span class="line">deallocate ------------</span><br></pre></td></tr></tbody></table></figure><p>其中内存的申请 / 释放使用 <code>malloc</code> 和 <code>free</code>效果也一样</p><h2 id="stdallocator_traits-的使用-c11-c17-c20"><code>std::allocator_traits</code>的使用 (C++11, C++17, C++20)</h2><p>在 C++17 中，<code>std::allocator</code> 类模板的<code>construct</code> <code>destroy</code> 等方法被标记为弃用，到 C++20这些方法直接被移除了，所以上面直接使用 <code>std::allocator</code>的源码在 C++20 中是无法使用的</p><p>标准库中提供了一个 <code>std::allocator_traits</code>类模板提供几个静态方法，用于标准化使用 <code>std::allocator</code></p><p>其实就是套个壳，不允许直接使用</p><p>将测试代码改成如下形式，则可以在 C++20 中正常使用</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::allocator&lt;Test&gt; alloc;</span><br><span class="line">    std::allocator_traits&lt;std::allocator&lt;Test&gt;&gt; traits;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"allocate ------------ \n"</span>);</span><br><span class="line">    Test* p = traits.<span class="built_in">allocate</span>(alloc, <span class="number">1</span>); <span class="comment">// 申请内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"construct ----------- \n"</span>);</span><br><span class="line">    traits.<span class="built_in">construct</span>(alloc, p); <span class="comment">// 构造对象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"use object ------------ \n"</span>);</span><br><span class="line">    p-&gt;<span class="built_in">Show</span>(); <span class="comment">// 使用对象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"destruct ------------ \n"</span>);</span><br><span class="line">    traits.<span class="built_in">destroy</span>(alloc, p); <span class="comment">// 销毁对象</span></span><br><span class="line">    <span class="comment">// 同一片内存的再次使用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"construct ----------- \n"</span>);</span><br><span class="line">    traits.<span class="built_in">construct</span>(alloc, p); <span class="comment">// 构造对象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"use object ------------ \n"</span>);</span><br><span class="line">    p-&gt;<span class="built_in">Show</span>(); <span class="comment">// 使用对象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"destruct ------------ \n"</span>);</span><br><span class="line">    traits.<span class="built_in">destroy</span>(alloc, p); <span class="comment">// 销毁对象</span></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"deallocate ------------ \n"</span>);</span><br><span class="line">    traits.<span class="built_in">deallocate</span>(alloc, p, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="内存池">内存池</h2><p>头文件</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _OBJECT_POOL_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OBJECT_POOL_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IRecyclable</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">Type</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUse</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnRecycle</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectAlloctor</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::function&lt;IRecyclable*()&gt; m_allocate;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(IRecyclable*)&gt; m_construct;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(IRecyclable*)&gt; m_destroy;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(IRecyclable*)&gt; m_deallocate;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectPool</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> ObjectPool Instance;</span><br><span class="line">    ~<span class="built_in">ObjectPool</span>() { <span class="built_in">ClearAll</span>(); }</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">SetType</span><span class="params">(<span class="type">const</span> std::string&amp; type, Args &amp;&amp;... args)</span></span>;</span><br><span class="line">    <span class="function">IRecyclable* <span class="title">GetObj</span><span class="params">(<span class="type">const</span> std::string&amp; type)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReturnObj</span><span class="params">(IRecyclable* obj)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearAll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">IRecyclable* <span class="title">CreateObj</span><span class="params">(<span class="type">const</span> std::string&amp; type)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, std::list&lt;IRecyclable*&gt;&gt; m_mapObjs;</span><br><span class="line">    std::unordered_map&lt;std::string, ObjectAlloctor&gt; m_mapAlloc;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ObjectPool</span>() {};</span><br><span class="line">    <span class="built_in">ObjectPool</span>(ObjectPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">ObjectPool</span>(ObjectPool&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">const</span> ObjectPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ObjectPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">const</span> ObjectPool&amp; <span class="keyword">operator</span>=(ObjectPool&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectPool::SetType</span><span class="params">(<span class="type">const</span> std::string&amp; type, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    m_mapAlloc[type].m_allocate = [] {</span><br><span class="line">        <span class="built_in">return</span> (IRecyclable*)(std::<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T)));</span><br><span class="line">    };</span><br><span class="line">    <span class="comment">// 这里需要注意, 闭包函数的参数都是引用传递, 如果是临时变量需要用值传递或者特殊处理一下 比如在函数内再申明变量保存一下参数</span></span><br><span class="line">    m_mapAlloc[type].m_construct = [&amp;args...](IRecyclable* p) {</span><br><span class="line">        std::allocator&lt;T&gt; alloc;</span><br><span class="line">        std::allocator_traits&lt;std::allocator&lt;T&gt;&gt; traits;</span><br><span class="line">        traits.<span class="built_in">construct</span>(alloc, <span class="built_in">static_cast</span>&lt;T*&gt;(p), std::<span class="built_in">move</span>(args)...);</span><br><span class="line">    };</span><br><span class="line">    m_mapAlloc[type].m_destroy = [](IRecyclable* p) {</span><br><span class="line">        std::allocator&lt;T&gt; alloc;</span><br><span class="line">        std::allocator_traits&lt;std::allocator&lt;T&gt;&gt; traits;</span><br><span class="line">        traits.<span class="built_in">destroy</span>(alloc, <span class="built_in">static_cast</span>&lt;T*&gt;(p));</span><br><span class="line">    };</span><br><span class="line">    m_mapAlloc[type].m_deallocate = [](IRecyclable* p) {</span><br><span class="line">        std::<span class="built_in">free</span>(p);</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>注意: <strong>C++ 中不支持模板的分离编译</strong> ,模板的实现都写在头文件中</p><p>源文件</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ObjectPool.h"</span></span></span><br><span class="line"></span><br><span class="line">ObjectPool ObjectPool::Instance;</span><br><span class="line"></span><br><span class="line"><span class="function">IRecyclable* <span class="title">ObjectPool::GetObj</span><span class="params">(<span class="type">const</span> std::string&amp; type)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    IRecyclable* obj = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> objIt = m_mapObjs.<span class="built_in">find</span>(type);</span><br><span class="line">    <span class="keyword">if</span> (objIt != m_mapObjs.<span class="built_in">end</span>() &amp;&amp; objIt-&gt;second.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        obj = objIt-&gt;second.<span class="built_in">front</span>();</span><br><span class="line">        objIt-&gt;second.<span class="built_in">pop_front</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        obj = <span class="built_in">CreateObj</span>(type);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">auto</span> allocIt = m_mapAlloc.<span class="built_in">find</span>(type);</span><br><span class="line">    <span class="keyword">if</span> (allocIt == m_mapAlloc.<span class="built_in">end</span>()) { <span class="keyword">throw</span> <span class="string">"somethings wrong"</span>; }</span><br><span class="line">    allocIt-&gt;second.<span class="built_in">m_construct</span>(obj);</span><br><span class="line">    obj-&gt;<span class="built_in">OnUse</span>();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">IRecyclable* <span class="title">ObjectPool::CreateObj</span><span class="params">(<span class="type">const</span> std::string&amp; type)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    IRecyclable* obj = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> allocIt = m_mapAlloc.<span class="built_in">find</span>(type);</span><br><span class="line">    <span class="keyword">if</span> (allocIt == m_mapAlloc.<span class="built_in">end</span>()) { <span class="keyword">throw</span> <span class="string">"somethings wrong"</span>; }</span><br><span class="line">    obj = allocIt-&gt;second.<span class="built_in">m_allocate</span>();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectPool::ReturnObj</span><span class="params">(IRecyclable* obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">nullptr</span>) { <span class="keyword">return</span>; }</span><br><span class="line">    std::string type = obj-&gt;<span class="built_in">Type</span>();</span><br><span class="line">    <span class="keyword">auto</span> it = m_mapAlloc.<span class="built_in">find</span>(type);</span><br><span class="line">    <span class="keyword">if</span> (it == m_mapAlloc.<span class="built_in">end</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"try to return obj that it's type not setted"</span>;</span><br><span class="line">    }</span><br><span class="line">    obj-&gt;<span class="built_in">OnRecycle</span>();</span><br><span class="line">    it-&gt;second.<span class="built_in">m_destroy</span>(obj);</span><br><span class="line">    m_mapObjs[type].<span class="built_in">push_back</span>(obj);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectPool::ClearAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = m_mapObjs.<span class="built_in">begin</span>(); it != m_mapObjs.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> allocIt = m_mapAlloc.<span class="built_in">find</span>(it-&gt;first);</span><br><span class="line">        <span class="keyword">if</span> (allocIt == m_mapAlloc.<span class="built_in">end</span>()) { <span class="keyword">throw</span> <span class="string">"somethings wrong"</span>; }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> lstit = it-&gt;second.<span class="built_in">begin</span>(); lstit != it-&gt;second.<span class="built_in">end</span>(); ++lstit)</span><br><span class="line">        {</span><br><span class="line">            allocIt-&gt;second.<span class="built_in">m_deallocate</span>(*lstit);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    m_mapObjs.<span class="built_in">clear</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> IRecyclable</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">Type</span><span class="params">()</span> <span class="keyword">override</span> </span>{ <span class="keyword">return</span> <span class="string">"test"</span>; }</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUse</span><span class="params">()</span> <span class="keyword">override</span> </span>{ std::cout &lt;&lt; <span class="string">"OnUse this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl; }</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnRecycle</span><span class="params">()</span> <span class="keyword">override</span> </span>{ std::cout &lt;&lt; <span class="string">"OnRecycle this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl; }</span><br><span class="line">    <span class="built_in">Test</span>()</span><br><span class="line">    {</span><br><span class="line">        x = ++index;</span><br><span class="line">        str = str + std::<span class="built_in">to_string</span>(x);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Test Constructor() this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Test Destructor() this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Test show x("</span> &lt;&lt; x &lt;&lt; <span class="string">"), str("</span> &lt;&lt; str &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string str {<span class="string">"sssaaa"</span>};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Test::index = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ObjectPool::Instance.<span class="built_in">SetType</span>&lt;Test&gt;(std::<span class="built_in">string</span>(<span class="string">"test"</span>));</span><br><span class="line">    Test* t1 = (Test*)ObjectPool::Instance.<span class="built_in">GetObj</span>(<span class="string">"test"</span>);</span><br><span class="line">    Test* t2 = (Test*)ObjectPool::Instance.<span class="built_in">GetObj</span>(<span class="string">"test"</span>);</span><br><span class="line">    t1-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    t2-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    ObjectPool::Instance.<span class="built_in">ReturnObj</span>((IRecyclable*)t1);</span><br><span class="line">    Test* t3 = (Test*)ObjectPool::Instance.<span class="built_in">GetObj</span>(<span class="string">"test"</span>);</span><br><span class="line">    t3-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    ObjectPool::Instance.<span class="built_in">ReturnObj</span>((IRecyclable*)t2);</span><br><span class="line">    ObjectPool::Instance.<span class="built_in">ReturnObj</span>((IRecyclable*)t3);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试结果:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Test Constructor() this=0x8037fe0</span><br><span class="line">OnUse this=0x8037fe0</span><br><span class="line">Test Constructor() this=0x8038430</span><br><span class="line">OnUse this=0x8038430</span><br><span class="line">Test show x(1), str(sssaaa1)</span><br><span class="line">Test show x(2), str(sssaaa2)</span><br><span class="line">OnRecycle this=0x8037fe0</span><br><span class="line">Test Destructor() this=0x8037fe0</span><br><span class="line">Test Constructor() this=0x8037fe0</span><br><span class="line">OnUse this=0x8037fe0</span><br><span class="line">Test show x(3), str(sssaaa3)</span><br><span class="line">OnRecycle this=0x8038430</span><br><span class="line">Test Destructor() this=0x8038430</span><br><span class="line">OnRecycle this=0x8037fe0</span><br><span class="line">Test Destructor() this=0x8037fe0</span><br></pre></td></tr></tbody></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;最近几天写一些服务端的基础小工具学习到不少内容，
特别是内存管理这块&lt;/p&gt;
&lt;p&gt;这里记录一下，C++ 中的内存复用&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://fetasty.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://fetasty.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 的数组不支持多态吗</title>
    <link href="https://fetasty.github.io/posts/72dbce7b/"/>
    <id>https://fetasty.github.io/posts/72dbce7b/</id>
    <published>2022-02-20T14:25:00.000Z</published>
    <updated>2023-06-19T08:51:24.103Z</updated>
    
    <content type="html"><![CDATA[<p>网上好像有人因为这个吵起来了，转载围观一下</p><span id="more"></span><p>转载</p><p>“C++ 的数组不支持多态”？</p><p>2013 年 04 月 29 日 陈皓 评论 177 条评论 59,678 人阅读</p><p>先是在微博上看到了个微博和云风的评论，然后我回了 “楼主对 C 的内存管理不了解”.</p><p>后来引发了很多人的讨论，大量的人又借机来黑 C++, 比如：</p><p>//<span class="citation" data-cites="Baidu-ThursdayWang:这不就c">@Baidu-ThursdayWang: 这不就 c</span>++ 弱爆了的地方吗，需要记忆太多东西</p><p>//<span class="citation" data-cites="编程浪子张发财:这个跟C关系真不大">@编程浪子张发财：这个跟 C 关系真不大</span>.不过我得验证一下，感觉真的不应该是这样的。如果基类的析构这种情况不能调用，就太弱了.</p><p>//<span class="citation" data-cites="程序元">@程序元</span>：现在看来，当初由于毅力不够而没有深入纠缠 c++ 语言特性的各种犄角旮旯的坑爹细枝末节，实是幸事。为现在还沉浸于这些诡异特性并乐此不疲的同志们感到忧伤.</p><p>然后，也出现了一些乱七八糟的理解：</p><p>//<span class="citation" data-cites="BA5BO">@BA5BO</span>:数组是基于拷贝的，而多态是基于指针的，派生类赋值给基类数组只是拷贝复制了一个基类新对象，当然不需要派生类析构函数</p><p>//<span class="citation" data-cites="编程浪子张发财:我突然理解是怎么回事了">@编程浪子张发财：我突然理解是怎么回事了</span> ,这种情况下数组中各元素都是等长结构体，类型必须一致，的确没法多态.这跟 C# 和 java 不同。后两者对于引用类型存放的是对象指针.</p><p>等等，看来我必需要写一篇博客以正视听了.</p><p>因为没有看到上下文，我就猜测讨论的可能会是下面这两种情况之一：</p><ol type="1"><li>一个 Base*[] 的指针数组中，存放了一堆派生类的指针，这样，你 delete []pBase; 只是把指针数组给删除了，并没有删除指针所指向的对象.这个是最基础的 C 的问题。你先得 for 这个指针数组，把数据里的对象都 delete 掉，然后再删除数组。很明显，这和 C++ 没有什么关系.</li></ol><p>2）第二种可能是：Base *pBase = new Derived [n] 这样的情况。这种情况下，delete [] pBase 明显不会调用虚析构函数（当然，这并不一定，我后面会说） ,这就是上面云风回的微博。对此，我觉得如果是这个样子，这个程序员完全没有搞懂 C 语言中的指针和数组是怎么一回事，也没有搞清楚，什么是对象，什么是对象的指针和引用，这完全就是 C 语言没有学好.</p><p>后来，在看到了 <span class="citation" data-cites="GeniusVczh">@GeniusVczh</span> 的原文《如何设计一门语言（一）—— 什么是坑 (a)》最后时，才知道了说的是第二种情况.也就是下面的这个示例（我加了虚的析构函数这样方便编译）：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">B</span>(){ cout &lt;&lt;<span class="string">"B::~B()"</span>&lt;&lt;endl; }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">D</span>() { cout &lt;&lt;<span class="string">"D::D~()"</span>&lt;&lt;endl; }</span><br><span class="line">};</span><br><span class="line">Base* pBase = <span class="keyword">new</span> Derived[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] pBase;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>C 语言补课</p><p>我先不说这段 C++ 的程序在什么情况下能正确调用派生类的析构函数，我还是先来说说 C 语言，这样我在后面说这段代码时你就明白了.</p><p>对于上面的：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base* pBase = <span class="keyword">new</span> Derived[<span class="number">10</span>];</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这个语言和下面的有什么不同吗？</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived d[<span class="number">10</span>];</span><br><span class="line">Base* pBase = d;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>一个是堆内存动态分配，一个是栈内存静态分配.只是内存的位置和类型不一样，在语法和使用上没有什么不一样的.（如果你把 Base 和 Derived 想成 struct, 把 new 想成 malloc () ,你还觉得这和 C++ 有什么关系吗？）</p><p>那么，你觉得 pBase 这个指针是指向对象的，是对象的引用，还是指向一个数组的，是数组的引用？</p><p>于是乎，你可以想像一下下面的场景：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pInt; <span class="type">char</span>* pChar;</span><br><span class="line">pInt = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">pChar = (<span class="type">char</span>*)pInt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>对上面的 pInt 和 pChar 指针来说，pInt [3] 和 pChar [3] 所指向的内容是否一样呢？当然不一样，因为 int 是 4 个字节，char 是 1 个字节，步长不一样，所以当然不一样.</p><p>那么再回到那个把 Derived [] 数组的指针转成 Base 类型的指针 pBase,那么 pBase [3] 是否会指向正确的 Derrived [3] 呢？</p><p>我们来看个纯 C 语言的例程，下面有两个结构体，就像继承一样，我还别有用心地加了一个 void *vptr, 好像虚函数表一样：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">    <span class="type">void</span> *vptr;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>{</span><br><span class="line">    <span class="type">void</span> *vptr;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">}b[<span class="number">2</span>] ={</span><br><span class="line">    {(<span class="type">void</span>*)<span class="number">0x01</span>, <span class="number">100</span>, <span class="string">'a'</span>, <span class="number">-1</span>},</span><br><span class="line">    {(<span class="type">void</span>*)<span class="number">0x02</span>, <span class="number">200</span>, <span class="string">'A'</span>, <span class="number">-2</span>}</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>注意：我用的是 G++ 编译的，在 64bits 平台上编译的，其中的 sizeof (void*) 的值是 8.</p><p>我们看一下栈上内存分配：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> *pa1 = (<span class="keyword">struct</span> A*)(b);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>用 gdb 我们可以看到下面的情况：(pa1 [1] 的成员的值完全乱掉了)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p b</span><br><span class="line">$<span class="number">7</span> = {{vptr = <span class="number">0x1</span>, i = <span class="number">100</span>, c = <span class="number">97</span> <span class="string">'a'</span>, j = <span class="number">-1</span>}, {vptr = <span class="number">0x2</span>, i = <span class="number">200</span>, c = <span class="number">65</span> <span class="string">'A'</span>, j = <span class="number">-2</span>}}</span><br><span class="line">(gdb) p pa1[<span class="number">0</span>]</span><br><span class="line">$<span class="number">8</span> = {vptr = <span class="number">0x1</span>, i = <span class="number">100</span>}</span><br><span class="line">(gdb) p pa1[<span class="number">1</span>]</span><br><span class="line">$<span class="number">9</span> = {vptr = <span class="number">0x7fffffffffff</span>, i = <span class="number">2</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>我们再来看一下堆上的情况：（我们动态了 struct B [2], 然后转成 struct A*, 然后对其成员操作）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> *pa = (<span class="keyword">struct</span> A*)<span class="built_in">malloc</span>(<span class="number">2</span>*<span class="built_in">sizeof</span>(<span class="keyword">struct</span> B));</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> *pb = (<span class="keyword">struct</span> B*)pa；</span><br><span class="line">pa[<span class="number">0</span>].vptr = (<span class="type">void</span>*) <span class="number">0x01</span>;</span><br><span class="line">pa[<span class="number">1</span>].vptr = (<span class="type">void</span>*) <span class="number">0x02</span>;</span><br><span class="line">pa[<span class="number">0</span>].i = <span class="number">100</span>;</span><br><span class="line">pa[<span class="number">1</span>].i = <span class="number">200</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>用 gdb 来查看一下变量，我们可以看到下面的情况：（pa 没问题，但是 pb [1] 的内存乱掉了）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p pa[<span class="number">0</span>]</span><br><span class="line">$<span class="number">1</span> = {vptr = <span class="number">0x1</span>, i = <span class="number">100</span>}</span><br><span class="line">(gdb) p pa[<span class="number">1</span>]</span><br><span class="line">$<span class="number">2</span> = {vptr = <span class="number">0x2</span>, i = <span class="number">200</span>}</span><br><span class="line">(gdb) p pb[<span class="number">0</span>]</span><br><span class="line">$<span class="number">3</span> = {vptr = <span class="number">0x1</span>, i = <span class="number">100</span>, c = <span class="number">0</span> <span class="string">'\000'</span>, j = <span class="number">2</span>}</span><br><span class="line">(gdb) p pb[<span class="number">1</span>]</span><br><span class="line">$<span class="number">4</span> = {vptr = <span class="number">0xc8</span>, i = <span class="number">0</span>, c = <span class="number">0</span> <span class="string">'\000'</span>, j = <span class="number">0</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>可见，这完全就是 C 语言里乱转型造成了内存的混乱，这和 C++ 一点关系都没有.而且，C++ 的任何一本书都说过，父类对象和子类对象的转型会带来严重的内存问题.</p><p>但是，如果在 64bits 平台下，如果把我们的 structB 改一下，改成如下（把 struct B 中的 int j 给注释掉）：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">    <span class="type">void</span> *vptr;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>{</span><br><span class="line">    <span class="type">void</span> *vptr;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="comment">//int j; &lt;---注释掉int j</span></span><br><span class="line">}b[<span class="number">2</span>] ={</span><br><span class="line">    {(<span class="type">void</span>*)<span class="number">0x01</span>, <span class="number">100</span>, <span class="string">'a'</span>},</span><br><span class="line">    {(<span class="type">void</span>*)<span class="number">0x02</span>, <span class="number">200</span>, <span class="string">'A'</span>}</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>你就会发现，上面的内存混乱的问题都没有了，因为 struct A 和 structB 的 size 是一样的：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="function">p <span class="title">sizeof</span><span class="params">(<span class="keyword">struct</span> A)</span></span></span><br><span class="line"><span class="function">$6 </span>= <span class="number">16</span></span><br><span class="line">(gdb) <span class="function">p <span class="title">sizeof</span><span class="params">(<span class="keyword">struct</span> B)</span></span></span><br><span class="line"><span class="function">$7 </span>= <span class="number">16</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>注：如果不注释 int j, 那么 sizeof (struct B) 的值是 24.</p><p>这就是 C 语言中的内存对齐，内存对齐的原因就是为了更快的存取内存（详见《深入理解 C 语言》）</p><p>如果内存对齐了，而且 struct A 中的成员的顺序在 structB 中是一样的而且在最前面话，那么就没有问题.</p><p>再来看 C++ 的程序</p><p>如果你看过我 5 年前写的《C++ 虚函数表解析》以及《C++ 内存对象布局上篇、下篇》, 你就知道 C++ 的标准会把虚函数表的指针放在类实例的最前面，你也就知道为什么我别有用心地在 struct A 和 struct B 前加了一个 void *vptr.C++ 之所以要加在最前面就是为了转型后，不会找不到虚表了.</p><p>好了，到这里，我们再来看 C++, 看下面的代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">B</span>(){ cout &lt;&lt;<span class="string">"B::~B()"</span>&lt;&lt;endl; }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B</span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">D</span>() { cout &lt;&lt;<span class="string">"D::~D()"</span>&lt;&lt;endl; }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"sizeB:"</span> &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; <span class="string">" sizeD:"</span>&lt;&lt; <span class="built_in">sizeof</span>(D) &lt;&lt;endl;</span><br><span class="line">    B *pb = <span class="keyword">new</span> D[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">delete</span> [] pb;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>上面的代码可以正确执行，包括调用子类的虚函数！因为内存对齐了.在我的 64bits 的 CentOS 上 ——sizeof (B):16 , sizeof (D):16</p><p>但是，如果你在 class D 中再加一个 int 成员的问题，这个程序就 Segmentationfault 了。因为 —— sizeof (B):16 , sizeof (D):24.pb [1] 的虚表找到了一个错误的内存上，内存乱掉了.</p><p>再注：我在 Visual Studio 2010 上做了一下测试，对于 struct 来说，其表现和 gcc 的是一样的，但对于 class 的代码来说，其可以 “正确调用到虚函数” 无论父类和子类有没有一样的 size.</p><p>然而，在 C++ 的标准中，下面这样的用法是 undefined!你可以看看 StackOverflow 上的相关问题讨论：《Why is it undefined behaviorto delete [] an array of derived objects via a base pointer?》（同样，你也可以看看《More Effective C++》中的条款三）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base* pBase = <span class="keyword">new</span> Derived[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] pBase;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>所以，微软 C++ 编程译器 define 这个事让我非常不解，对微软的 C++ 编译器再度失望，看似默默地把其编译对了很漂亮，实则误导了好多人把这种 undefined 的东西当成 defined 来用，还赞扬做得好，真是令人无语. （就像微博上的这个贴一样，说 VC 多么牛，还说这是 OO 的特性.我勒个去！）</p><p>现在，你终于知道 Base* pBase = newDerived [10]; 这个问题是 C 语言的转型的问题，你也应该知道用于数组的指针是怎么回事了吧？这是一个很奇葩的代码！请你不要像那些人一样在微博上和这里的评论里高呼并和我理论到：“微软的 C++ 编译器支持这个事！”.</p><p>最后，我越来越发现，很多说 C++ 难用的人，其实是不懂 C 语言.</p><p>（全文完）</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;网上好像有人因为这个吵起来了，转载围观一下&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://fetasty.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://fetasty.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11 左值右值</title>
    <link href="https://fetasty.github.io/posts/18350f75/"/>
    <id>https://fetasty.github.io/posts/18350f75/</id>
    <published>2022-02-20T14:22:47.000Z</published>
    <updated>2023-06-19T08:50:46.269Z</updated>
    
    <content type="html"><![CDATA[<p>左值右值，还是需要好好理一下的</p><span id="more"></span><blockquote><p>原文地址 <a href="https://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&amp;mid=2247484786&amp;idx=1&amp;sn=fc10ee31da336ec53b23b8be93e847ef&amp;source=41#wechat_redirect">mp.weixin.qq.com</a></p></blockquote><p>众所周知 C++11 新增了右值引用，谈右值引用我们也可以扩展一些相关概念：</p><ul><li>左值</li><li>右值</li><li>纯右值</li><li>将亡值</li><li>左值引用</li><li>右值引用</li><li>移动语义</li><li>完美转发</li><li>返回值优化</li></ul><p>程序喵下面会一一介绍：</p><h3 id="左值右值">左值、右值</h3><p><strong>概念 1</strong>：</p><p>左值：可以放到等号左边的东西叫左值.</p><p>右值：不可以放到等号左边的东西就叫右值.</p><p><strong>概念 2</strong>：</p><p>左值：可以取地址并且有名字的东西就是左值.</p><p>右值：不能取地址的没有名字的东西就是右值.</p><p><strong>举例</strong>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = b + c;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>a 是左值，有变量名，可以取地址，也可以放到等号左边，表达式 b+c的返回值是右值，没有名字且不能取地址，&amp;(b+c) 不能通过编译，而且也不能放到等号左边.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 4; // a是左值, 4作为普通字面量是右值</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>左值一般有：</p><ul><li>函数名和变量名</li><li>返回左值引用的函数调用</li><li>前置自增自减表达式 ++i、--i</li><li> 由赋值表达式或赋值运算符连接的表达式 (a=b, a += b 等)</li><li> 解引用表达式 * p</li><li> 字符串字面值 "abcd"</li></ul><h3 id="纯右值将亡值">纯右值、将亡值</h3><p>纯右值和将亡值都属于右值.</p><h4 id="纯右值">纯右值</h4><p>运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda表达式等都是纯右值.</p><p><strong>举例：</strong></p><ul><li>除字符串字面值外的字面值</li><li>返回非引用类型的函数调用</li><li>后置自增自减表达式 i++、i--</li><li> 算术表达式 (a+b, a*b, a&amp;&amp;b, a==b 等)</li><li> 取地址表达式等 (&amp;a)</li></ul><h4 id="将亡值">将亡值</h4><p>将亡值是指 C++11 新增的和右值引用相关的表达式，通常指将要被移动的对象、T&amp;&amp; 函数的返回值、std::move函数的返回值、转换为 T&amp;&amp; 类型转换函数的返回值，将亡值可以理解为即将要销毁的值，通过 “盗取”其它变量内存空间方式获取的值，在确保其它变量不再被使用或者即将被销毁时，可以避免内存空间的释放和分配，延长变量值的生命周期，常用来完成移动构造或者移动赋值的特殊任务.</p><p><strong>举例：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A {</span><br><span class="line">    xxx;</span><br><span class="line">};</span><br><span class="line">A a;</span><br><span class="line">auto c = std::move(a); // c是将亡值</span><br><span class="line">auto d = static_cast&lt;A&amp;&amp;&gt;(a); // d是将亡值</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>左值引用、右值引用</strong></p><p>根据名字大概就可以猜到意思，左值引用就是对左值进行引用的类型，右值引用就是对右值进行引用的类型，他们都是引用，都是对象的一个别名，并不拥有所绑定对象的堆存，所以都必须立即初始化.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type &amp;name = exp; // 左值引用</span><br><span class="line">type &amp;&amp;name = exp; // 右值引用</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>左值引用</strong></p><p>看代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 5;</span><br><span class="line">int &amp;b = a; // b是左值引用</span><br><span class="line">b = 4;</span><br><span class="line">int &amp;c = 10; // error, 10无法取地址, 无法进行引用</span><br><span class="line">const int &amp;d = 10; // ok, 因为是常引用, 引用常量数字, 这个常量数字会存储在内存中, 可以取地址</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>可以得出结论：对于左值引用，等号右边的值必须可以取地址，如果不能取地址，则会编译失败，或者可以使用 const 引用形式，但这样就只能通过引用来读取输出，不能修改数组，因为是常量引用.</p><p><strong>右值引用</strong></p><p>如果使用右值引用，那表达式等号右边的值需要时右值，可以使用 std::move函数强制把左值转换为右值.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 4;</span><br><span class="line">int &amp;&amp;b = a; // error, a是左值</span><br><span class="line">int &amp;&amp;c = std::move(a); // ok</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>移动语义</strong></p><p>谈移动语义前，我们首先需要了解深拷贝与浅拷贝的概念</p><h4 id="深拷贝浅拷贝"><strong>深拷贝、浅拷贝</strong></h4><p>直接拿代码举例:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class A {</span><br><span class="line">public:</span><br><span class="line">    A(int size) : size_(size) {</span><br><span class="line">        data_ = new int[size];</span><br><span class="line">    }</span><br><span class="line">    A(){}</span><br><span class="line">    A(const A&amp; a) {</span><br><span class="line">        size_ = a.size_;</span><br><span class="line">        data_ = a.data_;</span><br><span class="line">        cout &lt;&lt; "copy " &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    ~A() {</span><br><span class="line">        delete[] data_;</span><br><span class="line">    }</span><br><span class="line">    int *data_;</span><br><span class="line">    int size_;</span><br><span class="line">};</span><br><span class="line">int main() {</span><br><span class="line">    A a(10);</span><br><span class="line">    A b = a;</span><br><span class="line">    cout &lt;&lt; "b " &lt;&lt; b.data_ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; "a " &lt;&lt; a.data_ &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，两个输出的是相同的地址，a 和 b 的data_指针指向了同一块内存，这就是浅拷贝，只是数据的简单赋值，那再析构时data_内存会被释放两次，导致程序出问题，这里正常会出现 double free导致程序崩溃的，但是不知道为什么我自己测试程序却没有崩溃，能力有限，没搞明白，无论怎样，这样的程序肯定是有隐患的，如何消除这种隐患呢，可以使用如下深拷贝：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class A {</span><br><span class="line">public:</span><br><span class="line">    A(int size) : size_(size) {</span><br><span class="line">        data_ = new int[size];</span><br><span class="line">    }</span><br><span class="line">    A(){}</span><br><span class="line">    A(const A&amp; a) {</span><br><span class="line">        size_ = a.size_;</span><br><span class="line">        data_ = new int[size_];</span><br><span class="line">        cout &lt;&lt; "copy " &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    ~A() {</span><br><span class="line">        delete[] data_;</span><br><span class="line">    }</span><br><span class="line">    int *data_;</span><br><span class="line">    int size_;</span><br><span class="line">};</span><br><span class="line">int main() {</span><br><span class="line">    A a(10);</span><br><span class="line">    A b = a;</span><br><span class="line">    cout &lt;&lt; "b " &lt;&lt; b.data_ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; "a " &lt;&lt; a.data_ &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>深拷贝就是再拷贝对象时，如果被拷贝对象内部还有指针引用指向其它资源，自己需要重新开辟一块新内存存储资源，而不是简单的赋值.</p><p>聊完了深拷贝浅拷贝，可以聊聊<strong>移动语义</strong>啦：</p><p>移动语义，在程序喵看来可以理解为转移所有权，之前的拷贝是对于别人的资源，自己重新分配一块内存存储复制过来的资源，而对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用，通过 C++11新增的移动语义可以省去很多拷贝负担，怎么利用移动语义呢，是通过移动构造函数.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class A {</span><br><span class="line">public:</span><br><span class="line">    A(int size) : size_(size) {</span><br><span class="line">        data_ = new int[size];</span><br><span class="line">    }</span><br><span class="line">    A(){}</span><br><span class="line">    A(const A&amp; a) {</span><br><span class="line">        size_ = a.size_;</span><br><span class="line">        data_ = new int[size_];</span><br><span class="line">        cout &lt;&lt; "copy " &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    A(A&amp;&amp; a) {</span><br><span class="line">        this-&gt;data_ = a.data_;</span><br><span class="line">        a.data_ = nullptr;</span><br><span class="line">        cout &lt;&lt; "move " &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    ~A() {</span><br><span class="line">        if (data_ != nullptr) {</span><br><span class="line">         delete[] data_;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    int *data_;</span><br><span class="line">    int size_;</span><br><span class="line">};</span><br><span class="line">int main() {</span><br><span class="line">    A a(10);</span><br><span class="line">    A b = a;</span><br><span class="line">    A c = std::move(a); // 调用移动构造函数</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>如果不使用 std::move (), 会有很大的拷贝代价，使用移动语义可以避免很多无用的拷贝，提供程序性能，C++ 所有的 STL都实现了移动语义，方便我们使用。例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;string&gt; vecs;</span><br><span class="line">...</span><br><span class="line">std::vector&lt;string&gt; vecm = std::move(vecs); // 免去很多拷贝</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>注意：</strong>移动语义仅针对于那些实现了移动构造函数的类的对象，对于那种基本类型 int、float 等没有任何优化作用，还是会拷贝，因为它们实现没有对应的移动构造函数.</p><h3 id="完美转发">完美转发</h3><p>完美转发指可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参，转发函数实参是左值那目标函数实参也是左值，转发函数实参是右值那目标函数实参也是右值。那如何实现完美转发呢，答案是使用 std::forward ().</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void PrintV(int &amp;t) {</span><br><span class="line">    cout &lt;&lt; "lvalue" &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">void PrintV(int &amp;&amp;t) {</span><br><span class="line">    cout &lt;&lt; "rvalue" &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Test(T &amp;&amp;t) {</span><br><span class="line">    PrintV(t);</span><br><span class="line">    PrintV(std::forward&lt;T&gt;(t));</span><br><span class="line">    PrintV(std::move(t));</span><br><span class="line">}</span><br><span class="line">int main() {</span><br><span class="line">    Test(1); // lvalue rvalue rvalue</span><br><span class="line">    int a = 1;</span><br><span class="line">    Test(a); // lvalue lvalue rvalue</span><br><span class="line">    Test(std::forward&lt;int&gt;(a)); // lvalue rvalue rvalue</span><br><span class="line">    Test(std::forward&lt;int&amp;&gt;(a)); // lvalue lvalue rvalue</span><br><span class="line">    Test(std::forward&lt;int&amp;&amp;&gt;(a)); // lvalue rvalue rvalue</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>分析</strong></p><ul><li>Test (1)：1 是右值，模板中 T &amp;&amp;t 这种为万能引用，右值 1 传到Test 函数中变成了右值引用，但是调用 PrintV () 时候，t 变成了左值，因为它变成了一个拥有名字的变量，所以打印 lvalue, 而PrintV (std::forward<t>(t)) 时候，会进行完美转发，按照原来的类型转发，所以打印 rvalue, PrintV (std::move (t)) 毫无疑问会打印 rvalue.</t></li><li>Test (a)：a 是左值，模板中 T &amp;&amp; 这种为万能引用，左值 a 传到Test 函数中变成了左值引用，所以有代码中打印.</li><li>Test(std::forward<t>(a))：转发为左值还是右值，依赖于 T, T是左值那就转发为左值，T 是右值那就转发为右值.</t></li></ul><h3 id="返回值优化">返回值优化</h3><p>返回值优化 (RVO) 是一种 C++ 编译优化技术，当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++ 标准允许省略调用这些复制构造函数.</p><p>那什么时候编译器会进行返回值优化呢？</p><ul><li>return 的值类型与函数的返回值类型相同</li><li> return 的是一个局部对象</li></ul><p>看几个例子:</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; return_vector(void) {</span><br><span class="line">    std::vector&lt;int&gt; tmp {1,2,3,4,5};</span><br><span class="line">    return tmp;</span><br><span class="line">}</span><br><span class="line">std::vector&lt;int&gt; &amp;&amp;rval_ref = return_vector();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>不会触发 RVO, 拷贝构造了一个临时的对象，临时对象的生命周期和 rval_ref绑定，等价于下面这段代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const std::vector&lt;int&gt;&amp; rval_ref = return_vector();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt;&amp;&amp; return_vector(void) {</span><br><span class="line">    std::vector&lt;int&gt; tmp {1,2,3,4,5};</span><br><span class="line">    return std::move(tmp);</span><br><span class="line">}</span><br><span class="line">std::vector&lt;int&gt; &amp;&amp;rval_ref = return_vector();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这段代码会造成运行时错误，因为 rval_ref 引用了被析构的 tmp.讲道理来说这段代码是错的，但我自己运行过程中却成功了，我没有那么幸运，这里不纠结，继续向下看什么时候会触发 RVO.</p><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; return_vector(void) {</span><br><span class="line">    std::vector&lt;int&gt; tmp {1,2,3,4,5};</span><br><span class="line">    return std::move(tmp);</span><br><span class="line">}</span><br><span class="line">std::vector&lt;int&gt; &amp;&amp;rval_ref = return_vector();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>和示例 1 类似，std::move 一个临时对象是没有必要的，也会忽略掉返回值优化.</p><p><strong>最好的代码：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; return_vector(void) {</span><br><span class="line">    std::vector&lt;int&gt; tmp {1,2,3,4,5};</span><br><span class="line">    return tmp;</span><br><span class="line">}</span><br><span class="line">std::vector&lt;int&gt; rval_ref = return_vector();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这段代码会触发 RVO, 不拷贝也不移动，不生成临时对象.</p><h3 id="参考资料">参考资料</h3><blockquote><p>《Effective Modern C++》</p></blockquote><blockquote><p>《深入应用 C++11：代码优化与工程级应用》</p></blockquote><blockquote><p><a href="https://blog.csdn.net/u0105">https://blog.csdn.net/u0105</a></p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/4538483a1d8a">https://www.jianshu.com/p/4538483a1d8a</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/xkfz007/articles/2506022.html">https://www.cnblogs.com/xkfz007/articles/2506022.html</a></p></blockquote><blockquote><p><a href="https://zhuanlan.zhihu.com/p/97128024">https://zhuanlan.zhihu.com/p/97128024</a></p></blockquote><blockquote><p><a href="https://zh.cppreference.com/w/cpp/utility/forward">https://zh.cppreference.com/w/cpp/utility/forward</a></p></blockquote><blockquote><p><a href="https://www.zhihu.com/question/43513150">https://www.zhihu.com/question/43513150</a></p></blockquote><blockquote><p><a href="https://stackoverflow.com/questions/4986673/c11-rvalues-and-move-semantics-confusion-return-statement?lq=1">https://stackoverflow.com/questions/4986673/c11-rvalues-and-move-semantics-confusion-return-statement?lq=1</a></p></blockquote><p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483885&amp;idx=1&amp;sn=ba3342f7807d347747946df4b9bb4b4c&amp;chksm=eb7a077edc0d8e68f9bde2e39e64e18f5c2e2d85bd9abeb44986fe64a8c7dcbceb5333b78298&amp;scene=21#wechat_redirect">一文让你搞懂设计模式</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483837&amp;idx=1&amp;sn=228aa7a8dd9b580336fc82a6d283c382&amp;chksm=eb7a072edc0d8e3834b8c4588453d9cf72bd6b85290a18ce549534c1b6627e3164c476e30c47&amp;scene=21#wechat_redirect">RAII妙用之 ScopeExit</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483840&amp;idx=1&amp;sn=48a5ba180c61877134344084e25d27f4&amp;chksm=eb7a0753dc0d8e450dcfe3a6d6b0405c043b60944173510836049802d48828e366d47d88674e&amp;scene=21#wechat_redirect">深入浅出虚拟内存</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483840&amp;idx=2&amp;sn=ff498badd138d897c3d19284b4ddc8f9&amp;chksm=eb7a0753dc0d8e4514c613199c33fd1c604cb8e2f27f6e4362d09fa5376a6dcdea2d6b73d538&amp;scene=21#wechat_redirect">深入浅出虚拟内存（二）绘制虚拟内存排布图</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483840&amp;idx=3&amp;sn=388ece7d274bbfd69e48d01795e04d6f&amp;chksm=eb7a0753dc0d8e45088aa5b402d2af678ddd5d91ec41c89454986c07602e9925dbf2e06dfc19&amp;scene=21#wechat_redirect">深入浅出虚拟内存（三）堆内存分配及malloc 实现原理</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483852&amp;idx=1&amp;sn=34dde853d5304f8a165e82effe287f3c&amp;chksm=eb7a075fdc0d8e4971f55dc3c4ad4388a3c7466c6df5a47bcfa81510de230cf22065298fee26&amp;scene=21#wechat_redirect">RAII妙用之计算函数耗时</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483911&amp;idx=1&amp;sn=9808fea93560af81c594e7d7c0f81ed9&amp;chksm=eb7a0494dc0d8d82abfc0db427d921c93eb077e9f9162088b13651e81618bb231cb6f22f96a2&amp;scene=21#wechat_redirect">一文吃透C++11 中 auto 和 decltype 知识点</a></p><p>如果有任何问题或想法，可以 <strong>点此留言</strong> ,我会尽快回复哒！欢迎小伙伴们踊跃留言，希望这里是大家交流互通的平台～</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;左值右值，还是需要好好理一下的&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://fetasty.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://fetasty.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 不定参数到 lambda 的传递</title>
    <link href="https://fetasty.github.io/posts/15ddce4e/"/>
    <id>https://fetasty.github.io/posts/15ddce4e/</id>
    <published>2022-02-20T14:19:59.000Z</published>
    <updated>2023-06-19T08:50:39.029Z</updated>
    
    <content type="html"><![CDATA[<p>使用 不定参数列表传递到 lambda 中总是报错，这里记录一下正确用法</p><span id="more"></span><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectPool::SetType</span><span class="params">(std::string type, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    m_mapAlloc[type].m_construct = [&amp; args...](IRecyclable* p) {</span><br><span class="line">        std::allocator&lt;T&gt; alloc;</span><br><span class="line">        std::allocator_traits&lt;std::allocator&lt;T&gt;&gt; traits;</span><br><span class="line">        traits.<span class="built_in">construct</span>(alloc, <span class="built_in">static_cast</span>&lt;T*&gt;(p), args...);</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上代码是正确的使用方法，对于不定参数<code>Args&amp;&amp;... args</code> 在函数中使用时一定都是带上<code>...</code> 使用的</p><p>刚开始报错就是我在 lambda 捕获列表中一直写的是<code>[&amp;args]</code>, 而且后面传入 construct 函数时也需要使用<code>args...</code> 或者使用 <code>std::move(args)...</code></p><p>关于 lambda 捕获，可以参考 <a href="https://zh.cppreference.com/w/cpp/language/lambda">Lambda 表达式(C++11 起) - cppreference.com</a></p><p>关于 不定参数，可以参考 [<a href="https://zh.cppreference.com/w/cpp/language/parameter_pack">形参包- cppreference.com</a>]</p><p>包展开:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(&amp;args...); <span class="comment">// 展开成 f(&amp;E1, &amp;E2, &amp;E3)</span></span><br><span class="line"><span class="built_in">f</span>(n, ++args...); <span class="comment">// 展开成 f(n, ++E1, ++E2, ++E3);</span></span><br><span class="line"><span class="built_in">f</span>(++args..., n); <span class="comment">// 展开成 f(++E1, ++E2, ++E3, n);</span></span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> Args*&gt;(&amp;args)...);</span><br><span class="line"><span class="comment">// f(const_cast&lt;const E1*&gt;(&amp;X1), const_cast&lt;const E2*&gt;(&amp;X2), const_cast&lt;const E3*&gt;(&amp;X3))</span></span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">h</span>(args...) + args...); <span class="comment">// 展开成</span></span><br><span class="line"><span class="comment">// f(h(E1,E2,E3) + E1, h(E1,E2,E3) + E2, h(E1,E2,E3) + E3)</span></span><br></pre></td></tr></tbody></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 不定参数列表传递到 lambda 中总是报错，这里记录一下正确用法&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://fetasty.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://fetasty.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11 中的线程库 thread 与同步库 mutex</title>
    <link href="https://fetasty.github.io/posts/4cc95c54/"/>
    <id>https://fetasty.github.io/posts/4cc95c54/</id>
    <published>2022-02-20T14:18:18.000Z</published>
    <updated>2023-06-19T08:49:13.548Z</updated>
    
    <content type="html"><![CDATA[<p>C++11 提供了线程库和同步库，可以屏蔽操作系统接口细节使用多线程了</p><span id="more"></span><h2 id="多线程">多线程</h2><p><code>std::thread</code> 创建与使用</p><p><code>std::this_thread</code> 当前线程</p><h2 id="线程同步">线程同步</h2><p><code>lock_guard</code> 互斥锁</p><p><code>unique_lock</code> + <code>condition_variable</code> 条件锁</p><h2 id="原子操作库">原子操作库</h2><p>实现轻量免锁的多线程安全操作</p><p><a href="https://zh.cppreference.com/w/cpp/atomic/atomic">https://zh.cppreference.com/w/cpp/atomic/atomic</a></p><p><a href="https://zh.cppreference.com/w/cpp/atomic/atomic_flag">https://zh.cppreference.com/w/cpp/atomic/atomic_flag</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">std::atomic_int ttt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">bool</span> add)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) {</span><br><span class="line">        <span class="keyword">if</span> (add) ++ttt;</span><br><span class="line">        <span class="keyword">else</span> --ttt;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"th exit!\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    ttt = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; ths;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) {</span><br><span class="line">        ths.<span class="built_in">emplace_back</span>(test, i % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : ths) {</span><br><span class="line">        th.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; ttt &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出为 0; 如果把头一行的 std::atomic_int 换成 int, 得到的结果偏差巨大</p><h2 id="异步任务-future-promise">异步任务 future &amp; promise</h2><p>定义于 <code>&lt;future&gt;</code> 头文件</p><p>使用 future 三种方式: packaged_task, promise, async</p><p><a href="https://zh.cppreference.com/w/cpp/thread/future">https://zh.cppreference.com/w/cpp/thread/future</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 来自 packaged_task 的 future</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">([](){ <span class="keyword">return</span> <span class="number">7</span>; })</span></span>; <span class="comment">// 包装函数</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f1 = task.<span class="built_in">get_future</span>();  <span class="comment">// 获取 future</span></span><br><span class="line">    std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task)).<span class="built_in">detach</span>(); <span class="comment">// 在线程上运行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 来自 async() 的 future</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f2 = std::<span class="built_in">async</span>(std::launch::async, [](){ <span class="keyword">return</span> <span class="number">8</span>; });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 来自 promise 的 future</span></span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f3 = p.<span class="built_in">get_future</span>();</span><br><span class="line">    std::<span class="built_in">thread</span>( [&amp;p]{ p.<span class="built_in">set_value_at_thread_exit</span>(<span class="number">9</span>); }).<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Waiting..."</span> &lt;&lt; std::flush;</span><br><span class="line">    f1.<span class="built_in">wait</span>();</span><br><span class="line">    f2.<span class="built_in">wait</span>();</span><br><span class="line">    f3.<span class="built_in">wait</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Done!\nResults are: "</span></span><br><span class="line">              &lt;&lt; f1.<span class="built_in">get</span>() &lt;&lt; <span class="string">' '</span> &lt;&lt; f2.<span class="built_in">get</span>() &lt;&lt; <span class="string">' '</span> &lt;&lt; f3.<span class="built_in">get</span>() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>std::async</code></p><p>最简单的异步任务使用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::launch::async // 运行新线程, 以异步执行任务</span><br><span class="line">std::launch::deferred // 调用方线程上首次请求其结果时执行任务（惰性求值）</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 马上开始异步任务</span></span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; f2 = std::<span class="built_in">async</span>(std::launch::async, [](){ <span class="keyword">return</span> <span class="number">8</span>; });</span><br><span class="line">f2.<span class="built_in">wait</span>(); <span class="comment">// 阻塞至结果变得可用</span></span><br><span class="line"><span class="type">int</span> result = f2.<span class="built_in">get</span>(); <span class="comment">// 获取结果</span></span><br></pre></td></tr></tbody></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;C++11 提供了线程库和同步库，可以屏蔽操作系统接口细节使用多线程了&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://fetasty.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://fetasty.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11 中的默认函数控制 delete 和 default</title>
    <link href="https://fetasty.github.io/posts/be0f7d71/"/>
    <id>https://fetasty.github.io/posts/be0f7d71/</id>
    <published>2022-02-20T14:17:14.000Z</published>
    <updated>2023-06-19T08:50:50.587Z</updated>
    
    <content type="html"><![CDATA[<p>delete 和 default 在 C++ 中用于显式控制默认函数的生成情况，我们需要知道 C++ 编译器到底干了些什么</p><span id="more"></span><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c++11 类默认函数的控制："=default" 和 "=delete"函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++ 的类有四类特殊成员函数, 它们分别是：默认构造函数、析构函数、拷贝构造函数以及拷贝赋值运算符.</span></span><br><span class="line"><span class="comment">这些类的特殊成员函数负责创建、初始化、销毁, 或者拷贝类的对象.</span></span><br><span class="line"><span class="comment">如果程序员没有显式地为一个类定义某个特殊成员函数, 而又需要用到该特殊成员函数时, 则编译器会隐式的为这个类生成一个默认的特殊成员函数.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 标准引入了一个新特性："=default"函数. 程序员只需在函数声明后加上“=default;”, 就可将该函数声明为 "=default"函数, 编译器将为显式声明的 "=default"函数自动生成函数体.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>() = <span class="keyword">default</span>; <span class="comment">//该函数比用户自己定义的默认构造函数获得更高的代码效率</span></span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> i)</span><br><span class="line">    {</span><br><span class="line">        a = i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">X obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "=default"函数特性仅适用于类的特殊成员函数, 且该特殊成员函数没有默认参数.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X1</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="keyword">default</span>;      <span class="comment">// err , 函数 f() 非类 X 的特殊成员函数</span></span><br><span class="line">    <span class="built_in">X1</span>(<span class="type">int</span>, <span class="type">int</span>) = <span class="keyword">default</span>;  <span class="comment">// err , 构造函数 X1(int, int) 非 X 的特殊成员函数</span></span><br><span class="line">    <span class="built_in">X1</span>(<span class="type">int</span> = <span class="number">1</span>) = <span class="keyword">default</span>;   <span class="comment">// err , 默认构造函数 X1(int=1) 含有默认参数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// "=default"函数既可以在类体里（inline）定义, 也可以在类体外（out-of-line）定义.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X2</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X2</span>() = <span class="keyword">default</span>; <span class="comment">//Inline defaulted 默认构造函数</span></span><br><span class="line">    <span class="built_in">X2</span>(<span class="type">const</span> X&amp;);</span><br><span class="line">    X2&amp; <span class="keyword">operator</span> = (<span class="type">const</span> X&amp;);</span><br><span class="line">    ~<span class="built_in">X2</span>() = <span class="keyword">default</span>;  <span class="comment">//Inline defaulted 析构函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">X2::<span class="built_in">X2</span>(<span class="type">const</span> X&amp;) = <span class="keyword">default</span>;  <span class="comment">//Out-of-line defaulted 拷贝构造函数</span></span><br><span class="line">X2&amp; X2::<span class="keyword">operator</span>= (<span class="type">const</span> X2&amp;) = <span class="keyword">default</span>;   <span class="comment">//Out-of-line defaulted  拷贝赋值操作符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了能够让程序员显式的禁用某个函数, C++11 标准引入了一个新特性："=delete"函数. 程序员只需在函数声明后上“=delete;”, 就可将该函数禁用.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X3</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X3</span>();</span><br><span class="line">    <span class="built_in">X3</span>(<span class="type">const</span> X3&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 声明拷贝构造函数为 deleted 函数</span></span><br><span class="line">    X3&amp; <span class="keyword">operator</span> = (<span class="type">const</span> X3 &amp;) = <span class="keyword">delete</span>; <span class="comment">// 声明拷贝赋值操作符为 deleted 函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// "=delete"函数特性还可用于禁用类的某些转换构造函数, 从而避免不期望的类型转换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X4</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X4</span>(<span class="type">double</span>)</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">X4</span>(<span class="type">int</span>) = <span class="keyword">delete</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// "=delete"函数特性还可以用来禁用某些用户自定义的类的 new 操作符, 从而避免在自由存储区创建类的对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X5</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span>) = <span class="keyword">delete</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mytest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    X4 obj1;</span><br><span class="line">    X4 obj2=obj1;   <span class="comment">// 错误, 拷贝构造函数被禁用</span></span><br><span class="line"></span><br><span class="line">    X4 obj3;</span><br><span class="line">    obj3=obj1;     <span class="comment">// 错误, 拷贝赋值操作符被禁用</span></span><br><span class="line"></span><br><span class="line">    X5 *pa = <span class="keyword">new</span> X5;      <span class="comment">// 错误, new 操作符被禁用</span></span><br><span class="line">    X5 *pb = <span class="keyword">new</span> X5[<span class="number">10</span>];  <span class="comment">// 错误, new[] 操作符被禁用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">mytest</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;delete 和 default 在 C++ 中用于显式控制默认函数的生成情况，
我们需要知道 C++ 编译器到底干了些什么&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://fetasty.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://fetasty.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11 中的模板改进</title>
    <link href="https://fetasty.github.io/posts/bce68dd9/"/>
    <id>https://fetasty.github.io/posts/bce68dd9/</id>
    <published>2022-02-20T14:15:34.000Z</published>
    <updated>2023-06-19T08:49:08.067Z</updated>
    
    <content type="html"><![CDATA[<p>C++11 中该进了模板，看看还是比较有用的，终于理解上古代码里为什么模板尖括号里总是多留一个空格了</p><span id="more"></span><blockquote><p>原文地址 <a href="https://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&amp;mid=2247484785&amp;idx=1&amp;sn=194f240fa984970397e38a989c112aa2&amp;source=41#wechat_redirect">mp.weixin.qq.com</a></p></blockquote><p>C++11 关于模板有一些细节的改进：</p><ul><li>模板的右尖括号</li><li>模板的别名</li><li>函数模板的默认模板参数</li></ul><h4 id="模板的右尖括号">模板的右尖括号</h4><p>C++11 之前是不允许两个右尖括号出现的，会被认为是右移操作符，所以需要中间加个空格进行分割，避免发生编译错误.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; a; <span class="comment">// error</span></span><br><span class="line">   std::vector&lt;std::vector&lt;<span class="type">int</span>&gt; &gt; b; <span class="comment">// ok</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这个我之前都不知道，我开始学编程的时候就已经是 C++11 的时代啦.</p><h3 id="模板的别名">模板的别名</h3><p>C++11 引入了 using, 可以轻松的定义别名，而不是使用繁琐的 typedef.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; vvi; <span class="comment">// before c++11</span></span><br><span class="line"><span class="keyword">using</span> vvi = std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;; <span class="comment">// c++11</span></span><br></pre></td></tr></tbody></table></figure><p>使用 using 明显简洁并且易读，大家可能之前也见过使用 typedef定义函数指针之类的操作，那烂代码我就不列出来了，反正我是看不懂也不想看... 以后都可以使用 using, 额还是列出来吧.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; <span class="comment">// 啥玩意, 看不懂</span></span><br><span class="line"><span class="keyword">using</span> func = <span class="built_in">void</span> (*)(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">// 起码比typedef容易看的懂吧</span></span><br></pre></td></tr></tbody></table></figure><p>上面的代码使用 using 起码比 typedef 容易看的懂一些吧，但是我还是看不懂，因为我从来不用这种来表示函数指针，用<code>std::function()</code>、<code>std::bind()</code>、<code>std::placeholder()</code>、<code>lambda</code>表达式它不香吗.</p><h3 id="函数模板的默认模板参数">函数模板的默认模板参数</h3><p>C++11 之前只有类模板支持默认模板参数，函数模板是不支持默认模板参数的，C++11 后都支持.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U=<span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> A {</span><br><span class="line">    T value;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T=<span class="type">int</span>, <span class="keyword">typename</span> U&gt; <span class="comment">// error</span></span><br><span class="line"><span class="keyword">class</span> A {</span><br><span class="line">    T value;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>类模板的默认模板参数必须从右往左定义，而函数模板则没有这个限制.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> U=<span class="type">int</span>&gt;</span><br><span class="line">R <span class="built_in">func1</span>(U val) {</span><br><span class="line">   <span class="keyword">return</span> val;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R=<span class="type">int</span>, <span class="keyword">typename</span> U&gt;</span><br><span class="line">R <span class="built_in">func2</span>(U val) {</span><br><span class="line">   <span class="keyword">return</span> val;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   cout &lt;&lt; <span class="built_in">func1</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;(<span class="number">99.9</span>) &lt;&lt; endl; <span class="comment">// 99</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in">func1</span>&lt;<span class="type">double</span>, <span class="type">double</span>&gt;(<span class="number">99.9</span>) &lt;&lt; endl; <span class="comment">// 99.9</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in">func1</span>&lt;<span class="type">double</span>&gt;(<span class="number">99.9</span>) &lt;&lt; endl; <span class="comment">// 99.9</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in">func1</span>&lt;<span class="type">int</span>&gt;(<span class="number">99.9</span>) &lt;&lt; endl; <span class="comment">// 99</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in">func2</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;(<span class="number">99.9</span>) &lt;&lt; endl; <span class="comment">// 99</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in">func1</span>&lt;<span class="type">double</span>, <span class="type">double</span>&gt;(<span class="number">99.9</span>) &lt;&lt; endl; <span class="comment">// 99.9</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in">func2</span>&lt;<span class="type">double</span>&gt;(<span class="number">99.9</span>) &lt;&lt; endl; <span class="comment">// 99.9</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in">func2</span>&lt;<span class="type">int</span>&gt;(<span class="number">99.9</span>) &lt;&lt; endl; <span class="comment">// 99</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>对于函数模板，参数的填充顺序是从左到右的.</p><p><strong>参考资料</strong></p><blockquote><p>《深入应用 C++11：代码优化与工程级应用》</p></blockquote><blockquote><p><a href="https://blog.csdn.net/tennysonsky/article/details/77817027">https://blog.csdn.net/tennysonsky/article/details/77817027</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/wf19930209/article/details/79309881?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1">https://blog.csdn.net/wf19930209/article/details/79309881?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1</a></p></blockquote><p>关于 C++11 对于模板的改进就讲到这里，请继续关注～</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483885&amp;idx=1&amp;sn=ba3342f7807d347747946df4b9bb4b4c&amp;chksm=eb7a077edc0d8e68f9bde2e39e64e18f5c2e2d85bd9abeb44986fe64a8c7dcbceb5333b78298&amp;scene=21#wechat_redirect">一文让你搞懂设计模式</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483837&amp;idx=1&amp;sn=228aa7a8dd9b580336fc82a6d283c382&amp;chksm=eb7a072edc0d8e3834b8c4588453d9cf72bd6b85290a18ce549534c1b6627e3164c476e30c47&amp;scene=21#wechat_redirect">RAII妙用之 ScopeExit</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483852&amp;idx=1&amp;sn=34dde853d5304f8a165e82effe287f3c&amp;chksm=eb7a075fdc0d8e4971f55dc3c4ad4388a3c7466c6df5a47bcfa81510de230cf22065298fee26&amp;scene=21#wechat_redirect">RAII妙用之计算函数耗时</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483911&amp;idx=1&amp;sn=9808fea93560af81c594e7d7c0f81ed9&amp;chksm=eb7a0494dc0d8d82abfc0db427d921c93eb077e9f9162088b13651e81618bb231cb6f22f96a2&amp;scene=21#wechat_redirect">一文吃透C++11 中 auto 和 decltype 知识点</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483921&amp;idx=1&amp;sn=5f5a14ac4db1e12092434bd9c20e44a2&amp;chksm=eb7a0482dc0d8d94df49a59c1b9dce1458e9b385e97a6c53ecb4bea06b24bd47187a1c47cc4c&amp;scene=21#wechat_redirect">左值引用、右值引用、移动语义、完美转发，你知道的不知道的都在这里</a></p><p>如果有任何问题或想法，可以 点此留言，我会尽快回复哒！欢迎小伙伴们踊跃留言，希望这里是大家交流互通的平台～</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;p&gt;C++11 中该进了模板，看看还是比较有用的，
终于理解上古代码里为什么模板尖括号里总是多留一个空格了&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://fetasty.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://fetasty.github.io/tags/C/"/>
    
  </entry>
  
</feed>
