<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android 手机改造 Linux 服务器</title>
    <url>/posts/df321891/</url>
    <content><![CDATA[<p>手头上的旧手机为小米 6, 本文可能部分内容只在小米 6 上适用 [xiaomi 6
sagit]</p>
<p>且本文主要讨论 LinuxDeploy (需要 root) 的方式，
非 root 用户可使用 Termux 方式</p>
<span id="more"></span>
<h2 id="方案选择">1 方案选择</h2>
<p>前后测试了 3 种方法，最推荐使用 LinuxDeploy (chroot)</p>
<ul>
<li>Ubuntu touch 原生 Linux 系统，但是为了驱动手机设备，需要做很多工作，
社区上适用于 xiaomi6 的 ubuntu touch 已经停止开发了，使用起来还有很多不足，
<code>apt update &amp;&amp; apt upgrade</code> 一下，
可能设备就无法启动了</li>
<li> Termux (proot), Termux 本身的文件结构与 linux 系统不同，
使用 proot 方式运行 linux, 性能有损耗 (但是并不多),
对于非 root 用户该方式非常不错，而且可以通过 Termux-boot 插件实现自启动</li>
<li> LinuxDeploy (chroot), 需要 root 权限，初略了解，
它应该比 proot 方式性能更好，原本的 Android 系统负责驱动设备硬件，
维护设备运行，而 chroot 中的 linux 并行于 Android 系统运行，
不必关心硬件设备的驱动</li>
</ul>
<p>使用 LinuxDeploy 的同时将系统刷为 lineageos, 使用原生安卓系统驱动设备，
保证手机正常工作，同时尽量少的占用资源，不安装不开启不必要的应用，
不过刷系统是个可选项，使用原生系统也问题不大</p>
<p>chroot (change root) 是一种非常原始的容器技术，
仅仅是将一个进程的根目录更改到一个指定目录，限制访问和可见性，
其余的硬件资源，网络资源等则还是和宿主系统共享，chroot 本身运行在内核态，
需要 root 权限</p>
<p>小结:</p>
<ol type="1">
<li>对于没有 Root 权限的 Android 设备，
使用 Termux+proot 方式安装完整 linux 是最佳方案，proot 是用户空间的 chroot,
系统调用会拦截一层，有一些性能损失，但是这种隔离远不如容器的隔离，
性能损失比较小，是完全可以接受的 参考: <a href="https://wiki.termux.com/wiki/Main_Page">Termux Wiki</a></li>
<li> 对于有 Root 权限的 Android 设备，使用 LinuxDeploy (<a href="https://github.com/lateautumn233/Linuxdeploy-Pro">LinuxDeploy-Pro</a>
原作者 meefik 的 github 库貌似已经没有更新，且安装时有一些问题),
LinuxDeploy 使用 Chroot 实现，需要 Root 权限，相对于 Proot,
其系统调用没有转换操作，性能更好，适合长期运行</li>
</ol>
<h2 id="前置准备">2 前置准备</h2>
<ol type="1">
<li><p>bootloader 解锁</p></li>
<li><p>驱动安装，小米手机可以用 miflash 安装驱动</p></li>
<li><p>解决 Windows 上 usb3 使用 fastboot 时卡住的问题</p>
<p></p><figure class="highlight bat"><table><tbody><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\usbflags\<span class="number">18</span>D1D00D0100" /v "osvc" /t REG_BINARY /d "<span class="number">0000</span>" /f</span><br><span class="line">reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\usbflags\<span class="number">18</span>D1D00D0100" /v "SkipContainerIdQuery" /t REG_BINARY /d "<span class="number">01000000</span>" /f</span><br><span class="line">reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\usbflags\<span class="number">18</span>D1D00D0100" /v "SkipBOSDescriptorQuery" /t REG_BINARY /d "<span class="number">01000000</span>" /f</span><br><span class="line"></span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>(刷系统为可选项) 系统刷为 LineageOS 参考:
https://wiki.lineageos.org/devices/sagit/install</p></li>
<li><p> 刷入 twrp, 参考: https://twrp.me/xiaomi/xiaomimi6.html, img 下载:
https://dl.twrp.me/sagit/</p>
<ul>
<li><code>fastboot flash recovery ./twrp-xxx.img</code></li>
</ul></li>
<li><p>刷入 magisk (可以先刷入 twrp, 参考 https://dl.twrp.me/sagit/)
https://github.com/topjohnwu/Magisk</p>
<ul>
<li>下载最新的 magisk apk 文件，后缀改为 zip</li>
<li> 在 twrp 中选择对应的 zip 文件刷入，如果是 LineageOS 的 recovery,
可以适用 adb sideload 刷入</li>
<li>重启后打开 magisk, 按照提示进行后续操作，按推荐步骤执行即可</li>
</ul></li>
<li><p>给 shell 赋予 root 权限，打开开发者模式，打开 USB 调试，打开 USB
root 调试</p>
<ul>
<li><code>adb shell</code> 连接手机</li>
<li><code>su</code> 如果执行失败，去 magisk 的 root 权限管理中打开
com.android.shell 包的 root 权限</li>
<li>再次尝试 <code>su</code></li>
</ul></li>
</ol>
<h2 id="linuxdeploy安装部署和配置">3 LinuxDeploy 安装部署和配置</h2>
<ol type="1">
<li><p>LinuxDeploy 应用安装</p>
<ul>
<li>官方的 <a href="https://github.com/meefik/linuxdeploy">LinuxDeploy</a>,
可以先尝试一下，小米 6 使用官网的 app 一直安装有问题，
所以最终没有使用官方的 apk</li>
<li> 我的小米 6 使用 <a href="https://github.com/lateautumn233/Linuxdeploy-Pro">LinuxDeploy-Pro</a>,
看维护时间还比较新，官方地址貌似停止维护了</li>
<li>下载 apk 安装，打开时授予 root 权限</li>
</ul></li>
<li><p> LinuxDeploy 配置</p>
<p>应用右下角按钮设置安装选项，这里列一下我的选择，
可以根据喜好或者实际安装情况决定</p>
<ul>
<li>chroot 不用改</li>
<li> Debian</li>
<li>arm64</li>
<li>stable</li>
<li>http://mirrors.ustc.edu.cn/debian
小米 6 这里设置 <strong>https 连不上</strong> , 只有 http 能用</li>
<li> file</li>
<li><code>${EXETERNAL_STORAGE}/debian.img</code></li>
<li>81920 镜像大小我给了 80G, 开始只给 10G, 后面软件安装发现不够用了，
不过之后也可以扩容，只是费时间</li>
<li> ext4 不用改</li>
<li>用户名和密码自由设置</li>
<li> en_US.UTF-8</li>
<li>Auto DNS 设置可以改为好用的地址，我这里选的自动</li>
<li>勾选 INIT, 小米 6 上 run-parts 我没有调教好，这里选的
<strong>sysv</strong>, 用于开启容器时自动执行一些任务</li>
<li>勾选 MOUNTS, <code>/sdcard:/sdcard</code>
主要是将安卓内部存储挂载到 Linux 系统内</li>
<li>勾选 SSH, 该步骤是必须的，否则安装的 Linux 不好访问</li>
</ul></li>
<li><p>部署 Linux</p>
<p>按照上述配置完成后，返回主界面，点击右上 "三点", 选择 "install",
开始安装部署</p>
<ul>
<li>若提示联网问题，先检查设备是否联网，镜像配置是否正确，
是否使用 http 协议</li>
<li>更改配置后，先点 stop 按钮卸载分区，之后再次点 install 安装</li>
<li>安装过程必须保证没有报错，若有报错，可能需要搜索相关问题，
解决后重新安装</li>
<li>若使用该方法怎样都安装不成功，可以参考 ((20230730133322-tx8cs9x
' 备份与恢复 ')) 一节的方法，直接导入合适架构的备份包即可</li>
</ul></li>
<li><p>启动容器，ssh 连接</p>
<ul>
<li>点击 start 即可启动容器</li>
<li>启动成功后可以通过 ssh 连接到 Linux</li>
<li> 可以局域网的 PC 通过 IP 连接</li>
<li>也可以手机上安装 JuiceSSH, 通过 localhost 或者 127.0.0.1 连接</li>
<li>启动容器后，最好 sudo su 切<strong>换到 root 用户</strong>操作，
之后所有操作都基于 root 用户</li>
</ul></li>
<li><p>开机自启动，CPU 锁，Wi-Fi 锁</p>
<p>打开 LinuxDeploy 左上角菜单</p>
<ul>
<li>Lock Wi-Fi 应用运行时保持 WiFi 打开</li>
<li> Wake lock 应用运行时保持 CPU 运转，即使锁屏</li>
<li> Autostart 当 Android 启动后自动运行应用，并运行默认配置的容器，
非常有用</li>
<li> Autostart delay 自启动延时 我设置了 10 秒</li>
</ul></li>
<li><p>备份与恢复</p>
<p>Telnet 服务: LinuxDeploy 左上角菜单设置，Services, TELNET 和 HTTP 都打开，
取消勾选 TELNET 中的 Localhost, HTTP 服务的 Access
restriction 中 A 之后设置允许连接的 IP 地址
比如 <code>A:192.168.31.27 D:*</code></p>
<p>这里的 HTTP 服务是由 httpd 提供，
支持配置多个 <code>A:xxx</code> 添加多个可以访问的 IP 地址</p>
<p>浏览器访问 <code>http://ip:5080</code> 打开 Linux Deploy
Terminal 的 Telnet 终端</p>
<ul>
<li><p>备份与恢复命令</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">su <span class="comment"># 切换为root</span></span><br><span class="line"><span class="built_in">cd</span> /sdcard</span><br><span class="line">linuxdeploy stop -u <span class="comment"># 停止容器并卸载分区</span></span><br><span class="line">linuxdeploy <span class="built_in">export</span> /sdcard/debian-rootfs-20230729.tgz <span class="comment"># 等待完成即可, 之后可以拷贝一份到电脑上</span></span><br><span class="line">linuxdeploy import /sdcard/debian-rootfs-20230729.tgz <span class="comment"># 导入操作</span></span><br><span class="line">linuxdeploy start <span class="comment"># 运行容器</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>如果上述的安装不成功，也可以下载合适架构的备份包，直接导入
[小米 6 的架构为 arm64 (aarch64)]</p>
<ul>
<li>ubuntu 18 LTS arm64
(http://hub.meefik.ru/rootfs/ubuntu_arm64.tgz)</li>
<li>debian 10 arm64 (http://hub.meefik.ru/rootfs/debian_arm64.tgz)</li>
</ul></li>
</ul></li>
<li><p> 镜像扩容</p>
<p>先打开 telnet 访问，切 root 用户</p>
<p></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 从/dev/zero取二进制0, 块大小为1M, 一共4096个块, 追加到debian.img (扩容4GB)</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero bs=1048576 count=4096 &gt;&gt; /sdcard/debian.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制检查(修复)镜像的硬盘分区</span></span><br><span class="line">e2fsck -f /sdcard/debian.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整分区大小, 同步文件系统容量?</span></span><br><span class="line">resize2fs /sdcard/debian.img</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>LinuxDeploy 中的一些限制</p>
<ul>
<li>不是基于 systemd 运行的，systemctl, service 等命令无法正常工作</li>
<li>不支持 docker, 如果想要支持，需要自己编译 android 内核，修改编译选项，
相当麻烦</li>
</ul></li>
</ol>
<h2 id="linux系统配置">4 Linux 系统配置</h2>
<p>我的小米 6 系统部署启动成功后，发现 ssh 连接正常，apt 更新也正常，
但是 ping 不通任何域名和地址，包括 127.0.0.1,
curl 和 wget 等应用也无法使用</p>
<ol type="1">
<li><p>解决联网问题 尝试了很多方法，只能让 root 用户正常联网</p>
<ul>
<li><p>编辑 <code>/etc/group</code> 在 aid_inet (3003),
aid_net_raw (3004) 的分组中添加需要的用户名，多个用户名用逗号分开</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">aid_inet:x:3003:fetasty,root</span><br><span class="line">aid_net_raw:x:3004:fetasty,root</span><br></pre></td></tr></tbody></table></figure></li>
</ul></li>
<li><p>解决 ssh 连接后，无法 tab 补全，无法查看历史命令，
没有颜色显示问题</p>
<ul>
<li><p>编辑 /etc/passwd 在对应用户名后将 sh 更改为 bash</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">fetasty:x:60000:60000::/home/fetasty:/bin/bash</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>编辑～/.bashrc 取消注释其中要显示颜色的行</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></tbody></table></figure></li>
</ul></li>
<li><p>supervisor 自启动服务配置 (chroot 中的 Linux, systemd, systemctl,
service 等命令并不好用，不好设置自启动)</p>
<p>这里我们使用 <a href="http://supervisord.org/">supervisor</a> 管理其余服务进程，
主要设置好 supervisor 自启动和配置</p>
<ul>
<li><p><code>apt-get install supervisor</code> 安装 supervisor,
用于管理自启动进程 (按照官网的意思，应该使用 pip 安装，
但是我实际使用时并不太顺利)</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="comment"># curl -O https://bootstrap.pypa.io/get-pip.py</span></span><br><span class="line"><span class="comment"># python3 get-pip.py # 运行失败, 安装pip失败, 提示应该使用apt install python3-xxx来安装</span></span><br><span class="line">apt install python3-pip <span class="comment"># 安装成功</span></span><br><span class="line">pip3 config <span class="built_in">set</span> global.index-url https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">pip3 config list</span><br><span class="line"><span class="comment"># pip3 install supervisor # 失败 https://stackoverflow.com/questions/75608323/how-do-i-solve-error-externally-managed-environment-everytime-i-use-pip3</span></span><br><span class="line">pip3 install supervisor --break-system-packages <span class="comment"># 命令行提示最好先venv创建一个环境再安装, 太麻烦了, 不如apt直接装</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>确认容器启动配置中为 <strong>sysv</strong>,
小米 6 上测试了 run-parts 方式的自启动无效 参考 <a href="https://blog.csdn.net/qq_43445867/article/details/131799629">Linux
Deploy 应用自启动</a></p></li>
<li><p><code>~~nano /etc/init.d/supervisord.sh~~</code>​ ~~
编辑 supervisord 应用的启动脚本，该脚本必须按照<del>​<a href="https://wiki.debian.org/LSBInitScripts"><del>规范</del></a>​</del>编写～～</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides: supervisord</span></span><br><span class="line"><span class="comment"># Required-Start: $network $remote_fs $local_fs</span></span><br><span class="line"><span class="comment"># Required-Stop: $network $remote_fs $local_fs</span></span><br><span class="line"><span class="comment"># Default-Start: 2 3 4 5</span></span><br><span class="line"><span class="comment"># Default-Stop: 0 1 6</span></span><br><span class="line"><span class="comment"># Short-Description: supervisord start</span></span><br><span class="line"><span class="comment"># Description: supervisord run script</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"></span><br><span class="line">/usr/bin/supervisord -c /etc/supervisor/supervisord.conf</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>chmod +x /etc/init.d/supervisord.sh</code> 赋予执行权限</li>
<li><code>update-rc.d supervisord.sh defaults</code> 设置开机自启动</li>
<li><code>update-rc.d -f supervisord.sh remove</code>
移除开机自启动</li>
</ul></li>
<li><p>后续发现 apt 安装 supervisor 后，<code>/etc/init.d</code>
目录下存在一个 supervisor 文件，但是并未成功自启动
(lighttpd 安装后可正常自启动)</p>
<ol type="1">
<li><p>给该文件添加运行权限</p></li>
<li><p>该文件前面有一段注释，不知道是否符合<a href="https://wiki.debian.org/LSBInitScripts">规范</a> , 删除了
<code>### BEGIN INIT INFO</code> 之前的一段注释</p></li>
<li><p>执行 update-rc.d 命令</p>
<p></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">update-rc.d supervisor defaults</span><br><span class="line">update-rc.d supervisor <span class="built_in">enable</span></span><br></pre></td></tr></tbody></table></figure><p></p></li>
</ol></li>
<li><p>supervisor <a href="http://supervisord.org/installing.html#creating-a-configuration-file">配置生成</a>
<a href="http://supervisord.org/configuration.html">配置说明</a></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf <span class="comment"># 生成配置模板</span></span><br></pre></td></tr></tbody></table></figure>
<p>修改配置，小米 6 上的 supervisord 使用 sock 文件一直有报错，
我修改成了 http 方式，注释了 unix_http_server 部分，
打开了 inet_http_server 部分 (可能与之前的分组有同样关系？)</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">;[unix_http_server]</span></span><br><span class="line"><span class="comment">;file=/tmp/supervisor.sock   ; the path to the socket file</span></span><br><span class="line"><span class="comment">;chmod=0777                 ; socket file mode (default 0700)</span></span><br><span class="line"><span class="comment">;chown=root:root       ; socket file uid:gid owner</span></span><br><span class="line"><span class="comment">;username=user              ; default is no username (open server)</span></span><br><span class="line"><span class="comment">;password=123               ; default is no password (open server)</span></span><br><span class="line"></span><br><span class="line"><span class="section">[inet_http_server]</span>         <span class="comment">; inet (TCP) server disabled by default</span></span><br><span class="line"><span class="attr">port</span>=*:<span class="number">9001</span>        <span class="comment">; ip_address:port specifier, *:port for all iface</span></span><br><span class="line"><span class="comment">;username=user              ; default is no username (open server)</span></span><br><span class="line"><span class="comment">;password=123               ; default is no password (open server)</span></span><br><span class="line"></span><br><span class="line"><span class="section">[supervisorctl]</span></span><br><span class="line"><span class="comment">;serverurl=unix:///tmp/supervisor.sock ; use a unix:// URL  for a unix socket</span></span><br><span class="line"><span class="attr">serverurl</span>=http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9001</span> <span class="comment">; use an http:// url to specify an inet socket</span></span><br><span class="line"></span><br><span class="line"><span class="section">[include]</span></span><br><span class="line"><span class="attr">files</span> = /etc/supervisor/conf.d/*.conf</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>设置好 supervisor 的自启动后，stop 再 start,
看命令行中是否有 supervisor 的运行提示，若设置成功，
其余需要自启动的进程就可以交给 supervisor 来管理</p></li>
<li><p> supervisord 服务启动后，会监听 9001 端口，
用于控制和查看进程的状态</p></li>
<li><p>添加新的进程配置文件后 执行 <code>supervisorctl reload</code>
刷新，再访问 9001 的 http 服务，就可以查看进程状态</p></li>
<li><p><code>supervisorctl reload</code> 命令会重启所有管理的进程，
如果只是加载新添加的配置可以运行以下指令</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">supervisorctl reread <span class="comment"># 重新读取配置文件</span></span><br><span class="line">supervisorctl update <span class="comment"># 刷新配置到进程组</span></span><br></pre></td></tr></tbody></table></figure>
<p>之后可以在 supervisor 管理页面看到对应的进程配置</p></li>
<li><p>如果需要配置多个环境变量，可以在 Environment 字段这样填写</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">environment</span>=KEY=<span class="string">"val:123"</span>,KEY2=<span class="string">"val,456"</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul></li>
</ol>
<p>常用命令</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">free -h <span class="comment"># 查看内存占用</span></span><br><span class="line">top <span class="comment"># 查看资源占用最多的进程</span></span><br><span class="line">ps aux <span class="comment"># 查看进程列表</span></span><br><span class="line">ip addr <span class="comment"># 查看ip</span></span><br><span class="line">ss -anptu <span class="comment"># t(tcp) u(udp) 查看网络连接</span></span><br><span class="line"><span class="built_in">df</span> -h <span class="comment"># 查看磁盘空间</span></span><br><span class="line"><span class="built_in">du</span> -h --max-depth=1 /home <span class="comment"># 查看某个文件夹下的各文件/文件夹大小统计</span></span><br><span class="line"><span class="comment"># 查看用户信息 (uid, 所在分组) 用户需要在3003,3004分组中才具有网络访问权限</span></span><br><span class="line"><span class="built_in">id</span> [username]</span><br><span class="line"><span class="comment"># 编辑文件 ctrl-x ctrl-k alt-u alt-e</span></span><br><span class="line">nano /etc/apt/source.list</span><br><span class="line"><span class="comment"># 编辑用户组信息</span></span><br><span class="line">nano /etc/group</span><br><span class="line">passwd <span class="comment"># 设置当前用户密码</span></span><br><span class="line"><span class="built_in">chmod</span> a+rx xxx.sh <span class="comment"># a </span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="常用软件">5 常用软件</h2>
<h3 id="lighttpd-轻量web服务">5.1 lighttpd 轻量 Web 服务</h3>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">apt install lighttpd</span><br></pre></td></tr></tbody></table></figure>
<p>安装完成后已经自动在 /etc/init.d 目录下创建自启动配置，
运行配置在 <code>/etc/lighttpd/lighttpd.conf</code>,
默认网站路径为 <code>/var/www/html/</code></p>
<p>默认配置我没有改动，监听 80 端口，主要用于展示一个所有服务的导航页面，
因为且换网络环境时服务器 IP 会变，想弄个方便的导航页，
根据 hostname 值自动调整导航链接</p>
<ul>
<li><p>index.html 源码，使用 bootstrap 稍微修饰了一下，其实没啥必要</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en-US"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">href</span>=<span class="string">"#"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Services List<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Services List<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"services"</span> <span class="attr">class</span>=<span class="string">"list-group"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> services = [</span></span><br><span class="line"><span class="language-javascript">        [<span class="string">"Supervisor"</span>, <span class="number">9001</span>, <span class="string">""</span>],</span></span><br><span class="line"><span class="language-javascript">        [<span class="string">"Siyuan"</span>, <span class="number">6806</span>, <span class="string">""</span>],</span></span><br><span class="line"><span class="language-javascript">        [<span class="string">"Cloudreve"</span>, <span class="number">5212</span>, <span class="string">""</span>],</span></span><br><span class="line"><span class="language-javascript">        [<span class="string">"Cloudreve Admin"</span>, <span class="number">5212</span>, <span class="string">"/admin"</span>],</span></span><br><span class="line"><span class="language-javascript">        [<span class="string">"V2raya"</span>, <span class="number">2017</span>, <span class="string">""</span>]</span></span><br><span class="line"><span class="language-javascript">      ];</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> container = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">"#services"</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> hostname = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hostname</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> content = <span class="string">""</span>;</span></span><br><span class="line"><span class="language-javascript">      services.<span class="title function_">forEach</span>(<span class="function">(<span class="params">service</span>) =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">        content += <span class="string">"&lt;a class=\"list-group-item list-group-item-action\" "</span></span></span><br><span class="line"><span class="language-javascript">                + <span class="string">"target=\"_blank\" "</span></span></span><br><span class="line"><span class="language-javascript">                + <span class="string">"href=\"http://"</span></span></span><br><span class="line"><span class="language-javascript">                + hostname + <span class="string">":"</span></span></span><br><span class="line"><span class="language-javascript">                + service[<span class="number">1</span>]</span></span><br><span class="line"><span class="language-javascript">                + service[<span class="number">2</span>]</span></span><br><span class="line"><span class="language-javascript">                + <span class="string">"\"&gt;"</span></span></span><br><span class="line"><span class="language-javascript">                + service[<span class="number">0</span>]</span></span><br><span class="line"><span class="language-javascript">                + <span class="string">"&lt;/a&gt;\n"</span>;</span></span><br><span class="line"><span class="language-javascript">      })</span></span><br><span class="line"><span class="language-javascript">      container.<span class="property">innerHTML</span> = content;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/bootstrap.bundle.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="开发编译环境">5.2 开发编译环境</h3>
<ol type="1">
<li><p>rust 最好开代理安装 参考<a href="https://www.rust-lang.org/tools/install">官网安装说明</a>
(可以参考字节镜像源中的说明安装，无需代理)</p>
<p></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">curl --proto <span class="string">'=https'</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>设置 cargo 镜像源 这里使用<a href="http://rsproxy.cn/#getStarted">字节镜像源</a> ,
其实安装也可以参考这里，还可以加快安装速度</p>
<p>编辑 <code>$HOME/.cargo/config</code></p>
<p></p><figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[source.crates-io]</span></span><br><span class="line"><span class="attr">replace-with</span> = <span class="string">'rsproxy-sparse'</span></span><br><span class="line"><span class="section">[source.rsproxy]</span></span><br><span class="line"><span class="attr">registry</span> = <span class="string">"https://rsproxy.cn/crates.io-index"</span></span><br><span class="line"><span class="section">[source.rsproxy-sparse]</span></span><br><span class="line"><span class="attr">registry</span> = <span class="string">"sparse+https://rsproxy.cn/index/"</span></span><br><span class="line"><span class="section">[registries.rsproxy]</span></span><br><span class="line"><span class="attr">index</span> = <span class="string">"https://rsproxy.cn/crates.io-index"</span></span><br><span class="line"><span class="section">[net]</span></span><br><span class="line"><span class="attr">git-fetch-with-cli</span> = <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>golang 参考<a href="https://go.dev/doc/install">官方文档</a> ,
下载压缩包之后运行对应命令安装 (apt 直接安装的无法正常使用)</p>
<ul>
<li>在 <code>$HOME/.bashrc</code> 中添加
<code>export PATH="$PATH:/usr/local/go/bin"</code></li>
</ul></li>
<li><p>缓存清理方法 (备份系统前最好先清理缓存)</p>
<ul>
<li>golang 清理缓存 <code>go clean -cache</code>
<code>go clean -modcache</code> 可以极大减小 <code>$HOME/go</code>
目录大小</li>
<li> cargo 清理缓存 安装 cargo-cache, 运行 cargo-cache, .rustup
目录貌似无法精简</li>
<li> yarn 清理缓存 <code>yarn cache clean</code>
极大减小 <code>/usr/local/share/.cache/yarn</code> 目录大小</li>
</ul></li>
</ol>
<h3 id="cloudreve-网盘">5.3 cloudreve 网盘</h3>
<p>官网下载 arm64 版本二进制运行文件
https://github.com/cloudreve/Cloudreve</p>
<p>创建 <code>/etc/supervisor/conf.d/cloudreve.conf</code></p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[program:cloudreve]</span></span><br><span class="line"><span class="attr">directory</span>=/home/cloudreve</span><br><span class="line"><span class="attr">command</span>=/home/cloudreve/cloudreve</span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">stderr_logfile</span>=/var/log/cloudreve.err</span><br><span class="line"><span class="attr">stdout_logfile</span>=/var/log/cloudreve.log</span><br><span class="line"><span class="attr">environment</span>=CODENATION_ENV=prod</span><br></pre></td></tr></tbody></table></figure>
<h3 id="siyuan-笔记">5.4 siyuan 笔记</h3>
<p><strong>后端 core 程序编译</strong></p>
<p>siyuan 笔记我只想使用后端服务，使用浏览器访问，
但是官方只提供 docker 方式的服务端部署方式，且只提供了 linux amd64 的包，
需要自己编译</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/siyuan-note/siyuan.git</span><br><span class="line"><span class="built_in">cd</span> siyuan</span><br><span class="line">git checkout vx.x.x <span class="comment"># 切换到对应版本号</span></span><br></pre></td></tr></tbody></table></figure>
<p>修改 <code>scripts/linux-build.sh</code> 编译脚本</p>
<p>编译 siyuan-kernel, 其中的 GOARCH 需要从 amd64 改为 arm64,
goproxy 可以更改为 <code>https://goproxy.cn</code></p>
<p>执行 <code>scripts/linux-build.sh</code>, 编译内核</p>
<p>官网下载对应版本号的 linux.tar.gz,
解压后将 kernel 目录中的 siyuan-kernel 文件替换为我们自己编译生成的二进制文件</p>
<p>创建 <code>/etc/supervisor/conf.d/siyuan.conf</code> 其中的 <code>RUN_IN_CONTAINER</code> 环境变量配置非常重要，
否则它默认以为是客户端模式运行，会定时检测 Electron 前端程序是否存在，
若不存在，则一定时间后自动退出</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[program:siyuan]</span></span><br><span class="line"><span class="attr">directory</span>=/home/siyuan</span><br><span class="line"><span class="attr">command</span>=/home/siyuan/kernel/siyuan-kernel -lang zh_CN -wd /home/siyuan -workspace /root/siyuan</span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">stderr_logfile</span>=/var/log/siyuan.err</span><br><span class="line"><span class="attr">stdout_logfile</span>=/var/log/siyuan.log</span><br><span class="line"><span class="attr">environment</span>=RUN_IN_CONTAINER=<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>前端资源编译</strong></p>
<p>安装 nodejs, 去官网看看<a href="https://nodejs.org/en/download/package-manager">包管理器安装方法</a> ,
提示 Debian 的安装可以按照以下方式进行 (参考:
https://github.com/nodesource/distributions)</p>
<ol type="1">
<li><p>Download and import the Nodesource GPG key</p>
<p></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y ca-certificates curl gnupg</span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/nodesource.gpg</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>Create deb repository (<code>NODE_MAJOR</code> can be changed
depending on the version you need.) 16, 18, 20</p>
<p></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">NODE_MAJOR=20</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb [signed-by=/etc/apt/keyrings/nodesource.gpg] https://deb.nodesource.com/node_<span class="variable">$NODE_MAJOR</span>.x nodistro main"</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/nodesource.list</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>Run Update and Install</p>
<p></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nodejs -y</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>Uninstall</p>
<p></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">apt-get purge nodejs &amp;&amp;\</span><br><span class="line"><span class="built_in">rm</span> -r /etc/apt/sources.list.d/nodesource.list &amp;&amp;\</span><br><span class="line"><span class="built_in">rm</span> -r /etc/apt/keyrings/nodesource.gpg</span><br></pre></td></tr></tbody></table></figure><p></p></li>
</ol>
<p>我选择了安装 18 的 LTS 版本</p>
<p>设置 npm 镜像源 (后面两个提示不支持，按照下一步操作)</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 设置阿里镜像</span></span><br><span class="line">npm config <span class="built_in">set</span> registry=https://registry.npmmirror.com</span><br><span class="line">npm config <span class="built_in">set</span> disturl=https://registry.npmmirror.com/-/binary/node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置electron仓库</span></span><br><span class="line">npm config <span class="built_in">set</span> electron_mirror=https://registry.npmmirror.com/-/binary/electron/</span><br></pre></td></tr></tbody></table></figure>
<p>设置失败可以直接修改文件 <code>nano ~/.npmrc</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">registry=https://registry.npmmirror.com</span><br><span class="line">disturl=https://registry.npmmirror.com/-/binary/node</span><br><span class="line">electron_mirror=https://registry.npmmirror.com/-/binary/electron/</span><br></pre></td></tr></tbody></table></figure>
<p>安装 yarn, pnpm</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">npm install -g yarn</span><br><span class="line">npm install -g pnpm</span><br></pre></td></tr></tbody></table></figure>
<p>在 siyuan 根目录运行<code>./scripts/linux-build.sh</code> 即可</p>
<h3 id="v2raya-代理">5.5 v2raya 代理</h3>
<p>安装 v2raya 参考<a href="https://v2raya.org/docs/prologue/installation/debian/">官方文档</a></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 添加软件源安装</span></span><br><span class="line">wget -qO - https://apt.v2raya.org/key/public-key.asc | sudo <span class="built_in">tee</span> /etc/apt/trusted.gpg.d/v2raya.asc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb https://apt.v2raya.org/ v2raya main"</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/v2raya.list</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install v2raya</span><br></pre></td></tr></tbody></table></figure>
<p>下载 <a href="https://github.com/v2fly/v2ray-core">v2fly/v2ray-core</a>
v2ray-linux-arm64-v8a</p>
<p>编辑 <code>/etc/supervisor/conf.d/v2raya.conf</code> 其中的
<code>--v2ray-bin</code> 选项用于配置 v2ray-core 文件路径</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[program:v2raya]</span></span><br><span class="line"><span class="attr">directory</span>=/usr/bin</span><br><span class="line"><span class="attr">command</span>=/usr/bin/v2raya --v2ray-bin /home/v2ray/v2ray</span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">false</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">stderr_logfile</span>=/var/log/v2raya.err</span><br><span class="line"><span class="attr">stdout_logfile</span>=/var/log/v2raya.log</span><br><span class="line"><span class="attr">environment</span>=V2RAYA_LOG_FILE=/var/log/v2raya/v2raya.log</span><br></pre></td></tr></tbody></table></figure>
<p>这里没有设置为自启动，根据需求配置</p>
<p>打开进程后默认监听 2017 端口，访问可以配置选项，"port sharing" 打开后，
可以将代理端口共享到局域网中，供其他设备使用</p>
<h3 id="code-server">5.6 code-server</h3>
<p>自部署，可以通过浏览器访问的 VS Code</p>
<p>安装参考<a href="https://github.com/coder/code-server/tree/main#getting-started">官方文档</a></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://xxxx:xxx</span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="variable">$http_proxy</span></span><br><span class="line">curl -fsSL https://code-server.dev/install.sh | sh</span><br></pre></td></tr></tbody></table></figure>
<p>使用方式参考<a href="https://github.com/coder/code-server/blob/main/docs/guide.md#expose-code-server">官方文档</a></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Replaces "auth: password" with "auth: none" in the code-server config.</span></span><br><span class="line">sed -i.bak <span class="string">'s/auth: password/auth: none/'</span> ~/.config/code-server/config.yaml</span><br></pre></td></tr></tbody></table></figure>
<p>编辑 <code>/etc/supervisor/conf.d/code-server.conf</code></p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[program:code-server]</span></span><br><span class="line"><span class="attr">directory</span>=/usr/bin</span><br><span class="line"><span class="attr">command</span>=/usr/bin/code-server</span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">false</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">stderr_logfile</span>=/var/log/code-server.err</span><br><span class="line"><span class="attr">stdout_logfile</span>=/var/log/code-server.log</span><br><span class="line">environment=</span><br></pre></td></tr></tbody></table></figure>
<p>暴露服务端口，这部分最简单的方式是按照官方提示，使用 SSH Forwarding,
不然比较麻烦，直接暴露 HTTP 端口，使用会提示不安全，且很多功能会失效</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -N disables executing a remote shell</span></span><br><span class="line">ssh -N -L 8080:127.0.0.1:8080 [user]@&lt;instance-ip&gt;</span><br><span class="line"><span class="comment"># ssh -N -L 8080:127.0.0.1:8080 root@192.168.10.176</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="cpu调度问题探究">6 CPU 调度问题探究</h2>
<p>使用 lineageos 时关闭屏幕会自动开启 doze 模式，目前只能是 usb 默认文件传输，
接上电脑使用 [或者刷系统看看，honor v10 没有刷 lineageos 没有该问题]</p>
<p><strong>刷回小米的 MIUI 系统并禁用一部分系统应用，
效果还可以</strong></p>
<p>以下内容是探索该问题的一些思路历程</p>
<p>问题定位:
https://blog.csdn.net/wenzhi20102321/article/details/130977176</p>
<p>查看安卓日志</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">logcat -c # 先清空日志</span><br><span class="line"># 进行操作，拔掉电源线，关闭屏幕</span><br><span class="line"># 再连接usb线，打开adb shell</span><br><span class="line">logcat threadtime | grep -i  -E "Wifi|Power" # 查看和电源与wifi相关的日志</span><br></pre></td></tr></tbody></table></figure>
<p>注意到以下日志</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">09-28 22:22:47.166  1664  1664 I FingerprintManager: onPowerPressed</span><br><span class="line">09-28 22:22:47.167  1664  1664 I PowerManagerService: Going to sleep due to power_button (uid 1000, screenOffTimeout=60000, activityTimeoutWM=-1, maxDimRatio=0.20000005, maxDimDur=7000)...</span><br><span class="line">09-28 22:22:47.670   976   976 D SurfaceFlinger: Setting power mode 0 on display 0</span><br><span class="line">09-28 22:22:47.848   976   976 D SurfaceFlinger: Finished setting power mode 0 on display 0</span><br><span class="line">09-28 22:22:47.850  1664  2267 D SurfaceControl: Excessive delay in setPowerMode()</span><br><span class="line">09-28 22:22:47.850  1664  1943 I DisplayPowerController[0]: BrightnessEvent: disp=0, physDisp=local:0, brt=0.0, initBrt=0.0, rcmdBrt=NaN, preBrt=NaN, lux=0.0, preLux=0.0, hbmMax=1.0, hbmMode=off, rbcStrength=50, powerFactor=1.0, thrmMax=1.0, wasShortTermModelActive=false, flags=, reason=screen_off, autoBrightness=true</span><br><span class="line">09-28 22:22:47.851   917   917 I android.hardware.power-service-qti: Power setMode: 7 to: 0</span><br><span class="line">09-28 22:22:47.851   917   917 E QTI PowerHAL: Failed to acquire lock for hint_id: 1040.</span><br><span class="line">09-28 22:22:47.853  1664  1943 I PowerManagerService: Dozing...</span><br></pre></td></tr></tbody></table></figure>
<p>可能和 doze 模式打开相关</p>
<p>搜索如何关闭 doze 模式，参考
https://forum.xda-developers.com/t/disable-doze.4407685/,
以及 GPT 中询问 "怎样在 adb 中使用命令禁止 doze 模式"</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">adb shell dumpsys deviceidle disable # 使用该命令可以禁用doze模式</span><br><span class="line">adb shell dumpsys deviceidle enable # 使用该命令可以禁用doze模式</span><br><span class="line">adb shell dumpsys deviceidle whitelist +&lt;package_name&gt; # 在特定应用上禁用doze模式</span><br><span class="line">adb shell dumpsys deviceidle whitelist -&lt;package_name&gt; # 去掉特定应用禁用doze模式</span><br></pre></td></tr></tbody></table></figure>
<p>实测在 LinuxDeploy 中设置中打开 <code>Lock screen</code> 和 <code>Wake lock</code>,
并<strong>接通电源</strong>使用，可以保持较为流畅的体验，"Kernel
adiutor"并不能解决 CPU" 睡眠 " 问题</p>
<p><del>实际上打开</del>​<code>Lock screen</code>​<del>开关之后，
并不会导致屏幕常亮，而且可以照常锁屏，不会导致睡眠问题</del></p>
<p><del>但是打开</del>​<code>Lock screen</code>​<del>开关后电量会掉的比较快，
所以使用时打开该开关，待机时关闭该开关即可</del></p>
<p>(当然，也有可能是将 USB 默认配置改成了文件传输，才让它保持 CPU),
按照上述设置，打开 Lock Screen 但是接手机充电器试试，出现睡眠问题</p>
<p>开发者选项中开启 "Stay awake", 之后关闭屏幕，还是卡顿</p>
<p>参考:
https://stackoverflow.com/questions/7617459/how-to-keep-cpu-from-sleeping-when-screen-is-turned-off-in-android</p>
<p>参考: https://developer.android.com/training/scheduling/wakelock</p>
<p><del>可能是 LinuxDeploy 中的 CPU 锁没有生效</del></p>
<p>现象：实际使用的时候，
已经在 LinuxDeploy 中打开了 <code>Wifi Lock</code> 和 <code>CPU Wake Lock</code>,
但是有时候还是发现打开笔记会卡顿，刷新会卡 LOGO 界面，
但是点亮屏幕就会非常快刷新页面，不存在卡顿</p>
<p>这很有可能是 CPU 调度策略引起的问题，
<strong>锁屏</strong>后 CPU 进入了 "Deep Sleep" 状态</p>
<p>通过以下命令可以看到 CPU 核心的运行情况，但是当卡顿情况发生时，
命令的输入都会变得卡顿</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">lscpu -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果提示命令不存在, 需要下载util-linux</span></span><br><span class="line">apt-get install util-linux</span><br></pre></td></tr></tbody></table></figure>
<p>注意: <strong>使用 Kernel
adiutor 设置后还是无法避免锁屏后手机进入 "睡眠" 模式导致卡顿，
以下内容可以选择性忽略</strong></p>
<p>通过 <code>Kernel adiutor</code> 可以调整 CPU 运行策略</p>
<p>下载地址:
https://f-droid.org/en/packages/com.nhellfire.kerneladiutor</p>
<p>在 CPU 选项中，更改 CPU Govemor</p>
<p>以下内容引用自 ChatGPT</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Performance（性能）：</span><br><span class="line">Performance模式将CPU设置为最高性能状态，以实现最佳的性能表现。这意味着CPU频率会尽可能地提高，以获得更高的计算能力。但是，这也会导致电池更快地耗尽，因此通常不适用于需要长时间使用电池的情况。</span><br><span class="line"></span><br><span class="line">Powersave（节能）：</span><br><span class="line">Powersave模式旨在最大程度地减少CPU功耗，从而延长电池寿命。它会将CPU频率降低到较低的水平，以降低性能，但可以显著减少电池的消耗。这适用于长时间不需要高性能的情况。</span><br><span class="line"></span><br><span class="line">Ondemand（按需）：</span><br><span class="line">Ondemand模式是一种动态调整CPU频率的模式，它根据系统负载自动调整CPU频率。当系统负载较低时，CPU频率会降低以节省电池电量，而在需要更多性能时，它会提高频率以提供更好的响应性能。</span><br><span class="line"></span><br><span class="line">Interactive（交互式）：</span><br><span class="line">Interactive模式是一种类似于Ondemand的动态调整模式，但更加灵活。它更快地响应负载变化，以提供更好的用户体验。这个模式在需要快速响应输入和任务切换的情况下非常有用。</span><br><span class="line"></span><br><span class="line">Conservative（保守）：</span><br><span class="line">Conservative模式也是一种动态调整模式，但相对于Ondemand和Interactive来说更加保守。它会慢慢地增加或降低CPU频率，以更平滑地适应负载变化。</span><br><span class="line"></span><br><span class="line">Userspace（用户空间）：</span><br><span class="line">Userspace模式允许用户手动设置CPU频率，而不是依赖于内核的自动调整。用户可以根据自己的需求来设置CPU频率，但需要小心，以避免不稳定或过度耗电。</span><br><span class="line"></span><br><span class="line">Performance Bias（性能偏好）：</span><br><span class="line">这是一种类似于Performance模式的模式，但稍微降低了CPU的性能以节省一些电量。它可以提供相对较高的性能，同时保持一定的电池寿命。</span><br></pre></td></tr></tbody></table></figure>
<p>可以考虑将小核设置为 Performance, 大核保持 Interactive 不变，
看是否会减少卡顿 (貌似不行)</p>
<p>将大小核都设置为 Performance</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11 中的模板改进</title>
    <url>/posts/bce68dd9/</url>
    <content><![CDATA[<p>C++11 中该进了模板，看看还是比较有用的，
终于理解上古代码里为什么模板尖括号里总是多留一个空格了</p>
<span id="more"></span>
<blockquote>
<p>原文地址 <a href="https://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&amp;mid=2247484785&amp;idx=1&amp;sn=194f240fa984970397e38a989c112aa2&amp;source=41#wechat_redirect">mp.weixin.qq.com</a></p>
</blockquote>
<p>C++11 关于模板有一些细节的改进：</p>
<ul>
<li>模板的右尖括号</li>
<li>模板的别名</li>
<li>函数模板的默认模板参数</li>
</ul>
<h4 id="模板的右尖括号">模板的右尖括号</h4>
<p>C++11 之前是不允许两个右尖括号出现的，会被认为是右移操作符，
所以需要中间加个空格进行分割，避免发生编译错误.</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; a; <span class="comment">// error</span></span><br><span class="line">   std::vector&lt;std::vector&lt;<span class="type">int</span>&gt; &gt; b; <span class="comment">// ok</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>这个我之前都不知道，我开始学编程的时候就已经是 C++11 的时代啦.</p>
<h3 id="模板的别名">模板的别名</h3>
<p>C++11 引入了 using, 可以轻松的定义别名，而不是使用繁琐的 typedef.</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; vvi; <span class="comment">// before c++11</span></span><br><span class="line"><span class="keyword">using</span> vvi = std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;; <span class="comment">// c++11</span></span><br></pre></td></tr></tbody></table></figure>
<p>使用 using 明显简洁并且易读，大家可能之前也见过使用 typedef
定义函数指针之类的操作，那烂代码我就不列出来了，
反正我是看不懂也不想看... 以后都可以使用 using, 额还是列出来吧.</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; <span class="comment">// 啥玩意, 看不懂</span></span><br><span class="line"><span class="keyword">using</span> func = <span class="built_in">void</span> (*)(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">// 起码比typedef容易看的懂吧</span></span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码使用 using 起码比 typedef 容易看的懂一些吧，
但是我还是看不懂，因为我从来不用这种来表示函数指针，用
<code>std::function()</code>、<code>std::bind()</code>、<code>std::placeholder()</code>、<code>lambda</code>
表达式它不香吗.</p>
<h3 id="函数模板的默认模板参数">函数模板的默认模板参数</h3>
<p>C++11 之前只有类模板支持默认模板参数，函数模板是不支持默认模板参数的，
C++11 后都支持.</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U=<span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> A {</span><br><span class="line">    T value;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T=<span class="type">int</span>, <span class="keyword">typename</span> U&gt; <span class="comment">// error</span></span><br><span class="line"><span class="keyword">class</span> A {</span><br><span class="line">    T value;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>类模板的默认模板参数必须从右往左定义，而函数模板则没有这个限制.</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> U=<span class="type">int</span>&gt;</span><br><span class="line">R <span class="built_in">func1</span>(U val) {</span><br><span class="line">   <span class="keyword">return</span> val;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R=<span class="type">int</span>, <span class="keyword">typename</span> U&gt;</span><br><span class="line">R <span class="built_in">func2</span>(U val) {</span><br><span class="line">   <span class="keyword">return</span> val;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   cout &lt;&lt; <span class="built_in">func1</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;(<span class="number">99.9</span>) &lt;&lt; endl; <span class="comment">// 99</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in">func1</span>&lt;<span class="type">double</span>, <span class="type">double</span>&gt;(<span class="number">99.9</span>) &lt;&lt; endl; <span class="comment">// 99.9</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in">func1</span>&lt;<span class="type">double</span>&gt;(<span class="number">99.9</span>) &lt;&lt; endl; <span class="comment">// 99.9</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in">func1</span>&lt;<span class="type">int</span>&gt;(<span class="number">99.9</span>) &lt;&lt; endl; <span class="comment">// 99</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in">func2</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;(<span class="number">99.9</span>) &lt;&lt; endl; <span class="comment">// 99</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in">func1</span>&lt;<span class="type">double</span>, <span class="type">double</span>&gt;(<span class="number">99.9</span>) &lt;&lt; endl; <span class="comment">// 99.9</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in">func2</span>&lt;<span class="type">double</span>&gt;(<span class="number">99.9</span>) &lt;&lt; endl; <span class="comment">// 99.9</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in">func2</span>&lt;<span class="type">int</span>&gt;(<span class="number">99.9</span>) &lt;&lt; endl; <span class="comment">// 99</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>对于函数模板，参数的填充顺序是从左到右的.</p>
<p><strong>参考资料</strong></p>
<blockquote>
<p>《深入应用 C++11：代码优化与工程级应用》</p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/tennysonsky/article/details/77817027">https://blog.csdn.net/tennysonsky/article/details/77817027</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/wf19930209/article/details/79309881?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1">https://blog.csdn.net/wf19930209/article/details/79309881?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1</a></p>
</blockquote>
<p>关于 C++11 对于模板的改进就讲到这里，请继续关注～</p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483885&amp;idx=1&amp;sn=ba3342f7807d347747946df4b9bb4b4c&amp;chksm=eb7a077edc0d8e68f9bde2e39e64e18f5c2e2d85bd9abeb44986fe64a8c7dcbceb5333b78298&amp;scene=21#wechat_redirect">一文让你搞懂设计模式</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483837&amp;idx=1&amp;sn=228aa7a8dd9b580336fc82a6d283c382&amp;chksm=eb7a072edc0d8e3834b8c4588453d9cf72bd6b85290a18ce549534c1b6627e3164c476e30c47&amp;scene=21#wechat_redirect">RAII
妙用之 ScopeExit</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483852&amp;idx=1&amp;sn=34dde853d5304f8a165e82effe287f3c&amp;chksm=eb7a075fdc0d8e4971f55dc3c4ad4388a3c7466c6df5a47bcfa81510de230cf22065298fee26&amp;scene=21#wechat_redirect">RAII
妙用之计算函数耗时</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483911&amp;idx=1&amp;sn=9808fea93560af81c594e7d7c0f81ed9&amp;chksm=eb7a0494dc0d8d82abfc0db427d921c93eb077e9f9162088b13651e81618bb231cb6f22f96a2&amp;scene=21#wechat_redirect">一文吃透
C++11 中 auto 和 decltype 知识点</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483921&amp;idx=1&amp;sn=5f5a14ac4db1e12092434bd9c20e44a2&amp;chksm=eb7a0482dc0d8d94df49a59c1b9dce1458e9b385e97a6c53ecb4bea06b24bd47187a1c47cc4c&amp;scene=21#wechat_redirect">左值引用、右值引用、移动语义、完美转发，
你知道的不知道的都在这里</a></p>
<p>如果有任何问题或想法，可以 点此留言，
我会尽快回复哒！欢迎小伙伴们踊跃留言，希望这里是大家交流互通的平台～</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11 中的线程库 thread 与同步库 mutex</title>
    <url>/posts/4cc95c54/</url>
    <content><![CDATA[<p>C++11 提供了线程库和同步库，可以屏蔽操作系统接口细节使用多线程了</p>
<span id="more"></span>
<h2 id="多线程">多线程</h2>
<p><code>std::thread</code> 创建与使用</p>
<p><code>std::this_thread</code> 当前线程</p>
<h2 id="线程同步">线程同步</h2>
<p><code>lock_guard</code> 互斥锁</p>
<p><code>unique_lock</code> + <code>condition_variable</code> 条件锁</p>
<h2 id="原子操作库">原子操作库</h2>
<p>实现轻量免锁的多线程安全操作</p>
<p><a href="https://zh.cppreference.com/w/cpp/atomic/atomic">https://zh.cppreference.com/w/cpp/atomic/atomic</a></p>
<p><a href="https://zh.cppreference.com/w/cpp/atomic/atomic_flag">https://zh.cppreference.com/w/cpp/atomic/atomic_flag</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">std::atomic_int ttt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">bool</span> add)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) {</span><br><span class="line">        <span class="keyword">if</span> (add) ++ttt;</span><br><span class="line">        <span class="keyword">else</span> --ttt;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"th exit!\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    ttt = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; ths;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) {</span><br><span class="line">        ths.<span class="built_in">emplace_back</span>(test, i % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : ths) {</span><br><span class="line">        th.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; ttt &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出为 0; 如果把头一行的 std::atomic_int 换成 int, 得到的结果偏差巨大</p>
<h2 id="异步任务-future-promise">异步任务 future &amp; promise</h2>
<p>定义于 <code>&lt;future&gt;</code> 头文件</p>
<p>使用 future 三种方式: packaged_task, promise, async</p>
<p><a href="https://zh.cppreference.com/w/cpp/thread/future">https://zh.cppreference.com/w/cpp/thread/future</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 来自 packaged_task 的 future</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">([](){ <span class="keyword">return</span> <span class="number">7</span>; })</span></span>; <span class="comment">// 包装函数</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f1 = task.<span class="built_in">get_future</span>();  <span class="comment">// 获取 future</span></span><br><span class="line">    std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task)).<span class="built_in">detach</span>(); <span class="comment">// 在线程上运行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 来自 async() 的 future</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f2 = std::<span class="built_in">async</span>(std::launch::async, [](){ <span class="keyword">return</span> <span class="number">8</span>; });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 来自 promise 的 future</span></span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f3 = p.<span class="built_in">get_future</span>();</span><br><span class="line">    std::<span class="built_in">thread</span>( [&amp;p]{ p.<span class="built_in">set_value_at_thread_exit</span>(<span class="number">9</span>); }).<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Waiting..."</span> &lt;&lt; std::flush;</span><br><span class="line">    f1.<span class="built_in">wait</span>();</span><br><span class="line">    f2.<span class="built_in">wait</span>();</span><br><span class="line">    f3.<span class="built_in">wait</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Done!\nResults are: "</span></span><br><span class="line">              &lt;&lt; f1.<span class="built_in">get</span>() &lt;&lt; <span class="string">' '</span> &lt;&lt; f2.<span class="built_in">get</span>() &lt;&lt; <span class="string">' '</span> &lt;&lt; f3.<span class="built_in">get</span>() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>std::async</code></p>
<p>最简单的异步任务使用</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">std::launch::async // 运行新线程, 以异步执行任务</span><br><span class="line">std::launch::deferred // 调用方线程上首次请求其结果时执行任务（惰性求值）</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 马上开始异步任务</span></span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; f2 = std::<span class="built_in">async</span>(std::launch::async, [](){ <span class="keyword">return</span> <span class="number">8</span>; });</span><br><span class="line">f2.<span class="built_in">wait</span>(); <span class="comment">// 阻塞至结果变得可用</span></span><br><span class="line"><span class="type">int</span> result = f2.<span class="built_in">get</span>(); <span class="comment">// 获取结果</span></span><br></pre></td></tr></tbody></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11 中的默认函数控制 delete 和 default</title>
    <url>/posts/be0f7d71/</url>
    <content><![CDATA[<p>delete 和 default 在 C++ 中用于显式控制默认函数的生成情况，
我们需要知道 C++ 编译器到底干了些什么</p>
<span id="more"></span>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c++11 类默认函数的控制："=default" 和 "=delete"函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++ 的类有四类特殊成员函数, 它们分别是：默认构造函数、析构函数、拷贝构造函数以及拷贝赋值运算符.</span></span><br><span class="line"><span class="comment">这些类的特殊成员函数负责创建、初始化、销毁, 或者拷贝类的对象.</span></span><br><span class="line"><span class="comment">如果程序员没有显式地为一个类定义某个特殊成员函数, 而又需要用到该特殊成员函数时, 则编译器会隐式的为这个类生成一个默认的特殊成员函数.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 标准引入了一个新特性："=default"函数. 程序员只需在函数声明后加上“=default;”, 就可将该函数声明为 "=default"函数, 编译器将为显式声明的 "=default"函数自动生成函数体.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>() = <span class="keyword">default</span>; <span class="comment">//该函数比用户自己定义的默认构造函数获得更高的代码效率</span></span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> i)</span><br><span class="line">    {</span><br><span class="line">        a = i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">X obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "=default"函数特性仅适用于类的特殊成员函数, 且该特殊成员函数没有默认参数.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X1</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="keyword">default</span>;      <span class="comment">// err , 函数 f() 非类 X 的特殊成员函数</span></span><br><span class="line">    <span class="built_in">X1</span>(<span class="type">int</span>, <span class="type">int</span>) = <span class="keyword">default</span>;  <span class="comment">// err , 构造函数 X1(int, int) 非 X 的特殊成员函数</span></span><br><span class="line">    <span class="built_in">X1</span>(<span class="type">int</span> = <span class="number">1</span>) = <span class="keyword">default</span>;   <span class="comment">// err , 默认构造函数 X1(int=1) 含有默认参数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// "=default"函数既可以在类体里（inline）定义, 也可以在类体外（out-of-line）定义.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X2</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X2</span>() = <span class="keyword">default</span>; <span class="comment">//Inline defaulted 默认构造函数</span></span><br><span class="line">    <span class="built_in">X2</span>(<span class="type">const</span> X&amp;);</span><br><span class="line">    X2&amp; <span class="keyword">operator</span> = (<span class="type">const</span> X&amp;);</span><br><span class="line">    ~<span class="built_in">X2</span>() = <span class="keyword">default</span>;  <span class="comment">//Inline defaulted 析构函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">X2::<span class="built_in">X2</span>(<span class="type">const</span> X&amp;) = <span class="keyword">default</span>;  <span class="comment">//Out-of-line defaulted 拷贝构造函数</span></span><br><span class="line">X2&amp; X2::<span class="keyword">operator</span>= (<span class="type">const</span> X2&amp;) = <span class="keyword">default</span>;   <span class="comment">//Out-of-line defaulted  拷贝赋值操作符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了能够让程序员显式的禁用某个函数, C++11 标准引入了一个新特性："=delete"函数. 程序员只需在函数声明后上“=delete;”, 就可将该函数禁用.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X3</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X3</span>();</span><br><span class="line">    <span class="built_in">X3</span>(<span class="type">const</span> X3&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 声明拷贝构造函数为 deleted 函数</span></span><br><span class="line">    X3&amp; <span class="keyword">operator</span> = (<span class="type">const</span> X3 &amp;) = <span class="keyword">delete</span>; <span class="comment">// 声明拷贝赋值操作符为 deleted 函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// "=delete"函数特性还可用于禁用类的某些转换构造函数, 从而避免不期望的类型转换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X4</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X4</span>(<span class="type">double</span>)</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">X4</span>(<span class="type">int</span>) = <span class="keyword">delete</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// "=delete"函数特性还可以用来禁用某些用户自定义的类的 new 操作符, 从而避免在自由存储区创建类的对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X5</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span>) = <span class="keyword">delete</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mytest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    X4 obj1;</span><br><span class="line">    X4 obj2=obj1;   <span class="comment">// 错误, 拷贝构造函数被禁用</span></span><br><span class="line"></span><br><span class="line">    X4 obj3;</span><br><span class="line">    obj3=obj1;     <span class="comment">// 错误, 拷贝赋值操作符被禁用</span></span><br><span class="line"></span><br><span class="line">    X5 *pa = <span class="keyword">new</span> X5;      <span class="comment">// 错误, new 操作符被禁用</span></span><br><span class="line">    X5 *pb = <span class="keyword">new</span> X5[<span class="number">10</span>];  <span class="comment">// 错误, new[] 操作符被禁用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">mytest</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11 左值右值</title>
    <url>/posts/18350f75/</url>
    <content><![CDATA[<p>左值右值，还是需要好好理一下的</p>
<span id="more"></span>
<blockquote>
<p>原文地址 <a href="https://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&amp;mid=2247484786&amp;idx=1&amp;sn=fc10ee31da336ec53b23b8be93e847ef&amp;source=41#wechat_redirect">mp.weixin.qq.com</a></p>
</blockquote>
<p>众所周知 C++11 新增了右值引用，
谈右值引用我们也可以扩展一些相关概念：</p>
<ul>
<li>左值</li>
<li>右值</li>
<li>纯右值</li>
<li>将亡值</li>
<li>左值引用</li>
<li>右值引用</li>
<li>移动语义</li>
<li>完美转发</li>
<li>返回值优化</li>
</ul>
<p>程序喵下面会一一介绍：</p>
<h3 id="左值右值">左值、右值</h3>
<p><strong>概念 1</strong>：</p>
<p>左值：可以放到等号左边的东西叫左值.</p>
<p>右值：不可以放到等号左边的东西就叫右值.</p>
<p><strong>概念 2</strong>：</p>
<p>左值：可以取地址并且有名字的东西就是左值.</p>
<p>右值：不能取地址的没有名字的东西就是右值.</p>
<p><strong>举例</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int a = b + c;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>a 是左值，有变量名，可以取地址，也可以放到等号左边，表达式 b+c
的返回值是右值，没有名字且不能取地址，&amp;(b+c) 不能通过编译，
而且也不能放到等号左边.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int a = 4; // a是左值, 4作为普通字面量是右值</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>左值一般有：</p>
<ul>
<li>函数名和变量名</li>
<li>返回左值引用的函数调用</li>
<li>前置自增自减表达式 ++i、--i</li>
<li> 由赋值表达式或赋值运算符连接的表达式 (a=b, a += b 等)</li>
<li> 解引用表达式 * p</li>
<li> 字符串字面值 "abcd"</li>
</ul>
<h3 id="纯右值将亡值">纯右值、将亡值</h3>
<p>纯右值和将亡值都属于右值.</p>
<h4 id="纯右值">纯右值</h4>
<p>运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda
表达式等都是纯右值.</p>
<p><strong>举例：</strong></p>
<ul>
<li>除字符串字面值外的字面值</li>
<li>返回非引用类型的函数调用</li>
<li>后置自增自减表达式 i++、i--</li>
<li> 算术表达式 (a+b, a*b, a&amp;&amp;b, a==b 等)</li>
<li> 取地址表达式等 (&amp;a)</li>
</ul>
<h4 id="将亡值">将亡值</h4>
<p>将亡值是指 C++11 新增的和右值引用相关的表达式，
通常指将要被移动的对象、T&amp;&amp; 函数的返回值、std::move
函数的返回值、转换为 T&amp;&amp; 类型转换函数的返回值，
将亡值可以理解为即将要销毁的值，通过 “盗取”
其它变量内存空间方式获取的值，在确保其它变量不再被使用或者即将被销毁时，
可以避免内存空间的释放和分配，延长变量值的生命周期，
常用来完成移动构造或者移动赋值的特殊任务.</p>
<p><strong>举例：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class A {</span><br><span class="line">    xxx;</span><br><span class="line">};</span><br><span class="line">A a;</span><br><span class="line">auto c = std::move(a); // c是将亡值</span><br><span class="line">auto d = static_cast&lt;A&amp;&amp;&gt;(a); // d是将亡值</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>左值引用、右值引用</strong></p>
<p>根据名字大概就可以猜到意思，左值引用就是对左值进行引用的类型，
右值引用就是对右值进行引用的类型，他们都是引用，都是对象的一个别名，
并不拥有所绑定对象的堆存，所以都必须立即初始化.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">type &amp;name = exp; // 左值引用</span><br><span class="line">type &amp;&amp;name = exp; // 右值引用</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>左值引用</strong></p>
<p>看代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int a = 5;</span><br><span class="line">int &amp;b = a; // b是左值引用</span><br><span class="line">b = 4;</span><br><span class="line">int &amp;c = 10; // error, 10无法取地址, 无法进行引用</span><br><span class="line">const int &amp;d = 10; // ok, 因为是常引用, 引用常量数字, 这个常量数字会存储在内存中, 可以取地址</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>可以得出结论：对于左值引用，等号右边的值必须可以取地址，
如果不能取地址，则会编译失败，或者可以使用 const 引用形式，
但这样就只能通过引用来读取输出，不能修改数组，因为是常量引用.</p>
<p><strong>右值引用</strong></p>
<p>如果使用右值引用，那表达式等号右边的值需要时右值，可以使用 std::move
函数强制把左值转换为右值.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int a = 4;</span><br><span class="line">int &amp;&amp;b = a; // error, a是左值</span><br><span class="line">int &amp;&amp;c = std::move(a); // ok</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>移动语义</strong></p>
<p>谈移动语义前，我们首先需要了解深拷贝与浅拷贝的概念</p>
<h4 id="深拷贝浅拷贝"><strong>深拷贝、浅拷贝</strong></h4>
<p>直接拿代码举例:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class A {</span><br><span class="line">public:</span><br><span class="line">    A(int size) : size_(size) {</span><br><span class="line">        data_ = new int[size];</span><br><span class="line">    }</span><br><span class="line">    A(){}</span><br><span class="line">    A(const A&amp; a) {</span><br><span class="line">        size_ = a.size_;</span><br><span class="line">        data_ = a.data_;</span><br><span class="line">        cout &lt;&lt; "copy " &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    ~A() {</span><br><span class="line">        delete[] data_;</span><br><span class="line">    }</span><br><span class="line">    int *data_;</span><br><span class="line">    int size_;</span><br><span class="line">};</span><br><span class="line">int main() {</span><br><span class="line">    A a(10);</span><br><span class="line">    A b = a;</span><br><span class="line">    cout &lt;&lt; "b " &lt;&lt; b.data_ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; "a " &lt;&lt; a.data_ &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中，两个输出的是相同的地址，a 和 b 的
data_指针指向了同一块内存，这就是浅拷贝，只是数据的简单赋值，那再析构时
data_内存会被释放两次，导致程序出问题，这里正常会出现 double free
导致程序崩溃的，但是不知道为什么我自己测试程序却没有崩溃，能力有限，
没搞明白，无论怎样，这样的程序肯定是有隐患的，如何消除这种隐患呢，
可以使用如下深拷贝：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class A {</span><br><span class="line">public:</span><br><span class="line">    A(int size) : size_(size) {</span><br><span class="line">        data_ = new int[size];</span><br><span class="line">    }</span><br><span class="line">    A(){}</span><br><span class="line">    A(const A&amp; a) {</span><br><span class="line">        size_ = a.size_;</span><br><span class="line">        data_ = new int[size_];</span><br><span class="line">        cout &lt;&lt; "copy " &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    ~A() {</span><br><span class="line">        delete[] data_;</span><br><span class="line">    }</span><br><span class="line">    int *data_;</span><br><span class="line">    int size_;</span><br><span class="line">};</span><br><span class="line">int main() {</span><br><span class="line">    A a(10);</span><br><span class="line">    A b = a;</span><br><span class="line">    cout &lt;&lt; "b " &lt;&lt; b.data_ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; "a " &lt;&lt; a.data_ &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>深拷贝就是再拷贝对象时，如果被拷贝对象内部还有指针引用指向其它资源，
自己需要重新开辟一块新内存存储资源，而不是简单的赋值.</p>
<p>聊完了深拷贝浅拷贝，可以聊聊<strong>移动语义</strong>啦：</p>
<p>移动语义，在程序喵看来可以理解为转移所有权，
之前的拷贝是对于别人的资源，自己重新分配一块内存存储复制过来的资源，
而对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，
转为自己所拥有，别人不再拥有也不会再使用，通过 C++11
新增的移动语义可以省去很多拷贝负担，怎么利用移动语义呢，
是通过移动构造函数.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class A {</span><br><span class="line">public:</span><br><span class="line">    A(int size) : size_(size) {</span><br><span class="line">        data_ = new int[size];</span><br><span class="line">    }</span><br><span class="line">    A(){}</span><br><span class="line">    A(const A&amp; a) {</span><br><span class="line">        size_ = a.size_;</span><br><span class="line">        data_ = new int[size_];</span><br><span class="line">        cout &lt;&lt; "copy " &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    A(A&amp;&amp; a) {</span><br><span class="line">        this-&gt;data_ = a.data_;</span><br><span class="line">        a.data_ = nullptr;</span><br><span class="line">        cout &lt;&lt; "move " &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    ~A() {</span><br><span class="line">        if (data_ != nullptr) {</span><br><span class="line">         delete[] data_;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    int *data_;</span><br><span class="line">    int size_;</span><br><span class="line">};</span><br><span class="line">int main() {</span><br><span class="line">    A a(10);</span><br><span class="line">    A b = a;</span><br><span class="line">    A c = std::move(a); // 调用移动构造函数</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>如果不使用 std::move (), 会有很大的拷贝代价，
使用移动语义可以避免很多无用的拷贝，提供程序性能，C++ 所有的 STL
都实现了移动语义，方便我们使用。例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">std::vector&lt;string&gt; vecs;</span><br><span class="line">...</span><br><span class="line">std::vector&lt;string&gt; vecm = std::move(vecs); // 免去很多拷贝</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意：</strong>移动语义仅针对于那些实现了移动构造函数的类的对象，
对于那种基本类型 int、float 等没有任何优化作用，还是会拷贝，
因为它们实现没有对应的移动构造函数.</p>
<h3 id="完美转发">完美转发</h3>
<p>完美转发指可以写一个接受任意实参的函数模板，并转发到其它函数，
目标函数会收到与转发函数完全相同的实参，
转发函数实参是左值那目标函数实参也是左值，
转发函数实参是右值那目标函数实参也是右值。那如何实现完美转发呢，
答案是使用 std::forward ().</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">void PrintV(int &amp;t) {</span><br><span class="line">    cout &lt;&lt; "lvalue" &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">void PrintV(int &amp;&amp;t) {</span><br><span class="line">    cout &lt;&lt; "rvalue" &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Test(T &amp;&amp;t) {</span><br><span class="line">    PrintV(t);</span><br><span class="line">    PrintV(std::forward&lt;T&gt;(t));</span><br><span class="line">    PrintV(std::move(t));</span><br><span class="line">}</span><br><span class="line">int main() {</span><br><span class="line">    Test(1); // lvalue rvalue rvalue</span><br><span class="line">    int a = 1;</span><br><span class="line">    Test(a); // lvalue lvalue rvalue</span><br><span class="line">    Test(std::forward&lt;int&gt;(a)); // lvalue rvalue rvalue</span><br><span class="line">    Test(std::forward&lt;int&amp;&gt;(a)); // lvalue lvalue rvalue</span><br><span class="line">    Test(std::forward&lt;int&amp;&amp;&gt;(a)); // lvalue rvalue rvalue</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>分析</strong></p>
<ul>
<li>Test (1)：1 是右值，模板中 T &amp;&amp;t 这种为万能引用，右值 1 传到
Test 函数中变成了右值引用，但是调用 PrintV () 时候，t 变成了左值，
因为它变成了一个拥有名字的变量，所以打印 lvalue, 而
PrintV (std::forward<t>(t)) 时候，会进行完美转发，按照原来的类型转发，
所以打印 rvalue, PrintV (std::move (t)) 毫无疑问会打印 rvalue.</t></li>
<li>Test (a)：a 是左值，模板中 T &amp;&amp; 这种为万能引用，左值 a 传到
Test 函数中变成了左值引用，所以有代码中打印.</li>
<li>Test(std::forward<t>(a))：转发为左值还是右值，依赖于 T, T
是左值那就转发为左值，T 是右值那就转发为右值.</t></li>
</ul>
<h3 id="返回值优化">返回值优化</h3>
<p>返回值优化 (RVO) 是一种 C++ 编译优化技术，
当函数需要返回一个对象实例时候，
就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，
这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，
C++ 标准允许省略调用这些复制构造函数.</p>
<p>那什么时候编译器会进行返回值优化呢？</p>
<ul>
<li>return 的值类型与函数的返回值类型相同</li>
<li> return 的是一个局部对象</li>
</ul>
<p>看几个例子:</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; return_vector(void) {</span><br><span class="line">    std::vector&lt;int&gt; tmp {1,2,3,4,5};</span><br><span class="line">    return tmp;</span><br><span class="line">}</span><br><span class="line">std::vector&lt;int&gt; &amp;&amp;rval_ref = return_vector();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>不会触发 RVO, 拷贝构造了一个临时的对象，临时对象的生命周期和 rval_ref
绑定，等价于下面这段代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">const std::vector&lt;int&gt;&amp; rval_ref = return_vector();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt;&amp;&amp; return_vector(void) {</span><br><span class="line">    std::vector&lt;int&gt; tmp {1,2,3,4,5};</span><br><span class="line">    return std::move(tmp);</span><br><span class="line">}</span><br><span class="line">std::vector&lt;int&gt; &amp;&amp;rval_ref = return_vector();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>这段代码会造成运行时错误，因为 rval_ref 引用了被析构的 tmp.
讲道理来说这段代码是错的，但我自己运行过程中却成功了，我没有那么幸运，
这里不纠结，继续向下看什么时候会触发 RVO.</p>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; return_vector(void) {</span><br><span class="line">    std::vector&lt;int&gt; tmp {1,2,3,4,5};</span><br><span class="line">    return std::move(tmp);</span><br><span class="line">}</span><br><span class="line">std::vector&lt;int&gt; &amp;&amp;rval_ref = return_vector();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>和示例 1 类似，std::move 一个临时对象是没有必要的，
也会忽略掉返回值优化.</p>
<p><strong>最好的代码：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; return_vector(void) {</span><br><span class="line">    std::vector&lt;int&gt; tmp {1,2,3,4,5};</span><br><span class="line">    return tmp;</span><br><span class="line">}</span><br><span class="line">std::vector&lt;int&gt; rval_ref = return_vector();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>这段代码会触发 RVO, 不拷贝也不移动，不生成临时对象.</p>
<h3 id="参考资料">参考资料</h3>
<blockquote>
<p>《Effective Modern C++》</p>
</blockquote>
<blockquote>
<p>《深入应用 C++11：代码优化与工程级应用》</p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/u0105">https://blog.csdn.net/u0105</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.jianshu.com/p/4538483a1d8a">https://www.jianshu.com/p/4538483a1d8a</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/xkfz007/articles/2506022.html">https://www.cnblogs.com/xkfz007/articles/2506022.html</a></p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/97128024">https://zhuanlan.zhihu.com/p/97128024</a></p>
</blockquote>
<blockquote>
<p><a href="https://zh.cppreference.com/w/cpp/utility/forward">https://zh.cppreference.com/w/cpp/utility/forward</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.zhihu.com/question/43513150">https://www.zhihu.com/question/43513150</a></p>
</blockquote>
<blockquote>
<p><a href="https://stackoverflow.com/questions/4986673/c11-rvalues-and-move-semantics-confusion-return-statement?lq=1">https://stackoverflow.com/questions/4986673/c11-rvalues-and-move-semantics-confusion-return-statement?lq=1</a></p>
</blockquote>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483885&amp;idx=1&amp;sn=ba3342f7807d347747946df4b9bb4b4c&amp;chksm=eb7a077edc0d8e68f9bde2e39e64e18f5c2e2d85bd9abeb44986fe64a8c7dcbceb5333b78298&amp;scene=21#wechat_redirect">一文让你搞懂设计模式</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483837&amp;idx=1&amp;sn=228aa7a8dd9b580336fc82a6d283c382&amp;chksm=eb7a072edc0d8e3834b8c4588453d9cf72bd6b85290a18ce549534c1b6627e3164c476e30c47&amp;scene=21#wechat_redirect">RAII
妙用之 ScopeExit</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483840&amp;idx=1&amp;sn=48a5ba180c61877134344084e25d27f4&amp;chksm=eb7a0753dc0d8e450dcfe3a6d6b0405c043b60944173510836049802d48828e366d47d88674e&amp;scene=21#wechat_redirect">深入浅出虚拟内存</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483840&amp;idx=2&amp;sn=ff498badd138d897c3d19284b4ddc8f9&amp;chksm=eb7a0753dc0d8e4514c613199c33fd1c604cb8e2f27f6e4362d09fa5376a6dcdea2d6b73d538&amp;scene=21#wechat_redirect">深入浅出虚拟内存（二）绘制虚拟内存排布图</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483840&amp;idx=3&amp;sn=388ece7d274bbfd69e48d01795e04d6f&amp;chksm=eb7a0753dc0d8e45088aa5b402d2af678ddd5d91ec41c89454986c07602e9925dbf2e06dfc19&amp;scene=21#wechat_redirect">深入浅出虚拟内存（三）堆内存分配及
malloc 实现原理</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483852&amp;idx=1&amp;sn=34dde853d5304f8a165e82effe287f3c&amp;chksm=eb7a075fdc0d8e4971f55dc3c4ad4388a3c7466c6df5a47bcfa81510de230cf22065298fee26&amp;scene=21#wechat_redirect">RAII
妙用之计算函数耗时</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483911&amp;idx=1&amp;sn=9808fea93560af81c594e7d7c0f81ed9&amp;chksm=eb7a0494dc0d8d82abfc0db427d921c93eb077e9f9162088b13651e81618bb231cb6f22f96a2&amp;scene=21#wechat_redirect">一文吃透
C++11 中 auto 和 decltype 知识点</a></p>
<p>如果有任何问题或想法，可以 <strong>点此留言</strong> ,
我会尽快回复哒！欢迎小伙伴们踊跃留言，希望这里是大家交流互通的平台～</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11 新特性</title>
    <url>/posts/952ddb2b/</url>
    <content><![CDATA[<p>C++11 中的新特性概览</p>
<span id="more"></span>
<p>c++ 程序员面试过程中基本上都会被问到 c++11 新特性吧，
你是怎么回答的呢？</p>
<p>本文基本上涵盖了 c++11 的所有新特性，并有详细代码介绍其用法，
对关键知识点做了深入分析，
对重要的知识点我单独写了相关文章并附上了相关链接，我整理了完备的 c++
新特性脑图（由于图片太大，我没有放在文章里，同学可以在后台回复消息
“新特性”, 即可下载完整图片）.</p>
<h4 id="auto-decltype">auto &amp; decltype</h4>
<p>关于 C++11 新特性，最先提到的肯定是类型推导，C++11 引入了 auto 和
decltype 关键字，使用他们可以在编译期就推导出变量或者表达式的类型，
方便开发者编码也简化了代码.</p>
<ul>
<li>auto：让编译器在编译器就推导出变量的类型，可以通过 =
右边的类型推导出变量的类型.</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">10</span>; <span class="comment">// 10是int型, 可以自动推导出a是int</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>decltype：相对于 auto 用于推导变量类型，而 decltype
则用于推导表达式类型，这里只用于编译器分析表达式的类型，
表达式实际不会进行运算.</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cont <span class="type">int</span> &amp;i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) b = <span class="number">2</span>; <span class="comment">// b是const int&amp;</span></span><br></pre></td></tr></tbody></table></figure>
<p>关于 auto 和 decltype 的详细介绍请看：<a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483911&amp;idx=1&amp;sn=9808fea93560af81c594e7d7c0f81ed9&amp;chksm=eb7a0494dc0d8d82abfc0db427d921c93eb077e9f9162088b13651e81618bb231cb6f22f96a2&amp;scene=21#wechat_redirect">一文吃透
C++11 中 auto 和 decltype 知识点</a></p>
<h4 id="左值右值">左值右值</h4>
<p>众所周知 C++11 新增了右值引用，这里涉及到很多概念：</p>
<ul>
<li>左值：可以取地址并且有名字的东西就是左值.</li>
<li> 右值：不能取地址的没有名字的东西就是右值.</li>
<li> 纯右值：运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda
表达式等都是纯右值.</li>
<li> 将亡值：可以理解为即将要销毁的值.</li>
<li> 左值引用：对左值进行引用的类型.</li>
<li> 右值引用：对右值进行引用的类型.</li>
<li> 移动语义：转移资源所有权，类似于转让或者资源窃取的意思，
对于那块资源，转为自己所拥有，别人不再拥有也不会再使用.</li>
<li> 完美转发：可以写一个接受任意实参的函数模板，并转发到其它函数，
目标函数会收到与转发函数完全相同的实参.</li>
<li> 返回值优化：当函数需要返回一个对象实例时候，
就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，
这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，
C++ 标准允许省略调用这些复制构造函数.</li>
</ul>
<p>这里的详细介绍请看：<a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483921&amp;idx=1&amp;sn=5f5a14ac4db1e12092434bd9c20e44a2&amp;chksm=eb7a0482dc0d8d94df49a59c1b9dce1458e9b385e97a6c53ecb4bea06b24bd47187a1c47cc4c&amp;scene=21#wechat_redirect">左值引用、右值引用、移动语义、完美转发，
你知道的不知道的都在这里</a></p>
<h4 id="列表初始化">列表初始化</h4>
<p>在 C++11 中可以直接在变量名后面加上初始化列表来进行对象的初始化，
详细介绍一定要看这篇文章：<a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483934&amp;idx=1&amp;sn=26025c7e7d530df870059be967908c6d&amp;chksm=eb7a048ddc0d8d9b42e8954645cf7f60b9f3ba520f0d03adc1863a8456c89f2f0ad4c2645124&amp;scene=21#wechat_redirect">学会
C++11 列表初始化</a></p>
<h4 id="stdfunction-stdbind-lambda-表达式">std::function &amp; std::bind
&amp; lambda 表达式</h4>
<p>c++11 新增了 std::function、std::bind、lambda
表达式等封装使函数调用更加方便，详细介绍请看：<a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483968&amp;idx=1&amp;sn=3d1e0efb0a0cdc66bbf646fc5d64fcbe&amp;chksm=eb7a04d3dc0d8dc56030fed11c83534c105d71f402f56bbb8ad75cb4b7ea4c5e25a6640c078b&amp;scene=21#wechat_redirect">搞定
c++11 新特性 std::function 和 lambda 表达式</a></p>
<h4 id="模板的改进">模板的改进</h4>
<p>C++11 关于模板有一些细节的改进：</p>
<ul>
<li>模板的右尖括号</li>
<li>模板的别名</li>
<li>函数模板的默认模板参数</li>
</ul>
<p>详细介绍请看：<a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483929&amp;idx=1&amp;sn=7a2fac8daf54d12705ae6f36c57771ef&amp;chksm=eb7a048adc0d8d9cd6ba448c6423ae167deca839965cf82ecec2a92d51b9cb325217689b0764&amp;scene=21#wechat_redirect">C++11
的模板改进</a></p>
<h4 id="并发">并发</h4>
<p>c++11 关于并发引入了好多好东西，有：</p>
<ul>
<li>std::thread 相关</li>
<li> std::mutex 相关</li>
<li> std::lock 相关</li>
<li> std::atomic 相关</li>
<li> std::call_once 相关</li>
<li> volatile 相关</li>
<li> std::condition_variable 相关</li>
<li> std::future 相关</li>
<li> async 相关</li>
</ul>
<p>详细介绍请看：<a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483972&amp;idx=1&amp;sn=de4a41c7c7920241c35e76d25e092350&amp;chksm=eb7a04d7dc0d8dc102d8400cb081f0a23ab231e36c7adff8c24bfc5cbcc73ac7389614167c95&amp;scene=21#wechat_redirect">c++11
新特性之线程相关所有知识点</a></p>
<p>这里也使用 c++11 来实现的线程池和定时器，可以看：</p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483823&amp;idx=1&amp;sn=732303e36464f0c9fb4bd75fa10ba4db&amp;chksm=eb7a073cdc0d8e2a6dca8babec94ce063ccab0c7832b9d85539357fe2da692fc6ad6cd5b938b&amp;scene=21#wechat_redirect">C++
线程池的实现之格式修订版</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483823&amp;idx=2&amp;sn=9d39ed7ef1d3bb6c2984db28aa013a9f&amp;chksm=eb7a073cdc0d8e2a2e24291dc9c71d6c48bd8dd8e9149e91f10b44a75b10034005908de7b78d&amp;scene=21#wechat_redirect">C++
定时器的实现之格式修订版</a></p>
<h4 id="智能指针">智能指针</h4>
<p>很多人谈到 c++, 说它特别难，可能有一部分就是因为 c++ 的内存管理吧，
不像 java 那样有虚拟机动态的管理内存，
在程序运行过程中可能就会出现内存泄漏，然而这种问题其实都可以通过 c++11
引入的智能指针来解决，相反我还认为这种内存管理还是 c++ 语言的优势，
因为尽在掌握.</p>
<p>c++11 引入了三种智能指针：</p>
<ul>
<li>std::shared_ptr</li>
<li>std::weak_ptr</li>
<li>std::unique_ptr</li>
</ul>
<p>详细介绍请看：<a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483979&amp;idx=1&amp;sn=c815b28d8ffcb49adb7538bf76378f6d&amp;chksm=eb7a04d8dc0d8dce96f262e0b14a74c0bc3a7bf335b202b4f404899489e7e1a325bc0b5b9068&amp;scene=21#wechat_redirect">c++11
新特性之智能指针</a></p>
<h4 id="基于范围的-for-循环">基于范围的 for 循环</h4>
<p>直接看代码</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = vec.<span class="built_in">begin</span>(); iter != vec.<span class="built_in">end</span>(); iter++) { <span class="comment">// before c++11</span></span><br><span class="line">   cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : vec) { <span class="comment">// c++11基于范围的for循环</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"i"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="委托构造函数">委托构造函数</h4>
<p>委托构造函数允许在同一个类中一个构造函数调用另外一个构造函数，
可以在变量初始化时简化操作，通过代码来感受下委托构造函数的妙处吧：</p>
<p>不使用委托构造函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">   <span class="built_in">A</span>(){}</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> a) { a_ = a; }</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b) { <span class="comment">// 好麻烦</span></span><br><span class="line">       a_ = a;</span><br><span class="line">       b_ = b;</span><br><span class="line">  }</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) { <span class="comment">// 好麻烦</span></span><br><span class="line">       a_ = a;</span><br><span class="line">       b_ = b;</span><br><span class="line">       c_ = c;</span><br><span class="line">  }</span><br><span class="line">   <span class="type">int</span> a_;</span><br><span class="line">   <span class="type">int</span> b_;</span><br><span class="line">   <span class="type">int</span> c_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>使用委托构造函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">   <span class="built_in">A</span>(){}</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> a) { a_ = a; }</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">A</span>(a) { b_ = b; }</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) : <span class="built_in">A</span>(a, b) { c_ = c; }</span><br><span class="line">   <span class="type">int</span> a_;</span><br><span class="line">   <span class="type">int</span> b_;</span><br><span class="line">   <span class="type">int</span> c_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>初始化变量是不是方便了许多.</p>
<h4 id="继承构造函数">继承构造函数</h4>
<p>继承构造函数可以让派生类直接使用基类的构造函数，如果有一个派生类，
我们希望派生类采用和基类一样的构造方式，可以直接使用基类的构造函数，
而不是再重新写一遍构造函数，老规矩，看代码：</p>
<p>不使用继承构造函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> {</span><br><span class="line">   <span class="built_in">Base</span>() {}</span><br><span class="line">   <span class="built_in">Base</span>(<span class="type">int</span> a) { a_ = a; }</span><br><span class="line">   <span class="built_in">Base</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">Base</span>(a) { b_ = b; }</span><br><span class="line">   <span class="built_in">Base</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) : <span class="built_in">Base</span>(a, b) { c_ = c; }</span><br><span class="line">   <span class="type">int</span> a_;</span><br><span class="line">   <span class="type">int</span> b_;</span><br><span class="line">   <span class="type">int</span> c_;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base {</span><br><span class="line">   <span class="built_in">Derived</span>() {}</span><br><span class="line">   <span class="built_in">Derived</span>(<span class="type">int</span> a) : <span class="built_in">Base</span>(a) {} <span class="comment">// 好麻烦</span></span><br><span class="line">   <span class="built_in">Derived</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">Base</span>(a, b) {} <span class="comment">// 好麻烦</span></span><br><span class="line">   <span class="built_in">Derived</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) : <span class="built_in">Base</span>(a, b, c) {} <span class="comment">// 好麻烦</span></span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   <span class="function">Derived <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用继承构造函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> {</span><br><span class="line">   <span class="built_in">Base</span>() {}</span><br><span class="line">   <span class="built_in">Base</span>(<span class="type">int</span> a) { a_ = a; }</span><br><span class="line">   <span class="built_in">Base</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">Base</span>(a) { b_ = b; }</span><br><span class="line">   <span class="built_in">Base</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) : <span class="built_in">Base</span>(a, b) { c_ = c; }</span><br><span class="line">   <span class="type">int</span> a_;</span><br><span class="line">   <span class="type">int</span> b_;</span><br><span class="line">   <span class="type">int</span> c_;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base {</span><br><span class="line">   <span class="keyword">using</span> Base::Base;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   <span class="function">Derived <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>只需要使用 using Base::Base 继承构造函数，
就免去了很多重写代码的麻烦.</p>
<h4 id="nullptr">nullptr</h4>
<p>nullptr 是 c++11 用来表示空指针新引入的常量值，在 c++
中如果表示空指针语义时建议使用 nullptr 而不要使用 NULL, 因为 NULL
本质上是个 int 型的 0, 其实不是个指针。举例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span> *ptr)</span> </span>{</span><br><span class="line">   cout &lt;&lt; <span class="string">"func ptr"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>{</span><br><span class="line">   cout &lt;&lt; <span class="string">"func i"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   <span class="built_in">func</span>(<span class="literal">NULL</span>); <span class="comment">// 编译失败, 会产生二义性</span></span><br><span class="line">   <span class="built_in">func</span>(<span class="literal">nullptr</span>); <span class="comment">// 输出func ptr</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="final-override">final &amp; override</h4>
<p>c++11 关于继承新增了两个关键字，final 用于修饰一个类，
表示禁止该类进一步派生和虚函数的进一步重载，override
用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了
override 但父类却没有这个虚函数，编译报错，使用 override
关键字可以避免开发者在重写基类函数时无意产生的错误.</p>
<p>示例代码 1：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> {</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">       cout &lt;&lt; <span class="string">"base"</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base{</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>{ <span class="comment">// 确保func被重写</span></span><br><span class="line">       cout &lt;&lt; <span class="string">"derived"</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">fu</span><span class="params">()</span> <span class="keyword">override</span> </span>{ <span class="comment">// error, 基类没有fu(), 不可以被重写</span></span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码 2：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> <span class="keyword">final</span> {</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">       cout &lt;&lt; <span class="string">"base"</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base{ <span class="comment">// 编译失败, final修饰的类不可以被继承</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">       cout &lt;&lt; <span class="string">"derived"</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h4 id="default">default</h4>
<p>c++11 引入 default 特性，多数时候用于声明构造函数为默认构造函数，
如果类中有了自定义的构造函数，编译器就不会隐式生成默认构造函数，
如下代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">   <span class="type">int</span> a;</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> i) { a = i; }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   A a; <span class="comment">// 编译出错</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码编译出错，因为没有匹配的构造函数，
因为编译器没有生成默认构造函数，而通过 default,
程序员只需在函数声明后加上 “<code>=default;</code>”, 就可将该函数声明为
defaulted 函数，编译器将为显式声明的 defaulted 函数自动生成函数体，
如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">   <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">   <span class="type">int</span> a;</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> i) { a = i; }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   A a;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>编译通过.</p>
<h4 id="delete">delete</h4>
<p>c++ 中，如果开发人员没有定义特殊成员函数，
那么编译器在需要特殊成员函数时候会隐式自动生成一个默认的特殊成员函数，
例如拷贝构造函数或者拷贝赋值操作符，如下代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">   <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">   <span class="type">int</span> a;</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> i) { a = i; }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   A a1;</span><br><span class="line">   A a2 = a1;  <span class="comment">// 正确, 调用编译器隐式生成的默认拷贝构造函数</span></span><br><span class="line">   A a3;</span><br><span class="line">   a3 = a1;  <span class="comment">// 正确, 调用编译器隐式生成的默认拷贝赋值操作符</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>而我们有时候想禁止对象的拷贝与赋值，可以使用 delete 修饰，如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">   <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">const</span> A&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">   A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">   <span class="type">int</span> a;</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> i) { a = i; }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   A a1;</span><br><span class="line">   A a2 = a1;  <span class="comment">// 错误, 拷贝构造函数被禁用</span></span><br><span class="line">   A a3;</span><br><span class="line">   a3 = a1;  <span class="comment">// 错误, 拷贝赋值操作符被禁用</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>delele 函数在 c++11 中很常用，std::unique_ptr 就是通过 delete
修饰来禁止对象的拷贝的.</p>
<h4 id="explicit">explicit</h4>
<p>explicit 专用于修饰构造函数，表示只能显式构造，不可以被隐式转换，
根据代码看 explicit 的作用：</p>
<p>不用 explicit：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> value) { <span class="comment">// 没有explicit关键字</span></span><br><span class="line">       cout &lt;&lt; <span class="string">"value"</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   A a = <span class="number">1</span>; <span class="comment">// 可以隐式转换</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用 explicit:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">   <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> value)</span> </span>{</span><br><span class="line">       cout &lt;&lt; <span class="string">"value"</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   A a = <span class="number">1</span>; <span class="comment">// error, 不可以隐式转换</span></span><br><span class="line">   <span class="function">A <span class="title">aa</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// ok</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="const">const</h4>
<p>因为要讲后面的 constexpr, 所以这里简单介绍下 const.</p>
<p>const 字面意思为只读，可用于定义变量，表示变量是只读的，不可以更改，
如果更改，编译期间就会报错.</p>
<p>主要用法如下：</p>
<ol type="1">
<li>用于定义常量，const 的修饰的变量不可更改.</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> value = <span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure>
<ol start="2" type="1">
<li>指针也可以使用 const, 这里有个小技巧，从右向左读，即可知道 const
究竟修饰的是指针还是指针所指向的内容.</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="type">const</span> ptr; <span class="comment">// 指针本身是常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ptr; <span class="comment">// 指针指向的变量为常量</span></span><br></pre></td></tr></tbody></table></figure>
<ol start="3" type="1">
<li>在函数参数中使用 const, 一般会传递类对象时会传递一个 const
的引用或者指针，这样可以避免对象的拷贝，也可以防止对象被修改.</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ol start="4" type="1">
<li>const 修饰类的成员变量，表示是成员常量，不能被修改，
可以在初始化列表中被赋值.</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> {</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v){}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ol start="5" type="1">
<li>修饰类成员函数，表示在该函数内不可以修改该类的成员变量.</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ol start="6" type="1">
<li>修饰类对象，类对象只能调用该对象的 const 成员函数.</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br><span class="line"><span class="type">const</span> A a;</span><br><span class="line">a.<span class="built_in">func</span>();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h4 id="constexpr">constexpr</h4>
<p>constexpr 是 c++11 新引入的关键字，用于编译时的常量和常量函数，
这里直接介绍 constexpr 和 const 的区别：</p>
<p>两者都代表可读，const 只表示 read only 的语义，
只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，而
constexpr 修饰的才是真正的常量，它会在编译期间就会被计算出来，
整个运行过程中都不可以被改变，constexpr 可以用于修饰函数，
这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，
但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理.
如下代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>{</span><br><span class="line">   <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">func</span>(i);<span class="comment">// 普通函数</span></span><br><span class="line">   <span class="built_in">func</span>(<span class="number">2</span>);<span class="comment">// 编译期间就会被计算出来</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="enum-class">enum class</h4>
<p>c++11 新增有作用域的枚举类型，看代码</p>
<p>不带作用域的枚举代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">AColor</span> {</span><br><span class="line">   kRed,</span><br><span class="line">   kGreen,</span><br><span class="line">   kBlue</span><br><span class="line">};</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">BColor</span> {</span><br><span class="line">   kWhite,</span><br><span class="line">   kBlack,</span><br><span class="line">   kYellow</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   <span class="keyword">if</span> (kRed == kWhite) {</span><br><span class="line">       cout &lt;&lt; <span class="string">"red == white"</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如上代码，不带作用域的枚举类型可以自动转换成整形，
且不同的枚举可以相互比较，代码中的红色居然可以和白色比较，
这都是潜在的难以调试的 bug, 而这种完全可以通过有作用域的枚举来规避.</p>
<p>有作用域的枚举代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">AColor</span> {</span><br><span class="line">   kRed,</span><br><span class="line">   kGreen,</span><br><span class="line">   kBlue</span><br><span class="line">};</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">BColor</span> {</span><br><span class="line">   kWhite,</span><br><span class="line">   kBlack,</span><br><span class="line">   kYellow</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   <span class="keyword">if</span> (AColor::kRed == BColor::kWhite) { <span class="comment">// 编译失败</span></span><br><span class="line">       cout &lt;&lt; <span class="string">"red == white"</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用带有作用域的枚举类型后，对不同的枚举进行比较会导致编译失败，
消除潜在 bug, 同时带作用域的枚举类型可以选择底层类型，默认是 int,
可以改成 char 等别的类型.</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">AColor</span> : <span class="type">char</span> {</span><br><span class="line">   kRed,</span><br><span class="line">   kGreen,</span><br><span class="line">   kBlue</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>我们平时编程过程中使用枚举，
一定要使用有作用域的枚举取代传统的枚举.</p>
<h4 id="非受限联合体">非受限联合体</h4>
<p>c++11 之前 union 中数据成员的类型不允许有非 POD 类型，而这个限制在
c++11 被取消，允许数据成员类型有非 POD 类型，看代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">   <span class="type">int</span> a;</span><br><span class="line">   <span class="type">int</span> *b;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span> {</span><br><span class="line">   A a; <span class="comment">// 非POD类型 c++11之前不可以这样定义联合体</span></span><br><span class="line">   <span class="type">int</span> b;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>对于什么是 POD 类型，大家可以自行查下资料，
大体上可以理解为对象可以直接 memcpy 的类型.</p>
<h4 id="sizeof">sizeof</h4>
<p>c++11 中 sizeof 可以用的类的数据成员上，看代码：</p>
<p>c++11 前：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">   <span class="type">int</span> data[<span class="number">10</span>];</span><br><span class="line">   <span class="type">int</span> a;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   A a;</span><br><span class="line">   cout &lt;&lt; <span class="string">"size "</span> &lt;&lt; <span class="built_in">sizeof</span>(a.data) &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>c++11 后：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">   <span class="type">int</span> data[<span class="number">10</span>];</span><br><span class="line">   <span class="type">int</span> a;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   cout &lt;&lt; <span class="string">"size "</span> &lt;&lt; <span class="built_in">sizeof</span>(A::data) &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>想知道类中数据成员的大小在 c++11 中是不是方便了许多，
而不需要定义一个对象，在计算对象的成员大小.</p>
<h4 id="assertion">assertion</h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="literal">true</span>/<span class="literal">false</span>, message);</span><br></pre></td></tr></tbody></table></figure>
<p>c++11 引入 static_assert 声明，用于在编译期间检查，如果第一个参数值为
false, 则打印 message, 编译失败.</p>
<h4 id="自定义字面量">自定义字面量</h4>
<p>c++11 可以自定义字面量，我们平时 c++ 中都或多或少使用过 chrono
中的时间，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>)); <span class="comment">// 100ms</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">100</span>)); <span class="comment">// 100s</span></span><br></pre></td></tr></tbody></table></figure>
<p>其实没必要这么麻烦，也可以这么写：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">100</span>ms); <span class="comment">// c++14里可以这么使用, 这里只是举个自定义字面量使用的例子</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">100</span>s);</span><br></pre></td></tr></tbody></table></figure>
<p>这就是自定义字面量的使用，示例如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mytype</span> {</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> value;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">constexpr</span> mytype <span class="keyword">operator</span><span class="string">""</span> _mytype ( <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> n ) {</span><br><span class="line">   <span class="keyword">return</span> mytype{n};</span><br><span class="line">}</span><br><span class="line">mytype mm = <span class="number">123</span>_mytype;</span><br><span class="line">cout &lt;&lt; mm.value &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure>
<p>关于自定义字面量，可以看下 chrono 的源代码，相信大家会有很大收获，
需要源码分析 chrono 的话，可以留言给我.</p>
<h4 id="内存对齐">内存对齐</h4>
<h4 id="什么是内存对齐">什么是内存对齐</h4>
<p>理论上计算机对于任何变量的访问都可以从任意位置开始，
然而实际上系统会对这些变量的存放地址有限制，通常将变量首地址设为某个数 N
的倍数，这就是内存对齐.</p>
<h4 id="为什么要内存对齐">为什么要内存对齐</h4>
<ol type="1">
<li>硬件平台限制，内存以字节为单位，
不同硬件平台不一定支持任何内存地址的存取，一般可能以双字节、4
字节等为单位存取内存，为了保证处理器正确存取数据，需要进行内存对齐.</li>
<li> 提高 CPU 内存访问速度，一般处理器的内存存取粒度都是 N 的整数倍，
假如访问 N 大小的数据，没有进行内存对齐，
有可能就需要两次访问才可以读取出数据，
而进行内存对齐可以一次性把数据全部读取出来，提高效率.</li>
</ol>
<p>在 c++11 之前如果想创建内存对齐需要：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">align_cpp11_before</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   <span class="type">static</span> <span class="type">char</span> data[<span class="built_in">sizeof</span>(<span class="type">void</span> *) + <span class="built_in">sizeof</span>(A)];</span><br><span class="line">   <span class="type">const</span> <span class="type">uintptr_t</span> kAlign = <span class="built_in">sizeof</span>(<span class="type">void</span> *) - <span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span> *align_ptr =</span><br><span class="line">       <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(data + kAlign) &amp; ~kAlign);</span><br><span class="line">   A *attr = <span class="built_in">new</span> (align_ptr) A;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>c++11 关于内存对齐新增了一些函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">align_cpp11_after</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   <span class="type">static</span> std::aligned_storage&lt;<span class="built_in">sizeof</span>(A),</span><br><span class="line">                               <span class="built_in">alignof</span>(A)&gt;::type data;</span><br><span class="line">   A *attr = <span class="built_in">new</span> (&amp;data) A;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>还有：alignof ()、std::alignment_of ()、alignas (),
关于内存对齐详情可以看这篇文章：<a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483981&amp;idx=1&amp;sn=cfda6e84fd77084c75e5048187a1ab28&amp;chksm=eb7a04dedc0d8dc8cb2a26e92f254e23a4538cd2756a1d7f0e8a2aaf99c6e18a42391208276f&amp;scene=21#wechat_redirect">内存对齐之格式修订版</a></p>
<h4 id="thread_local">thread_local</h4>
<p>c++11 引入 thread_local, 用 thread_local 修饰的变量具有 thread 周期，
每一个线程都拥有并只拥有一个该变量的独立实例，
一般用于需要保证线程安全的函数中.</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">A</span>() {}</span><br><span class="line">   ~<span class="built_in">A</span>() {}</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span> </span>{</span><br><span class="line">       <span class="keyword">thread_local</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">       ++count;</span><br><span class="line">       std::cout &lt;&lt; name &lt;&lt; <span class="string">": "</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span> </span>{</span><br><span class="line">   A a1;</span><br><span class="line">   a1.<span class="built_in">test</span>(name);</span><br><span class="line">   a1.<span class="built_in">test</span>(name);</span><br><span class="line">   A a2;</span><br><span class="line">   a2.<span class="built_in">test</span>(name);</span><br><span class="line">   a2.<span class="built_in">test</span>(name);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   std::<span class="built_in">thread</span>(func, <span class="string">"thread1"</span>).<span class="built_in">join</span>();</span><br><span class="line">   std::<span class="built_in">thread</span>(func, <span class="string">"thread2"</span>).<span class="built_in">join</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">thread1: 1</span><br><span class="line">thread1: 2</span><br><span class="line">thread1: 3</span><br><span class="line">thread1: 4</span><br><span class="line">thread2: 1</span><br><span class="line">thread2: 2</span><br><span class="line">thread2: 3</span><br><span class="line">thread2: 4</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>验证上述说法，对于一个线程私有变量，一个线程拥有且只拥有一个该实例，
类似于 static.</p>
<h4 id="基础数值类型">基础数值类型</h4>
<p>c++11 新增了几种数据类型：long long、char16_t、char32_t 等</p>
<h4 id="随机数功能">随机数功能</h4>
<p>c++11 关于随机数功能则较之前丰富了很多，典型的可以选择概率分布类型，
先看如下代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   <span class="function">std::default_random_engine <span class="title">random</span><span class="params">(time(<span class="literal">nullptr</span>))</span></span>;</span><br><span class="line">   <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">int_dis</span><span class="params">(<span class="number">0</span>, <span class="number">100</span>)</span></span>; <span class="comment">// 整数均匀分布</span></span><br><span class="line">   <span class="function">std::uniform_real_distribution&lt;<span class="type">float</span>&gt; <span class="title">real_dis</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>; <span class="comment">// 浮点数均匀分布</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</span><br><span class="line">       cout &lt;&lt; <span class="built_in">int_dis</span>(random) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  }</span><br><span class="line">   cout &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</span><br><span class="line">       cout &lt;&lt; <span class="built_in">real_dis</span>(random) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  }</span><br><span class="line">   cout &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">38 100 93 7 66 0 68 99 41 7</span><br><span class="line">0.232202 0.617716 0.959241 0.970859 0.230406 0.430682 0.477359 0.971858 0.0171148 0.64863</span><br></pre></td></tr></tbody></table></figure>
<p>代码中举例的是整数均匀分布和浮点数均匀分布，c++11
提供的概率分布类型还有好多，例如伯努利分布、正态分布等，
具体可以见最后的参考资料.</p>
<h4 id="正则表达式">正则表达式</h4>
<p>c++11 引入了 regex 库更好的支持正则表达式，见代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   std::string s = <span class="string">"I know, I'll use2 regular expressions."</span>;</span><br><span class="line"><span class="comment">// 忽略大小写</span></span><br><span class="line">   <span class="function">std::regex <span class="title">self_regex</span><span class="params">(<span class="string">"REGULAR EXPRESSIONS"</span>, std::regex_constants::icase)</span></span>;</span><br><span class="line">   <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(s, self_regex)) {</span><br><span class="line">       std::cout &lt;&lt; <span class="string">"Text contains the phrase 'regular expressions'\n"</span>;</span><br><span class="line">  }</span><br><span class="line">   <span class="function">std::regex <span class="title">word_regex</span><span class="params">(<span class="string">"(\\w+)"</span>)</span></span>;  <span class="comment">// 匹配字母数字等字符</span></span><br><span class="line">   <span class="keyword">auto</span> words_begin = std::<span class="built_in">sregex_iterator</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), word_regex);</span><br><span class="line">   <span class="keyword">auto</span> words_end = std::<span class="built_in">sregex_iterator</span>();</span><br><span class="line">   std::cout &lt;&lt; <span class="string">"Found "</span> &lt;&lt; std::<span class="built_in">distance</span>(words_begin, words_end) &lt;&lt; <span class="string">" words\n"</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> N = <span class="number">6</span>;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">"Words longer than "</span> &lt;&lt; N &lt;&lt; <span class="string">" characters:\n"</span>;</span><br><span class="line">   <span class="keyword">for</span> (std::sregex_iterator i = words_begin; i != words_end; ++i) {</span><br><span class="line">       std::smatch match = *i;</span><br><span class="line">       std::string match_str = match.<span class="built_in">str</span>();</span><br><span class="line">       <span class="keyword">if</span> (match_str.<span class="built_in">size</span>() &gt; N) {</span><br><span class="line">           std::cout &lt;&lt; <span class="string">" "</span> &lt;&lt; match_str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line">   <span class="function">std::regex <span class="title">long_word_regex</span><span class="params">(<span class="string">"(\\w{7,})"</span>)</span></span>;</span><br><span class="line">   <span class="comment">// 超过7个字符的单词用[]包围</span></span><br><span class="line">   std::string new_s = std::<span class="built_in">regex_replace</span>(s, long_word_regex, <span class="string">"[$&amp;]"</span>);</span><br><span class="line">   std::cout &lt;&lt; new_s &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="chrono">chrono</h4>
<p>c++11 关于时间引入了 chrono 库，源于 boost, 功能强大，chrono
主要有三个点：</p>
<ul>
<li>duration</li>
<li>time_point</li>
<li>clocks</li>
</ul>
<h4 id="duration">duration</h4>
<p>std::chrono::duration 表示一段时间，常见的单位有 s、ms 等，
示例代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 拿休眠一段时间举例, 这里表示休眠100ms</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br></pre></td></tr></tbody></table></figure>
<p>sleep_for 里面其实就是 std::chrono::duration, 表示一段时间，
实际是这样：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="type">int64_t</span>, milli&gt; milliseconds;</span><br><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="type">int64_t</span>&gt; seconds;</span><br></pre></td></tr></tbody></table></figure>
<p>duration 具体模板如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span> = ratio&lt;<span class="number">1</span>&gt; &gt; <span class="keyword">class</span> duration;</span><br></pre></td></tr></tbody></table></figure>
<p>Rep 表示一种数值类型，用来表示 Period 的数量，比如
int、float、double, Period 是 ratio 类型，
用来表示【用秒表示的时间单位】比如 second, 常用的 duration&lt;Rep,
Period&gt; 已经定义好了，在 std::chrono::duration 下：</p>
<ul>
<li>ratio&lt;3600, 1&gt;：hours</li>
<li>ratio&lt;60, 1&gt;：minutes</li>
<li>ratio&lt;1, 1&gt;：seconds</li>
<li>ratio&lt;1, 1000&gt;：microseconds</li>
<li>ratio&lt;1, 1000000&gt;：microseconds</li>
<li>ratio&lt;1, 1000000000&gt;：nanosecons</li>
</ul>
<p>ratio 的具体模板如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">intmax_t</span> N, <span class="type">intmax_t</span> D = <span class="number">1</span>&gt; <span class="keyword">class</span> ratio;</span><br></pre></td></tr></tbody></table></figure>
<p>N 代表分子，D 代表分母，所以 ratio 表示一个分数，我们可以自定义
Period, 比如 ratio&lt;2, 1&gt; 表示单位时间是 2 秒.</p>
<h4 id="time_point">time_point</h4>
<p>表示一个具体时间点，如 2020 年 5 月 10 日 10 点 10 分 10 秒，
拿获取当前时间举例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">std::<span class="function">chrono::time_point&lt;std::chrono::high_resolution_clock&gt; <span class="title">Now</span><span class="params">()</span> </span>{</span><br><span class="line">   <span class="keyword">return</span> std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">}</span><br><span class="line"><span class="comment">// std::chrono::high_resolution_clock为高精度时钟, 下面会提到</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>clocks</strong></p>
<p>时钟，chrono 里面提供了三种时钟：</p>
<ul>
<li>steady_clock</li>
<li>system_clock</li>
<li>high_resolution_clock</li>
</ul>
<h4 id="steady_clock">steady_clock</h4>
<p>稳定的时间间隔，表示相对时间，相对于系统开机启动的时间，
无论系统时间如何被更改，后一次调用 now () 肯定比前一次调用 now ()
的数值大，可用于计时.</p>
<h4 id="system_clock">system_clock</h4>
<p>表示当前的系统时钟，可以用于获取当前时间：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   <span class="keyword">using</span> std::chrono::system_clock;</span><br><span class="line">   system_clock::time_point today = system_clock::<span class="built_in">now</span>();</span><br><span class="line">   std::<span class="type">time_t</span> tt = system_clock::<span class="built_in">to_time_t</span>(today);</span><br><span class="line">   std::cout &lt;&lt; <span class="string">"today is: "</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;tt);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// today is: Sun May 10 09:48:36 2020</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>high_resolution_clock</strong></p>
<p>high_resolution_clock 表示系统可用的最高精度的时钟，实际上就是
system_clock 或者 steady_clock 其中一种的定义，官方没有说明具体是哪个，
不同系统可能不一样，我之前看 gcc chrono 源码中 high_resolution_clock 是
steady_clock 的 typedef.</p>
<p>更多关于 chrono 的介绍可以看下我之前的文章：<a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483852&amp;idx=1&amp;sn=34dde853d5304f8a165e82effe287f3c&amp;chksm=eb7a075fdc0d8e4971f55dc3c4ad4388a3c7466c6df5a47bcfa81510de230cf22065298fee26&amp;scene=21#wechat_redirect">RAII
妙用之计算函数耗时</a></p>
<h4 id="新增数据结构">新增数据结构</h4>
<ul>
<li>std::forward_list：单向链表，只可以前进，在特定场景下使用，相比于
std::list 节省了内存，提高了性能 </li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">std::forward_list&lt;<span class="type">int</span>&gt; fl = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;elem : fl) {</span><br><span class="line">   cout &lt;&lt; elem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>std::unordered_set：基于 hash 表实现的 set, 内部不会排序，使用方法和
set 类似</li>
<li> std::unordered_map：基于 hash 表实现的 map, 内部不会排序，使用方法和
set 类似</li>
<li> std::array：数组，在越界访问时抛出异常，建议使用 std::array
替代普通的数组</li>
<li> std::tuple：元组类型，类似 pair, 但比 pair 扩展性好 </li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">int</span>, <span class="type">double</span>&gt; Mytuple;</span><br><span class="line"><span class="function">Mytuple <span class="title">t</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">"0 "</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t);</span><br><span class="line">std::cout &lt;&lt; <span class="string">"1 "</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t);</span><br><span class="line">std::cout &lt;&lt; <span class="string">"2 "</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t);</span><br><span class="line">std::cout &lt;&lt; <span class="string">"3 "</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(t);</span><br></pre></td></tr></tbody></table></figure>
<p>新增算法</p>
<ul>
<li>all_of：检测表达式是否对范围 [first, last) 中所有元素都返回 true,
如果都满足，则返回 true</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (std::<span class="built_in">all_of</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), [](<span class="type">int</span> i) { <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>; })) {</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"All numbers are even\n"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>any_of：检测表达式是否对范围 [first, last) 中至少一个元素返回 true,
如果满足，则返回 true, 否则返回 false, 用法和上面一样</li>
<li> none_of：检测表达式是否对范围 [first, last) 中所有元素都不返回 true,
如果都不满足，则返回 true, 否则返回 false, 用法和上面一样</li>
<li> find_if_not：找到第一个不符合要求的元素迭代器，和 find_if 相反</li>
<li> copy_if：复制满足条件的元素</li>
<li> itoa：对容器内的元素按序递增 </li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">iota</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>(), <span class="number">19</span>); <span class="comment">// 19为初始值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> n : l) std::cout &lt;&lt; n &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="comment">// 19 20 21 22 23 24 25 26 27 28</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>minmax_element：返回容器内最大元素和最小元素位置 </li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   std::vector&lt;<span class="type">int</span>&gt; v = {<span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>};</span><br><span class="line">   <span class="keyword">auto</span> result = std::<span class="built_in">minmax_element</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">   std::cout &lt;&lt; <span class="string">"min element at: "</span> &lt;&lt; *(result.first) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">"max element at: "</span> &lt;&lt; *(result.second) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// min element at: 1</span></span><br><span class="line"><span class="comment">// max element at: 9</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>is_sorted、is_sorted_until：返回容器内元素是否已经排好序.</li>
</ul>
<p>关于 c++11 的新特性基本上就是这些，相信各位看完一定会有所收获.</p>
<h3 id="参考资料">参考资料</h3>
<blockquote>
<p><a href="https://zh.cppreference.com/w/cpp/language/range-for">https://zh.cppreference.com/w/cpp/language/range-for</a></p>
</blockquote>
<blockquote>
<p><a href="https://juejin.im/post/5dcaa857e51d457f7675360b">https://juejin.im/post/5dcaa857e51d457f7675360b</a></p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/21930436">https://zhuanlan.zhihu.com/p/21930436</a></p>
</blockquote>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/Nullptr">https://zh.wikipedia.org/wiki/Nullptr</a></p>
</blockquote>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/Constexpr">https://zh.wikipedia.org/wiki/Constexpr</a></p>
</blockquote>
<blockquote>
<p><a href="https://zh.cppreference.com/w/cpp/language/enum">https://zh.cppreference.com/w/cpp/language/enum</a></p>
</blockquote>
<blockquote>
<p><a href="https://kheresy.wordpress.com/2019/03/27/using-enum-class/">https://kheresy.wordpress.com/2019/03/27/using-enum-class/</a></p>
</blockquote>
<blockquote>
<p><a href="https://zh.cppreference.com/w/cpp/language/union">https://zh.cppreference.com/w/cpp/language/union</a></p>
</blockquote>
<blockquote>
<p><a href="http://c.biancheng.net/view/7165.html">http://c.biancheng.net/view/7165.html</a></p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/77585472">https://zhuanlan.zhihu.com/p/77585472</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.cplusplus.com/reference/random/">http://www.cplusplus.com/reference/random/</a></p>
</blockquote>
<blockquote>
<p><a href="https://zh.cppreference.com/w/cpp/regex">https://zh.cppreference.com/w/cpp/regex</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/jwk000/p/3560086.html">https://www.cnblogs.com/jwk000/p/3560086.html</a></p>
</blockquote>
<blockquote>
<p><a href="https://zh.cppreference.com/w/cpp/algorithm/all_any_none_of">https://zh.cppreference.com/w/cpp/algorithm/all_any_none_of</a></p>
</blockquote>
<p>往期回顾</p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483885&amp;idx=1&amp;sn=ba3342f7807d347747946df4b9bb4b4c&amp;chksm=eb7a077edc0d8e68f9bde2e39e64e18f5c2e2d85bd9abeb44986fe64a8c7dcbceb5333b78298&amp;scene=21#wechat_redirect">一文让你搞懂设计模式</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483852&amp;idx=1&amp;sn=34dde853d5304f8a165e82effe287f3c&amp;chksm=eb7a075fdc0d8e4971f55dc3c4ad4388a3c7466c6df5a47bcfa81510de230cf22065298fee26&amp;scene=21#wechat_redirect">RAII
妙用之计算函数耗时</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483840&amp;idx=1&amp;sn=48a5ba180c61877134344084e25d27f4&amp;chksm=eb7a0753dc0d8e450dcfe3a6d6b0405c043b60944173510836049802d48828e366d47d88674e&amp;scene=21#wechat_redirect">深入浅出虚拟内存</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&amp;mid=2247483823&amp;idx=1&amp;sn=732303e36464f0c9fb4bd75fa10ba4db&amp;chksm=eb7a073cdc0d8e2a6dca8babec94ce063ccab0c7832b9d85539357fe2da692fc6ad6cd5b938b&amp;scene=21#wechat_redirect">C++
线程池的实现之格式修订版</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>ArchLinux 使用</title>
    <url>/posts/2d9deefc/</url>
    <content><![CDATA[<p>Arch 是众多 Linux 发行版中的其中一个，但是它比较纯净，
同时安装也相比于其它的 Linux 发行版复杂一些，
从头安装一个 ArchLinux 可以学习不少 Linux 知识</p>
<p>推荐按照官方的安装教程一步步执行:
https://wiki.archlinux.org/title/Installation_guide</p>
<p>最好阅读英文版，更新日期比较新</p>
<p>以下是折腾 Arch 的记录</p>
<span id="more"></span>
<h2 id="安装步骤">1 安装步骤</h2>
<h3 id="制作启动u盘">1.1 制作启动 U 盘</h3>
<ul>
<li>镜像文件下载: https://archlinux.org/download/</li>
<li> 使用 rufus 等工具制作 UEFI 启动盘</li>
<li> BIOS 中设置启动模式为 UEFI</li>
<li> 通过 U 盘启动</li>
</ul>
<h3 id="连接网络">1.2 连接网络</h3>
<p>U 盘启动后是一个用于安装系统的 Linux 环境，必须连接到网络才能进行 arch
linux 的安装</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 查看网卡状态, 打开网口</span></span><br><span class="line">ip <span class="built_in">link</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> dev [interface] up</span><br><span class="line"></span><br><span class="line"><span class="comment"># iwctl 连接wifi</span></span><br><span class="line">iwctl <span class="comment"># 进入iwc交互模式</span></span><br><span class="line">[iwd] <span class="built_in">help</span></span><br><span class="line">[iwd] device list</span><br><span class="line">[iwd] device [device] set-property Powered on</span><br><span class="line">[iwd] adapter [adapter] set-property Powered on</span><br><span class="line">[iwd] station [device] scan</span><br><span class="line">[iwd] station [device] get-networks</span><br><span class="line">[iwd] station [device] connect SSID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测网络</span></span><br><span class="line">ping archlinux.org</span><br></pre></td></tr></tbody></table></figure>
<p>如果 wifi 不好连接，可直接使用网线连接</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 查看系统ip地址</span></span><br><span class="line">ip addr</span><br></pre></td></tr></tbody></table></figure>
<p>之后使用 ssh 远程连接，方便操作</p>
<h3 id="同步系统时钟">1.3 同步系统时钟</h3>
<p>同步系统时钟</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 开启时间同步</span></span><br><span class="line">timedatectl set-ntp <span class="literal">true</span></span><br><span class="line"><span class="comment"># 时区不对先不用管</span></span><br><span class="line">timedatectl</span><br></pre></td></tr></tbody></table></figure>
<h3 id="磁盘分区">1.4 磁盘分区</h3>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 查看磁盘设备</span></span><br><span class="line">lsblk</span><br><span class="line">fdisk -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用fdisk分区</span></span><br><span class="line">fdisk /dev/[nvme0n1] <span class="comment"># 需要分区的磁盘设备, 交互式操作, m查看帮助, 创建GTP分区表, 分区开始位置自动, 结束位置可以使用+1G的方式确定</span></span><br></pre></td></tr></tbody></table></figure>
<p>一般来说，一个 linux 系统需要以下 3 个分区</p>
<table>
<colgroup>
<col style="width: 12%">
<col style="width: 30%">
<col style="width: 57%">
</colgroup>
<thead>
<tr class="header">
<th>挂载点</th>
<th>大小</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>/boot</code></td>
<td>300M ~ 1G</td>
<td>EFI 分区，一般需要是磁盘第一个分区</td>
</tr>
<tr class="even">
<td><code>[swap]</code></td>
<td>4G ~ 32G (看心情)</td>
<td> 交换分区，内存不足时用于缓存</td>
</tr>
<tr class="odd">
<td><code>/</code></td>
<td>剩余所有</td>
<td> linux 系统根目录</td>
</tr>
</tbody>
</table>
<p>也可以根据需要将 <code>/home</code>, <code>/root</code>,
<code>/srv</code> 或者 <code>/var</code> 等进行单独分区，以便于数据备份</p>
<p>fdisk 分区写入后，退出交互操作，格式化各分区</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 格式化分区</span></span><br><span class="line">mkfs.ext4 /dev/[root_partition] <span class="comment"># 以及其它linux文件分区, /home, /root, /srv</span></span><br><span class="line">mkswap /dev/[swap_partition]</span><br><span class="line">mkfs.fat -F 32 /dev/[efi_system_partition] <span class="comment"># EFI分区必须格式化为FAT32格式</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="挂载系统分区">1.5 挂载系统分区</h3>
<p>所有的分区都要按照实际情况挂载上去，包括交换分区，
之后的 <code>genfstab</code> 命令会检测所有的挂载分区和交换分区</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 首先挂载根分区</span></span><br><span class="line">mount /dev/[root_partition] /mnt</span><br><span class="line">mount --<span class="built_in">mkdir</span> /dev/[efi_system_partition] /mnt/boot</span><br><span class="line"><span class="comment"># 如果有自定义的其余分区, 也都挂载进来</span></span><br><span class="line">mount --<span class="built_in">mkdir</span> /dev/[home_partition] /mnt/home</span><br><span class="line">mount --<span class="built_in">mkdir</span> /dev/[root_home_partition] /mnt/root</span><br><span class="line">mount --<span class="built_in">mkdir</span> /dev/[srv_partition] /mnt/srv</span><br><span class="line"><span class="comment"># 如果有swap分区, 也打开它</span></span><br><span class="line">swapon /dev/[swap_partition]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="更改pacman镜像源">1.6 更改 pacman 镜像源</h3>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">nano /etc/pacman.d/mirrorlist</span><br><span class="line"><span class="comment"># 源的优先级取决于顺序, 可以将以下国内源添加在最上方</span></span><br><span class="line"><span class="comment"># Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="安装系统">1.7 安装系统</h3>
<p>首先安装必须的基本包</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">pacstrap -K /mnt base linux linux-firmware</span><br></pre></td></tr></tbody></table></figure>
<p>配置系统</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 将分区挂载信息写入fstab文件, 生成文件后检查文件是否有错</span></span><br><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></tbody></table></figure>
<p>change root 到新系统下</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></tbody></table></figure>
<p>设置系统时间时区</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -sf /usr/share/zoneinfo/[Asia/Shanghai] /etc/localtime</span><br><span class="line">hwclock --systohc <span class="comment"># 写入系统时间bios</span></span><br></pre></td></tr></tbody></table></figure>
<p>本地化配置</p>
<p>编辑 <code>/etc/locale.gen</code>, 取消注释
<code>en_US.UTF-8 UTF-8</code>, 执行以下命名</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">locale-gen</span><br></pre></td></tr></tbody></table></figure>
<p>创建 <code>/etc/locale.conf</code>, 填入以下内容</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">LANG=en_US.UTF-8</span><br></pre></td></tr></tbody></table></figure>
<p>设置网络名称</p>
<p>创建 <code>/etc/hostname</code> 文件，
并填写自己的 <code>hostname</code></p>
<p>更改 root 账户密码</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></tbody></table></figure>
<p>安装配置 grub</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 更新源信息</span></span><br><span class="line">pacman -Sy</span><br><span class="line">pacman -S grub</span><br><span class="line"><span class="comment"># 安装启动文件</span></span><br><span class="line">grub-install --target=x86_64-efi --efi-directory=[/boot] --bootloader-id=GRUB</span><br><span class="line"><span class="comment"># 生成grub配置</span></span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></tbody></table></figure>
<p>安装 microcode 微码包</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># intel cpu安装intel-ucode, amd cpu安装amd-ucode</span></span><br><span class="line">pacman -S amd-ucode</span><br></pre></td></tr></tbody></table></figure>
<p>微码包应该尽量早的加载，可以通过 grub 配置</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 重新运行grub配置, 将自动检测微码包资源, 并放在最开始加载</span></span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br><span class="line"><span class="comment"># 在/boot/grub/grub.cfg中应该能看到以下配置</span></span><br><span class="line"><span class="comment"># initrd    /boot/[cpu_manufacturer]-ucode.img /boot/initramfs-linux.img</span></span><br></pre></td></tr></tbody></table></figure>
<p>安装基本软件</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 安装需要的软件</span></span><br><span class="line">pacman -S base-devel openssh nano dhcpcd wpa_supplicant neofetch dmidecode radeontop</span><br></pre></td></tr></tbody></table></figure>
<p>配置网络和 ssh (以免重启后未联网，还要重新操作，或者连接显示器，
比较麻烦)</p>
<p>参考</p>
<p>https://wiki.archlinux.org/title/Network_configuration/Wireless</p>
<p>https://wiki.archlinux.org/title/Dhcpcd</p>
<p>https://wiki.archlinux.org/title/Wpa_supplicant</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑ssh配置, 允许root登录</span></span><br><span class="line">nano /etc/ssh/sshd_config <span class="comment"># PermitRootLogin yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开ssh自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> sshd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加dhcp对wpa_supplicant(wifi wpa)的hook</span></span><br><span class="line"><span class="built_in">ln</span> -s /usr/share/dhcpcd/hooks/10-wpa_supplicant /usr/lib/dhcpcd/dhcpcd-hooks/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网口</span></span><br><span class="line">ip <span class="built_in">link</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅开启无线网口的自启动配置, 如果没有@xxx, 那么会自启动所有网口</span></span><br><span class="line">systemctl <span class="built_in">enable</span> dhcpcd@[wlan0].service</span><br><span class="line"></span><br><span class="line"><span class="comment"># wpa_supplicant配置, wpa_supplicant会由dhcpcd自动打开, 如果使用systemctl自启动, 也可以开启wpa_supplicant@[wlan0].service</span></span><br><span class="line">wpa_passphrase [MYSSID] [passphrase] &gt; /etc/wpa_supplicant/wpa_supplicant-[wlan0].conf</span><br></pre></td></tr></tbody></table></figure>
<p>配置好所有内容后，重启系统</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 关机使用poweroff</span></span><br><span class="line">reboot</span><br></pre></td></tr></tbody></table></figure>
<h2 id="使用pacman">2 使用 pacman</h2>
<p>帮助: <code>pacman -h</code></p>
<p>标签帮助: <code>pacman -Sh</code></p>
<p>更新软件源: <code>pacman -Sy</code></p>
<p>更新源并更新系统: <code>pacman -Syu</code></p>
<p>搜索在线包: <code>pacman -Ss &lt;package_name&gt;</code></p>
<p>安装包: <code>pacman -S &lt;package_name&gt;</code></p>
<p><code>pacman -Rns &lt;package_name&gt;</code>
删除软件以及不被其他软件依赖的包 (<code>-Rsu</code>
可能删除其他软件包还在依赖的项，不安全)</p>
<p><code>pacman -Rc &lt;package_name&gt;</code>
删除软件包以及其配置项 (可以先使用</p>
<p><code>pacman -Qdtq</code> 列出不再被其它软件包依赖的软件包名称</p>
<h2 id="常用软件">3 常用软件</h2>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 查看cpu核心信息</span></span><br><span class="line">lscpu -e</span><br><span class="line"><span class="comment"># 查看各传感器温度</span></span><br><span class="line">pacman -Syu</span><br><span class="line">pacman -S lm_sensors <span class="comment"># 工具集, 可以搜索以下lm_sensors其余用法</span></span><br><span class="line">sensors <span class="comment"># 查看硬件温度</span></span><br><span class="line"><span class="comment"># 查看内存占用</span></span><br><span class="line">free -h</span><br><span class="line"><span class="comment"># 查看磁盘占用</span></span><br><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"><span class="comment"># 查看系统信息</span></span><br><span class="line">pacman -S neofetch</span><br><span class="line">neofetch</span><br><span class="line"><span class="comment"># 查看磁盘分区详情</span></span><br><span class="line">lsblk</span><br><span class="line">fdisk -l</span><br><span class="line"><span class="comment"># 查看pci设备</span></span><br><span class="line">lspci [-k]</span><br><span class="line"><span class="comment"># 查看硬件信息</span></span><br><span class="line">dmidecode [-t memory]</span><br><span class="line"><span class="comment"># 查看amd显卡信息</span></span><br><span class="line">radeontop</span><br></pre></td></tr></tbody></table></figure>
<p>至此已安装完毕</p>
<h2 id="展示环节">4 展示环节</h2>
<img data-src="/posts/2d9deefc/sensors.png" class="">
<img data-src="/posts/2d9deefc/cpu_ram.png" class="">
<img data-src="/posts/2d9deefc/radeontop.png" class="">
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Arch</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 不定参数到 lambda 的传递</title>
    <url>/posts/15ddce4e/</url>
    <content><![CDATA[<p>使用 不定参数列表传递到 lambda 中总是报错，这里记录一下正确用法</p>
<span id="more"></span>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectPool::SetType</span><span class="params">(std::string type, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    m_mapAlloc[type].m_construct = [&amp; args...](IRecyclable* p) {</span><br><span class="line">        std::allocator&lt;T&gt; alloc;</span><br><span class="line">        std::allocator_traits&lt;std::allocator&lt;T&gt;&gt; traits;</span><br><span class="line">        traits.<span class="built_in">construct</span>(alloc, <span class="built_in">static_cast</span>&lt;T*&gt;(p), args...);</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>以上代码是正确的使用方法，对于不定参数
<code>Args&amp;&amp;... args</code> 在函数中使用时一定都是带上
<code>...</code> 使用的</p>
<p>刚开始报错就是我在 lambda 捕获列表中一直写的是
<code>[&amp;args]</code>, 而且后面传入 construct 函数时也需要使用
<code>args...</code> 或者使用 <code>std::move(args)...</code></p>
<p>关于 lambda 捕获，可以参考 <a href="https://zh.cppreference.com/w/cpp/language/lambda">Lambda 表达式
(C++11 起) - cppreference.com</a></p>
<p>关于 不定参数，可以参考 [<a href="https://zh.cppreference.com/w/cpp/language/parameter_pack">形参包
- cppreference.com</a>]</p>
<p>包展开:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">f</span>(&amp;args...); <span class="comment">// 展开成 f(&amp;E1, &amp;E2, &amp;E3)</span></span><br><span class="line"><span class="built_in">f</span>(n, ++args...); <span class="comment">// 展开成 f(n, ++E1, ++E2, ++E3);</span></span><br><span class="line"><span class="built_in">f</span>(++args..., n); <span class="comment">// 展开成 f(++E1, ++E2, ++E3, n);</span></span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> Args*&gt;(&amp;args)...);</span><br><span class="line"><span class="comment">// f(const_cast&lt;const E1*&gt;(&amp;X1), const_cast&lt;const E2*&gt;(&amp;X2), const_cast&lt;const E3*&gt;(&amp;X3))</span></span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">h</span>(args...) + args...); <span class="comment">// 展开成</span></span><br><span class="line"><span class="comment">// f(h(E1,E2,E3) + E1, h(E1,E2,E3) + E2, h(E1,E2,E3) + E3)</span></span><br></pre></td></tr></tbody></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中 lambda 使用注意事项</title>
    <url>/posts/24017eff/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/czyt1988/article/details/80149695">https://blog.csdn.net/czyt1988/article/details/80149695</a></p>
<ul>
<li><strong> 不要使用 lambda 以引用方式捕获局部变量</strong>！！！(悬挂引用)</li>
<li>lambda 捕获 this 时也需要注意，lambda 的调用时机是否在 this 的生命周期之外
(类生命周期)</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中 const 与 constexpr 的区别</title>
    <url>/posts/106f98c5/</url>
    <content><![CDATA[<p>原文地址: <a href="https://www.cnblogs.com/fortunely/p/14550145.html">const 和 constexpr 区别与联系</a></p>
<p>提到 const 和 constexpr, 就需要引入常量表达式。常量表达式是指值不会改变，
并且编译过程就能得到计算结果的表达式. =&gt; 编译阶段就能得到值，
并且不能改变.</p>
<span id="more"></span>
<p><strong>const 修饰对象无法修改，
constexpr 更侧重于修饰对象编译期确定且无法修改. </strong>具体区别，
体现在以下两个方面：</p>
<h2 id="修饰变量">修饰变量</h2>
<p><strong>const 变量，表示一个变量无法改变，但初值并不确定，
不能在编译阶段决定. </strong></p>
<p>比如，</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>(); <span class="comment">// 虽然sz无法改变, 但get_size()</span></span><br></pre></td></tr></tbody></table></figure>
<p>编译阶段无法确定值，也就是说 sz 不是常量表达式</p>
<p><strong>constexpr 变量，编译器在编译阶段验证变量是否为一个常量表达式.
</strong></p>
<p>constexpr 侧重变量初值编译阶段确定，且无法修改.
如果认定变量是一个常量表达式，就把它声明称 constexpr 类型.</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mf = <span class="number">20</span>; <span class="comment">// 字面量20是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = mf + <span class="number">1</span>; <span class="comment">// mf + 1是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">size</span>(); <span class="comment">// 只有当size是constexpr函数时, 才是正确的</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="修饰指针">修饰指针</h2>
<p>const 修饰指针分为两种情况：顶层 const, 底层 const.</p>
<p><strong>顶层 const 代表指针变量自身无法修改；底层 const 代表指针所指对象无法修改.
</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i; <span class="comment">// 顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;i; <span class="comment">// 底层const</span></span><br><span class="line"></span><br><span class="line">p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>); <span class="comment">// 错误, 顶层const指针自身无法修改</span></span><br><span class="line">p2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">30</span>); <span class="comment">// 正确, 底层const指针可以修改</span></span><br><span class="line">*p1 = <span class="number">40</span>; <span class="comment">// 正确, 顶层const指针指向的对象可以修改</span></span><br><span class="line">*p2 = <span class="number">40</span>; <span class="comment">// 错误, 底层const指针指向的对象无法修改</span></span><br></pre></td></tr></tbody></table></figure>
<p>constexpr 修饰指针，仅对指针有效，与指针所指对象无关</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// j的定义必须放在函数体外</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数体内</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *pp1 = &amp;j; <span class="comment">// 等价于 int constexpr *pp1 = &amp;j;</span></span><br><span class="line">cout &lt;&lt; *pp1 &lt;&lt; endl; <span class="comment">// 30</span></span><br><span class="line">*pp1 = <span class="number">40</span>;</span><br><span class="line">cout &lt;&lt; j &lt;&lt; endl; <span class="comment">// 40</span></span><br><span class="line">pp1 = <span class="literal">nullptr</span>; <span class="comment">// 错误, constexpr指针无法修改</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="修饰函数">修饰函数</h2>
<p>const 修饰成员函数，通常称为 const 函数，
表示该函数不会修改类的状态（即不会通过任何方式修改类数据成员）. 另外，
const 类对象，只能调用 const 函数，确保不会修改类的数据成员.</p>
<p>constexpr 无法修饰成员函数，只能作为函数返回值类型，
表明该函数返回的是一个编译期可确定的常量；constexpr
被隐式隐式指定为内联函数，只能在类的声明中定义（.h 文件）.</p>
<p>参见 <a href="https://blog.csdn.net/lihao21/article/details/8634876">C++ 的 const 类成员函数</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// A.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>():<span class="built_in">curSize</span>(<span class="number">10</span>) {}</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setSize</span><span class="params">(<span class="type">int</span> size)</span> </span>{ size++; }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// const函数</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> curSize; }  <span class="comment">// 正确示例：不写任何数据成员</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>{ curSize = <span class="number">2</span>; <span class="keyword">return</span> curSize; }; <span class="comment">// 错误示例： const函数不能修改任何类的数据成员</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="built_in">setSize</span>(); <span class="keyword">return</span> curSize; } <span class="comment">// 错误示例：const函数不能调用任何可能导致类的数据成员改变的函数, 也就是说, 如果调用自身成员函数, 只能调用const函数</span></span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>{ <span class="keyword">return</span> curSize; }  <span class="comment">// 函数返回值为const类型：函数体可以修改数据成员, 但返回类型是const, 也就是调用者无法修改</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数返回值为constexpr类型</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">getMaxSize</span><span class="params">()</span> </span>{ <span class="keyword">return</span> INT_MAX; } <span class="comment">// 正确示例：返回常量值</span></span><br><span class="line">  <span class="comment">// 错误示例：vec.size()运行时确定, 不能在编译期决定</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">getMaxSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> vec.<span class="built_in">size</span>();</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 正确：虽然看起来返回的是变量, 但编译器可确定</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">getMaxSize</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> curSize;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// A.cpp</span></span><br><span class="line"><span class="comment">// 错误示例：constexpr被隐式指定为内联函数, 只能在.h 类内定义, 不能在类实现文件(.cpp)中定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">A::getMaxsize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中 new-delete 与 malloc-free 的比较</title>
    <url>/posts/f8def853/</url>
    <content><![CDATA[<p>new-delete 与 malloc-free</p>
<span id="more"></span>
<h2 id="newdelete-与-mallocfree-的比较">new&amp;delete 与
malloc&amp;free 的比较</h2>
<ul>
<li><code>malloc/free</code> 是 C 语言的库函数</li>
<li><code>new/delete</code> <code>new[]/delete[]</code> 是 C++
中的运算符</li>
<li><code>malloc/free</code> 只是申请内存空间，释放空间</li>
<li><code>new/delete</code> 不仅会申请内存空间，
还会根据类型初始化内存空间，this 指针绑定，
调用构造函数和析构函数进行初始化或者清理等操作</li>
</ul>
<p>这里有两张网上找到的图</p>
<ol type="1">
<li><p><code>new/delete</code> 实现 <img data-src="/posts/f8def853/new_delete%E5%AE%9E%E7%8E%B0.png" class=""></p></li>
<li><p><code>new[]/delete[]</code> 实现</p>
<img data-src="/posts/f8def853/new_delete%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0.png" class=""></li>
</ol>
<p>不一定完全正确，但具有一定参考意义，<code>new[]</code> 文中说会多申请
4 字节 空间，在开始位置存储对象个数，这里我在 64 位 编译环境下验证了一下，
是前 8 字节 空间中存储的，应该与系统位数有关</p>
<p>测试环境: Win10 64 bit &amp; GCC 8.1.0 64 bit</p>
<p>这里定义一个 Test 类作测试</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="built_in">Test</span>()</span><br><span class="line">    {</span><br><span class="line">        x = ++index;</span><br><span class="line">        str = str + std::<span class="built_in">to_string</span>(x);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Test Constructor() this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Test Destructor() this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Test show x("</span> &lt;&lt; x &lt;&lt; <span class="string">"), str("</span> &lt;&lt; str &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string str {<span class="string">"sssaaa"</span>};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Test::index = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>测试:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">sizeof</span>(Test);</span><br><span class="line">    Test* p = <span class="keyword">new</span> Test[<span class="number">3</span>]();</span><br><span class="line">    <span class="type">uint64_t</span>* sp = (<span class="type">uint64_t</span>*)p - <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Test obj size: "</span> &lt;&lt; *sp &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出如下</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Test Constructor() this=0x1d1e88</span><br><span class="line">Test Constructor() this=0x1d1eb0</span><br><span class="line">Test Constructor() this=0x1d1ed8</span><br><span class="line">Test obj size: 3</span><br><span class="line">Test Destructor() this=0x1d1ed8</span><br><span class="line">Test Destructor() this=0x1d1eb0</span><br><span class="line">Test Destructor() this=0x1d1e88</span><br></pre></td></tr></tbody></table></figure>
<p>如果我们修改一下上面的测试代码，更改一下前面的对象个数</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">sizeof</span>(Test);</span><br><span class="line">    Test* p = <span class="keyword">new</span> Test[<span class="number">3</span>]();</span><br><span class="line">    <span class="type">uint64_t</span>* sp = (<span class="type">uint64_t</span>*)p - <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Test obj size: "</span> &lt;&lt; *sp &lt;&lt; std::endl;</span><br><span class="line">    *sp = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Test Constructor() this=0x6e1e88</span><br><span class="line">Test Constructor() this=0x6e1eb0</span><br><span class="line">Test Constructor() this=0x6e1ed8</span><br><span class="line">Test obj size: 3</span><br><span class="line">Test Destructor() this=0x6e1eb0</span><br><span class="line">Test Destructor() this=0x6e1e88</span><br></pre></td></tr></tbody></table></figure>
<p><code>delete[]</code> 只执行了两次析构</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中使用 fstream 一次读取整个文件内容</title>
    <url>/posts/3579021f/</url>
    <content><![CDATA[<p>原文地址 <a href="https://www.cnblogs.com/kex1n/p/4028428.html">https://www.cnblogs.com/kex1n/p/4028428.html</a></p>
<span id="more"></span>
<h2 id="读取到-char">读取到 char*</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">std::ifstream t; <span class="type">int</span> length; t.<span class="built_in">open</span>(<span class="string">"file.txt"</span>); <span class="comment">// open input file</span></span><br><span class="line">t.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::end); <span class="comment">// go to the end</span></span><br><span class="line">length = t.<span class="built_in">tellg</span>(); <span class="comment">// report location (this is the length)</span></span><br><span class="line">t.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::beg); <span class="comment">// go back to the beginning</span></span><br><span class="line">buffer = <span class="keyword">new</span> <span class="type">char</span>[length]; <span class="comment">// allocate memory for a buffer of appropriate dimension</span></span><br><span class="line">t.<span class="built_in">read</span>(buffer, length); <span class="comment">// read the whole file into the buffer</span></span><br><span class="line">t.<span class="built_in">close</span>(); <span class="comment">// close file handle</span></span><br><span class="line"><span class="comment">// ... do stuff with buffer here ...</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="读取到-stdstring">读取到 std::string</h2>
<p>方法一</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;streambuf&gt;</span></span></span><br><span class="line"><span class="function">std::ifstream <span class="title">t</span><span class="params">(<span class="string">"file.txt"</span>)</span></span>;</span><br><span class="line"><span class="function">std::string  <span class="title">str</span><span class="params">((std::istreambuf_iterator&lt;<span class="type">char</span>&gt;(t)), std::istreambuf_iterator&lt;<span class="type">char</span>&gt;())</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>方法二</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="function">std::ifstream  <span class="title">t</span><span class="params">(<span class="string">"file.txt"</span>)</span></span>;</span><br><span class="line">std::stringstream  buffer;</span><br><span class="line">buffer &lt;&lt; t.<span class="built_in">rdbuf</span>();</span><br><span class="line"><span class="function">std::string  <span class="title">contents</span><span class="params">(buffer.str())</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中使用智能指针管理数组</title>
    <url>/posts/21ebbed9/</url>
    <content><![CDATA[<p>C++ 智能指针不仅能管理普通对象，也可以管理数组对象</p>
<span id="more"></span>
<p>以前只知道使用智能指针管理对象</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;A&gt; <span class="title">pA</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line"><span class="comment">// do something with pA or pA.Get()</span></span><br><span class="line"><span class="comment">// 超过作用域后, pA自动释放资源</span></span><br></pre></td></tr></tbody></table></figure>
<p>智能指针也可以用于管理数组</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>[]&gt; pArr;</span><br><span class="line">pArr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]); <span class="comment">// pArr 管理10个大小的int数组</span></span><br><span class="line">pArr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">64</span>]); <span class="comment">// 替换pArr的管理数组, 原来的10大小的数组将被自动释放</span></span><br></pre></td></tr></tbody></table></figure>
<p>以上代码管理数组对象的 <code>reset</code> 方法在 C++17 之前不可用</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 特化 unique_ptr&lt;T[]&gt;的成员</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(U)</span> </span>= <span class="keyword">delete</span>;      <span class="comment">// C++17 前</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(U)</span> <span class="keyword">noexcept</span></span>;      <span class="comment">// C++17 起</span></span><br></pre></td></tr></tbody></table></figure>
<p>千万不要用普通的智能指针指向数组地址，否则可能内存泄漏！！</p>
<p><del><code>std::unique_ptr&lt;int&gt; p(new int[xx])</code></del>
错误用法！</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中只能通过引用和指针来实现多态</title>
    <url>/posts/25f4ac4c/</url>
    <content><![CDATA[<p>C++ 中只能通过引用和指针实现多态</p>
<span id="more"></span>
<h2 id="多态的正确用法">多态的正确用法</h2>
<p>C++ 中正确的多态使用方法只有两种:</p>
<ul>
<li>基类引用绑定子类对象</li>
<li>基类指针指向子类对象 </li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>{ <span class="built_in">printf</span>(<span class="string">"Base Show()\n"</span>); }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>{ <span class="built_in">printf</span>(<span class="string">"Test Show()\n"</span>); }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Test t;</span><br><span class="line"><span class="comment">// 引用实现多态</span></span><br><span class="line">Base&amp; r = t;</span><br><span class="line">r.<span class="built_in">Show</span>();        <span class="comment">// Test Show()</span></span><br><span class="line"><span class="comment">// 指针实现多态</span></span><br><span class="line">Base* p = &amp;t;</span><br><span class="line">p-&gt;<span class="built_in">Show</span>();    <span class="comment">// Test Show()</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="无法实现多态的错误用法">无法实现多态的错误用法</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Test t;</span><br><span class="line">((Base)t).<span class="built_in">Show</span>(); <span class="comment">// 错误用法, 无法实现多态 输出 Base Show()</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="不要用基类指针指向子类数组">不要用基类指针指向子类数组</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Base* p = <span class="keyword">new</span> Test[<span class="number">10</span>]; <span class="comment">// 错误用法！！！！</span></span><br><span class="line"><span class="comment">// 将导致未定义行为, 或者 Segmentation fault</span></span><br></pre></td></tr></tbody></table></figure>
<p>原因其实很简单，当 Base 和 Test 大小不一致的时候，p [1]
其实指向的并不是一个正确的对象起始地址，如果把 p [1]
起始地址当作虚表读取，就会导致内存错乱</p>
<p>虚表指针放在对象起始位置是 C++ 实现多态的核心所在</p>
<p>就像下面的代码，一看就明白</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>];</span><br><span class="line"><span class="comment">// p[1] 指向的并不是数组的第二个元素位置</span></span><br></pre></td></tr></tbody></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中的 move 和 forward</title>
    <url>/posts/be74f994/</url>
    <content><![CDATA[<p>std::move 和 std::forward 仅仅是进行类型转换的函数（实际上是函数模板）.
std::move 无条件的将其参数转换为右值，
而 std::forward 只在必要情况下进行这个转换，就是这样.</p>
<span id="more"></span>
<ol type="1">
<li>std::move 执行一个无条件的转化到右值。它本身并不移动任何东西；</li>
<li>std::forward 把其参数转换为右值，
仅仅在那个参数被绑定到一个右值时；</li>
<li>std::move 和 std::forward 在运行时（runtime）都不做任何事.</li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中的 sizeof 运算符</title>
    <url>/posts/45b8fd2a/</url>
    <content><![CDATA[<h2 id="sizeof---class类型">sizeof - class 类型</h2>
<ul>
<li>空的 class, 没有成员变量和成员函数，对该类型求 sizeof, 结果为 1</li>
<li> 空类型不包含任何信息，但是声明类型实例时，必须在内存中有一定内存，
占用内存大小由编译器决定，在 g++ 8.1 中占用 1 字节</li>
<li>如果在类中添加一些非虚函数，再求 sizeof, 结果还是 1</li>
<li> 调用类函数只需要知道函数地址就行了，而函数地址只与类型相关，
与实例无关</li>
<li>如果添加一个析构函数并标记为虚函数</li>
<li> C++ 类一旦有虚函数，编译器就会为该类型生成虚函数表，
并在每个该类型实例中添加一个指向虚函数表的指针，32 位机器上，
一个指针为 4 字节，所以 sizeof 结果为 4; 如果是 64 位机器，一个指针占用 8 字节，
则 sizeof 结果为 8</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中的 static 与 const</title>
    <url>/posts/c8e80444/</url>
    <content><![CDATA[<p>C++ 中的 CV 特性</p>
<span id="more"></span>
<h2 id="static">static</h2>
<ol type="1">
<li>static 修饰全局函数 / 全局变量，可以让原本具有全局作用域的函数 / 变量，
变成只在文件内有效</li>
<li> static 修饰局部变量，
改变局部变量的生命周期为整个程序运行周期 (作用域不变),
该变量只初始化一次，之后每次进入它的作用域都可以访问使用；
static 局部变量下次再访问还是上次保留的值</li>
<li> static 修饰类成员变量 / 成员函数，可以让变量 / 函数成为类成员，
而不是实例成员</li>
</ol>
<p>warning：不要再头文件中声明 static 的全局函数，
不要在 cpp 内声明非 static 的全局函数，如果你要在多个 cpp 中复用该函数，
就把它的声明提到头文件里去，否则 cpp 内部声明需加上 static 修饰；</p>
<h2 id="const">const</h2>
<ol type="1">
<li>修饰变量，阻止变量被修改，const 变量必须在声明时初始化，
否则后面无法初始化了</li>
<li>修饰指针，对于指针来说，既可以指定指针本身为 const (顶层 const),
让指针的值不能修改；也可以指定指针指向的值为 const 不能修改 (底层 const);
或者指定两者都是 const</li>
<li> 修饰形参，表示在函数内部不能修改输入参数的值</li>
<li> const 成员函数，表示函数内不会修改类的成员变量 (除了 mutable 成员)</li>
<li> 修饰返回值，表示函数的返回值不能被修改，不是左值</li>
</ol>
<p>注意第 4 点，const 成员函数不可以修改类的非 mutable 成员变量，
而且 const 成员函数与非 const 成员函数可以重载</p>
<p>const 的类对象只可以调用 const 的类成员函数</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dis</span><span class="params">()</span> </span>{ <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"dis"</span>); }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dis</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"const dis"</span>); }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>{ <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"test"</span>); }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    C c;</span><br><span class="line">    c.<span class="built_in">dis</span>();</span><br><span class="line">    <span class="type">const</span> C cc;</span><br><span class="line">    cc.<span class="built_in">dis</span>();</span><br><span class="line">    <span class="comment">// cc.test(); // 编译出错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 两个dis函数是重载函数! 并不会编译出错, 头一个对象是普通对象, 调用dis函数也是非const版本;</span></span><br><span class="line"><span class="comment">// 第二个cc对象是const对象, 它只能调用自己的const函数!!</span></span><br><span class="line"><span class="comment">// 程序输出:</span></span><br><span class="line"><span class="comment">// dis</span></span><br><span class="line"><span class="comment">// const dis</span></span><br></pre></td></tr></tbody></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中的声明与定义关键字</title>
    <url>/posts/45070312/</url>
    <content><![CDATA[<p>记录 C++ 中一些常见的声明与定义的关键字作用</p>
<span id="more"></span>
<h2 id="static-声明">static 声明</h2>
<p>static 修饰类成员时，表示成员仅属于类，不属于实例；</p>
<p>并且 static 修饰的类成员不能直接指定类内初始值，除非为 const;</p>
<p>而且必须在类外初始化，初始化时不能再次写 static</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// static int num = 0; // 报错</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> size = <span class="number">20</span>; <span class="comment">// 正确, 若类外再次初始化则重复定义</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">// 如果类外没有初始化, 则编译出错</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">// const int A::size = 20; // 不能重复定义, 类内初始值与类外初始化只能有一个</span></span><br><span class="line"><span class="type">int</span> A::count = <span class="number">30</span>; <span class="comment">// 类外初始化</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="inline-定义-声明">inline 定义 (声明)</h2>
<p>inline 只是给编译器的处理建议，编译器可以自行选择，
如果函数中出现 switch, 循环，递归，或者有函数指针对该函数的调用，
编译器会忽略 inline 建议</p>
<p>inline 函数在哪里声明就在哪里实现</p>
<p>inline 函数的声明和实现应该放在头文件中，
应该在函数实现的地方加上 inline; 对于声明的地方是否加上 inline,
貌似并没有影响</p>
<h2 id="virtual-声明">virtual 声明</h2>
<p>仅在函数声明时使用，函数定义时再加 virtual 会报错</p>
<p>当一个成员函数被声明为 virtual 之后，
其子类中相同签名的函数自动成为虚函数，即使子类没有显式写上 virtual,
不过为了阅读清晰，子类中也应该显式加上 virtual 声明</p>
<h2 id="const-声明-定义">const 声明 + 定义</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>上面两个成员函数可以同时存在，const 对象调用只能调用 const 的成员函数，
而非 const 对象在两种函数都存在时调用不带 const 的版本，
如果只有 const 版本也可以调用不会报错</p>
<p>所以函数后加 const 与不加 const 是两个不同函数，
声明和定义时都要表述清楚</p>
<h2 id="final-声明">final 声明</h2>
<p>C++ 11 新增关键字，用于阻止成员函数被重写，或者阻止类继承；</p>
<p>只能声明时使用，定义处使用报错</p>
<p>用在虚函数之后，表示在之后的子类中，不能重写该函数</p>
<p>用在类名之后，表示该类不可以被继承</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">final</span> {}; <span class="comment">// 表示A类不能被继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A {}; <span class="comment">// 编译报错</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>{} <span class="comment">// 从父类继承而来, 但不允许子类重写</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{} <span class="comment">// 编译报错, 不允许重写</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">special</span><span class="params">()</span> <span class="keyword">final</span> </span>{} <span class="comment">// 不允许子类重写</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="override-声明">override 声明</h2>
<p>C++ 11 新增关键字，用于子类中显式说明一个函数是重写父类函数，
编译器可以检查错误</p>
<p>只能声明时使用，定义处使用报错</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 如果没有override, 这段错误代码会编译通过</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sh0w</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// 报错, 没有sh0w函数可以重写, 让编译器检查错误</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="default-声明">default 声明</h2>
<p>C++ 11 新增，表示类的特殊函数使用默认实现</p>
<p>特殊函数:
默认构造函数、复制 / 移动构造函数、复制 / 移动赋值运算符和析构函数</p>
<p>默认构造函数是没有参数的</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()                         = <span class="keyword">default</span>; <span class="comment">// 默认构造</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a)               = <span class="keyword">default</span>; <span class="comment">// 复制构造</span></span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; a)                    = <span class="keyword">default</span>; <span class="comment">// 移动构造</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>()                = <span class="keyword">default</span>; <span class="comment">// 析构函数</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a)    = <span class="keyword">default</span>; <span class="comment">// 复制赋值 (默认实现为浅拷贝)</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(A&amp;&amp; a)         = <span class="keyword">default</span>; <span class="comment">// 移动赋值 (浅拷贝)</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="delete-声明">delete 声明</h2>
<p>C++ 11 新增 表示删除默认提供的特殊函数，禁止默认操作</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a) = <span class="keyword">delete</span>; <span class="comment">// 禁止复制构造</span></span><br><span class="line">};</span><br><span class="line">A a;</span><br><span class="line"><span class="comment">// A b(a); // 报错, 禁止</span></span><br><span class="line"><span class="comment">// A b = a; // 报错, 禁止</span></span><br><span class="line">A b;</span><br><span class="line">b = a; <span class="comment">// 调用了默认赋值函数, 没有delete, 允许; 浅复制</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="explicit-声明">explicit 声明</h2>
<p>仅声明，函数外写会报错</p>
<p>表示构造函数必须显式调用，而不能隐式转换</p>
<p>C++ 中的 explicit 关键字只能用于修饰只有一个参数的类构造函数 (或者除了第一个参数外，
其它参数有默认值的构造) C++11 后已经可以修饰任意参数的构造函数，
它的作用是表明该构造函数是显示的，而非隐式的，
跟它相对应的另一个关键字是 implicit,
意思是隐藏的，类构造函数默认情况下即声明为 implicit (隐式)</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i) {}</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i, <span class="type">int</span> j) {}</span><br><span class="line">};</span><br><span class="line">A a = <span class="number">30</span>; <span class="comment">// 正确, 隐式调用构造函数, 自动隐式转换</span></span><br><span class="line">A b = {<span class="number">1</span>, <span class="number">2</span>}; <span class="comment">// 正确, 复制列表初始化</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> i)</span> </span>{} <span class="comment">// 显式构造函数, 不能隐式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>{}</span><br><span class="line">}</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">30</span>)</span></span>; <span class="comment">// 显式调用, 正确</span></span><br><span class="line"><span class="comment">// A a = 30; // 隐式调用, 错误</span></span><br><span class="line"><span class="comment">// A a = {2, 3}; // 隐式调用, 错误</span></span><br></pre></td></tr></tbody></table></figure>
<p>详情: <a href="/posts/de05b48b/" title="C++中的explicit关键字">C++ 中的 explicit 关键字</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 内存复用_内存池_allocator</title>
    <url>/posts/8fc5d182/</url>
    <content><![CDATA[<p>最近几天写一些服务端的基础小工具学习到不少内容，
特别是内存管理这块</p>
<p>这里记录一下，C++ 中的内存复用</p>
<span id="more"></span>
<h2 id="newdelete-的局限性">new/delete 的局限性</h2>
<p>写 C++ 的孩子都知道 C++ 中使用动态内存 (堆内存), 一般使用 new 和
delete 这对关键字</p>
<p>与 malloc/free 不同，new 申请内存后还会初始化内存空间，调用构造函数；
delete 会先调用析构函数，之后释放内存</p>
<p>一般我们都是需要对象的时候 new 一个，用完后 delete 掉，
但是如果一种类型的对象会很频繁的被使用到，就会有大量的 new/delete
操作</p>
<p>new 操作符内部一般用 malloc 实现，malloc
向系统申请内存空间会有系统调用，如果很频繁的 new/delete
会导致用户态和内核态切换较多，浪费性能，而且容易产生大量内存碎片</p>
<p>对于需要频繁使用的类对象，如果能重用一片内存区域，
就不会有上述问题</p>
<h2 id="stdallocator-的使用-c11"><code>std::allocator</code> 的使用
(C++11)</h2>
<p>C++ 11 提供了 <code>std::allocator</code> 类模板，
它是所有标准库容器的默认分配器，默认分配器无状态，即任何给定的 allocator
实例可交换，比较像等，且能解分配同一 allocator
类型的任何其他实例所分配的内存</p>
<p>上面的介绍来自 cppreference 文档 std::allocator - <a href="http://cppreference.com">cppreference.com</a></p>
<p>不理解也无所谓，只用知道它最大的作用就是
<strong>可以将内存的申请和类对象初始化，
还有类对象析构和内存释放拆分开</strong></p>
<p>也就是说，使用 allocator 可以申请一个对象的内存空间之后，
可以在这片相同的内存上多次构造 / 析构不同的对象，也就是内存重用</p>
<p>测试类</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="built_in">Test</span>()</span><br><span class="line">    {</span><br><span class="line">        x = ++index;</span><br><span class="line">        str = str + std::<span class="built_in">to_string</span>(x);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Test Constructor() this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Test Destructor() this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Test show x("</span> &lt;&lt; x &lt;&lt; <span class="string">"), str("</span> &lt;&lt; str &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string str {<span class="string">"sssaaa"</span>};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Test::index = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>测试代码</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::allocator&lt;Test&gt; alloc;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"allocate ------------ \n"</span>);</span><br><span class="line">    Test* p = alloc.<span class="built_in">allocate</span>(<span class="number">1</span>); <span class="comment">// 申请内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"construct ----------- \n"</span>);</span><br><span class="line">    alloc.<span class="built_in">construct</span>(p); <span class="comment">// 构造对象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"use object ------------ \n"</span>);</span><br><span class="line">    p-&gt;<span class="built_in">Show</span>(); <span class="comment">// 使用对象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"destruct ------------ \n"</span>);</span><br><span class="line">    alloc.<span class="built_in">destroy</span>(p); <span class="comment">// 销毁对象</span></span><br><span class="line">    <span class="comment">// 同一片内存的再次使用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"construct ----------- \n"</span>);</span><br><span class="line">    alloc.<span class="built_in">construct</span>(p); <span class="comment">// 构造对象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"use object ------------ \n"</span>);</span><br><span class="line">    p-&gt;<span class="built_in">Show</span>(); <span class="comment">// 使用对象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"destruct ------------ \n"</span>);</span><br><span class="line">    alloc.<span class="built_in">destroy</span>(p); <span class="comment">// 销毁对象</span></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"deallocate ------------ \n"</span>);</span><br><span class="line">    alloc.<span class="built_in">deallocate</span>(p, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">allocate ------------</span><br><span class="line">construct -----------</span><br><span class="line">Test Constructor() this=0x1d1a50</span><br><span class="line">use object ------------</span><br><span class="line">Test show x(1), str(sssaaa1)</span><br><span class="line">destruct ------------</span><br><span class="line">Test Destructor() this=0x1d1a50</span><br><span class="line">construct -----------</span><br><span class="line">Test Constructor() this=0x1d1a50</span><br><span class="line">use object ------------</span><br><span class="line">Test show x(2), str(sssaaa2)</span><br><span class="line">destruct ------------</span><br><span class="line">Test Destructor() this=0x1d1a50</span><br><span class="line">deallocate ------------</span><br></pre></td></tr></tbody></table></figure>
<p>其中内存的申请 / 释放使用 <code>malloc</code> 和 <code>free</code>
效果也一样</p>
<h2 id="stdallocator_traits-的使用-c11-c17-c20"><code>std::allocator_traits</code>
的使用 (C++11, C++17, C++20)</h2>
<p>在 C++17 中，<code>std::allocator</code> 类模板的
<code>construct</code> <code>destroy</code> 等方法被标记为弃用，到 C++20
这些方法直接被移除了，所以上面直接使用 <code>std::allocator</code>
的源码在 C++20 中是无法使用的</p>
<p>标准库中提供了一个 <code>std::allocator_traits</code>
类模板提供几个静态方法，用于标准化使用 <code>std::allocator</code></p>
<p>其实就是套个壳，不允许直接使用</p>
<p>将测试代码改成如下形式，则可以在 C++20 中正常使用</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::allocator&lt;Test&gt; alloc;</span><br><span class="line">    std::allocator_traits&lt;std::allocator&lt;Test&gt;&gt; traits;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"allocate ------------ \n"</span>);</span><br><span class="line">    Test* p = traits.<span class="built_in">allocate</span>(alloc, <span class="number">1</span>); <span class="comment">// 申请内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"construct ----------- \n"</span>);</span><br><span class="line">    traits.<span class="built_in">construct</span>(alloc, p); <span class="comment">// 构造对象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"use object ------------ \n"</span>);</span><br><span class="line">    p-&gt;<span class="built_in">Show</span>(); <span class="comment">// 使用对象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"destruct ------------ \n"</span>);</span><br><span class="line">    traits.<span class="built_in">destroy</span>(alloc, p); <span class="comment">// 销毁对象</span></span><br><span class="line">    <span class="comment">// 同一片内存的再次使用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"construct ----------- \n"</span>);</span><br><span class="line">    traits.<span class="built_in">construct</span>(alloc, p); <span class="comment">// 构造对象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"use object ------------ \n"</span>);</span><br><span class="line">    p-&gt;<span class="built_in">Show</span>(); <span class="comment">// 使用对象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"destruct ------------ \n"</span>);</span><br><span class="line">    traits.<span class="built_in">destroy</span>(alloc, p); <span class="comment">// 销毁对象</span></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"deallocate ------------ \n"</span>);</span><br><span class="line">    traits.<span class="built_in">deallocate</span>(alloc, p, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="内存池">内存池</h2>
<p>头文件</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _OBJECT_POOL_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OBJECT_POOL_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IRecyclable</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">Type</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUse</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnRecycle</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectAlloctor</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::function&lt;IRecyclable*()&gt; m_allocate;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(IRecyclable*)&gt; m_construct;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(IRecyclable*)&gt; m_destroy;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(IRecyclable*)&gt; m_deallocate;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectPool</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> ObjectPool Instance;</span><br><span class="line">    ~<span class="built_in">ObjectPool</span>() { <span class="built_in">ClearAll</span>(); }</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">SetType</span><span class="params">(<span class="type">const</span> std::string&amp; type, Args &amp;&amp;... args)</span></span>;</span><br><span class="line">    <span class="function">IRecyclable* <span class="title">GetObj</span><span class="params">(<span class="type">const</span> std::string&amp; type)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReturnObj</span><span class="params">(IRecyclable* obj)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearAll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">IRecyclable* <span class="title">CreateObj</span><span class="params">(<span class="type">const</span> std::string&amp; type)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, std::list&lt;IRecyclable*&gt;&gt; m_mapObjs;</span><br><span class="line">    std::unordered_map&lt;std::string, ObjectAlloctor&gt; m_mapAlloc;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ObjectPool</span>() {};</span><br><span class="line">    <span class="built_in">ObjectPool</span>(ObjectPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">ObjectPool</span>(ObjectPool&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">const</span> ObjectPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ObjectPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">const</span> ObjectPool&amp; <span class="keyword">operator</span>=(ObjectPool&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectPool::SetType</span><span class="params">(<span class="type">const</span> std::string&amp; type, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    m_mapAlloc[type].m_allocate = [] {</span><br><span class="line">        <span class="built_in">return</span> (IRecyclable*)(std::<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T)));</span><br><span class="line">    };</span><br><span class="line">    <span class="comment">// 这里需要注意, 闭包函数的参数都是引用传递, 如果是临时变量需要用值传递或者特殊处理一下 比如在函数内再申明变量保存一下参数</span></span><br><span class="line">    m_mapAlloc[type].m_construct = [&amp;args...](IRecyclable* p) {</span><br><span class="line">        std::allocator&lt;T&gt; alloc;</span><br><span class="line">        std::allocator_traits&lt;std::allocator&lt;T&gt;&gt; traits;</span><br><span class="line">        traits.<span class="built_in">construct</span>(alloc, <span class="built_in">static_cast</span>&lt;T*&gt;(p), std::<span class="built_in">move</span>(args)...);</span><br><span class="line">    };</span><br><span class="line">    m_mapAlloc[type].m_destroy = [](IRecyclable* p) {</span><br><span class="line">        std::allocator&lt;T&gt; alloc;</span><br><span class="line">        std::allocator_traits&lt;std::allocator&lt;T&gt;&gt; traits;</span><br><span class="line">        traits.<span class="built_in">destroy</span>(alloc, <span class="built_in">static_cast</span>&lt;T*&gt;(p));</span><br><span class="line">    };</span><br><span class="line">    m_mapAlloc[type].m_deallocate = [](IRecyclable* p) {</span><br><span class="line">        std::<span class="built_in">free</span>(p);</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>注意: <strong>C++ 中不支持模板的分离编译</strong> ,
模板的实现都写在头文件中</p>
<p>源文件</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ObjectPool.h"</span></span></span><br><span class="line"></span><br><span class="line">ObjectPool ObjectPool::Instance;</span><br><span class="line"></span><br><span class="line"><span class="function">IRecyclable* <span class="title">ObjectPool::GetObj</span><span class="params">(<span class="type">const</span> std::string&amp; type)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    IRecyclable* obj = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> objIt = m_mapObjs.<span class="built_in">find</span>(type);</span><br><span class="line">    <span class="keyword">if</span> (objIt != m_mapObjs.<span class="built_in">end</span>() &amp;&amp; objIt-&gt;second.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        obj = objIt-&gt;second.<span class="built_in">front</span>();</span><br><span class="line">        objIt-&gt;second.<span class="built_in">pop_front</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        obj = <span class="built_in">CreateObj</span>(type);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">auto</span> allocIt = m_mapAlloc.<span class="built_in">find</span>(type);</span><br><span class="line">    <span class="keyword">if</span> (allocIt == m_mapAlloc.<span class="built_in">end</span>()) { <span class="keyword">throw</span> <span class="string">"somethings wrong"</span>; }</span><br><span class="line">    allocIt-&gt;second.<span class="built_in">m_construct</span>(obj);</span><br><span class="line">    obj-&gt;<span class="built_in">OnUse</span>();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">IRecyclable* <span class="title">ObjectPool::CreateObj</span><span class="params">(<span class="type">const</span> std::string&amp; type)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    IRecyclable* obj = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> allocIt = m_mapAlloc.<span class="built_in">find</span>(type);</span><br><span class="line">    <span class="keyword">if</span> (allocIt == m_mapAlloc.<span class="built_in">end</span>()) { <span class="keyword">throw</span> <span class="string">"somethings wrong"</span>; }</span><br><span class="line">    obj = allocIt-&gt;second.<span class="built_in">m_allocate</span>();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectPool::ReturnObj</span><span class="params">(IRecyclable* obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">nullptr</span>) { <span class="keyword">return</span>; }</span><br><span class="line">    std::string type = obj-&gt;<span class="built_in">Type</span>();</span><br><span class="line">    <span class="keyword">auto</span> it = m_mapAlloc.<span class="built_in">find</span>(type);</span><br><span class="line">    <span class="keyword">if</span> (it == m_mapAlloc.<span class="built_in">end</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"try to return obj that it's type not setted"</span>;</span><br><span class="line">    }</span><br><span class="line">    obj-&gt;<span class="built_in">OnRecycle</span>();</span><br><span class="line">    it-&gt;second.<span class="built_in">m_destroy</span>(obj);</span><br><span class="line">    m_mapObjs[type].<span class="built_in">push_back</span>(obj);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectPool::ClearAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = m_mapObjs.<span class="built_in">begin</span>(); it != m_mapObjs.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> allocIt = m_mapAlloc.<span class="built_in">find</span>(it-&gt;first);</span><br><span class="line">        <span class="keyword">if</span> (allocIt == m_mapAlloc.<span class="built_in">end</span>()) { <span class="keyword">throw</span> <span class="string">"somethings wrong"</span>; }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> lstit = it-&gt;second.<span class="built_in">begin</span>(); lstit != it-&gt;second.<span class="built_in">end</span>(); ++lstit)</span><br><span class="line">        {</span><br><span class="line">            allocIt-&gt;second.<span class="built_in">m_deallocate</span>(*lstit);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    m_mapObjs.<span class="built_in">clear</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>测试</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> IRecyclable</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">Type</span><span class="params">()</span> <span class="keyword">override</span> </span>{ <span class="keyword">return</span> <span class="string">"test"</span>; }</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUse</span><span class="params">()</span> <span class="keyword">override</span> </span>{ std::cout &lt;&lt; <span class="string">"OnUse this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl; }</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnRecycle</span><span class="params">()</span> <span class="keyword">override</span> </span>{ std::cout &lt;&lt; <span class="string">"OnRecycle this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl; }</span><br><span class="line">    <span class="built_in">Test</span>()</span><br><span class="line">    {</span><br><span class="line">        x = ++index;</span><br><span class="line">        str = str + std::<span class="built_in">to_string</span>(x);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Test Constructor() this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Test Destructor() this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Test show x("</span> &lt;&lt; x &lt;&lt; <span class="string">"), str("</span> &lt;&lt; str &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string str {<span class="string">"sssaaa"</span>};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Test::index = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ObjectPool::Instance.<span class="built_in">SetType</span>&lt;Test&gt;(std::<span class="built_in">string</span>(<span class="string">"test"</span>));</span><br><span class="line">    Test* t1 = (Test*)ObjectPool::Instance.<span class="built_in">GetObj</span>(<span class="string">"test"</span>);</span><br><span class="line">    Test* t2 = (Test*)ObjectPool::Instance.<span class="built_in">GetObj</span>(<span class="string">"test"</span>);</span><br><span class="line">    t1-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    t2-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    ObjectPool::Instance.<span class="built_in">ReturnObj</span>((IRecyclable*)t1);</span><br><span class="line">    Test* t3 = (Test*)ObjectPool::Instance.<span class="built_in">GetObj</span>(<span class="string">"test"</span>);</span><br><span class="line">    t3-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    ObjectPool::Instance.<span class="built_in">ReturnObj</span>((IRecyclable*)t2);</span><br><span class="line">    ObjectPool::Instance.<span class="built_in">ReturnObj</span>((IRecyclable*)t3);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>测试结果:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Test Constructor() this=0x8037fe0</span><br><span class="line">OnUse this=0x8037fe0</span><br><span class="line">Test Constructor() this=0x8038430</span><br><span class="line">OnUse this=0x8038430</span><br><span class="line">Test show x(1), str(sssaaa1)</span><br><span class="line">Test show x(2), str(sssaaa2)</span><br><span class="line">OnRecycle this=0x8037fe0</span><br><span class="line">Test Destructor() this=0x8037fe0</span><br><span class="line">Test Constructor() this=0x8037fe0</span><br><span class="line">OnUse this=0x8037fe0</span><br><span class="line">Test show x(3), str(sssaaa3)</span><br><span class="line">OnRecycle this=0x8038430</span><br><span class="line">Test Destructor() this=0x8038430</span><br><span class="line">OnRecycle this=0x8037fe0</span><br><span class="line">Test Destructor() this=0x8037fe0</span><br></pre></td></tr></tbody></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 构造函数与析构函数</title>
    <url>/posts/50b0fa36/</url>
    <content><![CDATA[<p>C++ 中构造函数与析构函数一些注意事项</p>
<span id="more"></span>
<h2 id="构造函数中不能调用虚函数">构造函数中不能调用虚函数</h2>
<p>在 C++ 中，实例化一个子类对象的时候，会先构造父类部分，
父类部分构造完成后再构造子类部分</p>
<p>因此，<strong>在父类构造函数调用的时候，子类部分数据还未构造完成，
此时调用子类方法本身就是未定义行为</strong> , 所以 C++
中构造函数中调用虚函数并不会表现出多态特征</p>
<h2 id="为什么析构函数需要定义为虚函数">为什么析构函数需要定义为虚函数</h2>
<p>一个常见的面试问题：为什么 C++ 中的析构函数需要定义为虚函数？</p>
<p>通常 C++ 析构一个对象时，会依次调用对象的析构函数和它父类的析构函数，
但是在多态发生时，可能会漏调用对象本身的析构函数</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">A</span>() { <span class="built_in">printf</span>(<span class="string">"~A()\n"</span>); }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">B</span>() { <span class="built_in">printf</span>(<span class="string">"~B()\n"</span>); }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    A* ptr = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>以上代码是析构函数不使用虚函数的错误写法，
我们在释放父类指针所指向的对象时，
希望析构函数调用是先 <code>~B()</code> 再 <code>~A()</code>,
但以上代码只会调用 <code>~A()</code> 而对象本身属于类 B 的部分不会调用析构函数释放，
发生内存泄漏</p>
<p>如果将析构函数写成虚函数，
那么释放父类指针指向的对象时会根据多态原理调用正确的子类析构函数</p>
<h2 id="析构函数中不能调用虚函数">析构函数中不能调用虚函数</h2>
<p>同理，我们将析构函数写成虚函数，
为了析构函数能从子类到父类一层层释放资源，
所以<strong>当父类的析构函数被调用时，子类的数据已经被析构，
此时调用子类的方法也是未定义行为</strong> , 所以 C++
析构函数中调用虚函数也不会表现出多态</p>
<p>至于是不是虚表指针没有初始化，
还是编译器在构造函数和虚构函数中更改了虚表指针的值，这都不重要，
反正记住编译器的实现是不表现出多态特征</p>
<p>总结:</p>
<ul>
<li>C++ 父类构造函数调用时，子类并未构造完成</li>
<li> C++ 父类析构函数调用时，子类已经析构</li>
<li> C++ 编译器实现：在构造函数和析构函数中调用虚函数并没有多态特性</li>
</ul>
<p><strong>不要在构造函数和析构函数中调用虚函数</strong></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 数组长度可以为变量吗</title>
    <url>/posts/7a9ccc43/</url>
    <content><![CDATA[<p>转载：原创程序喵大人 程序喵大人 (微信公众号) (收录于话题:
C++ 精进之路)</p>
<p>推荐一下这个专题，讲 C++ 很棒</p>
<span id="more"></span>
<h2 id="c数组长度可以为变量吗">C++ 数组长度可以为变量吗？</h2>
<p>37 个</p>
<p>大家好，我是喵大人，今天跟大家分享的是关于 C++ 数组提出几点问题：</p>
<h3 id="预备">预备</h3>
<p>先看下这两段代码，并思考如下问题.</p>
<p>1、变量作为数组的长度可行吗？</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> num)</span> </span>{</span><br><span class="line">    <span class="type">int</span> array[num]; <span class="comment">// num &gt; 0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"num "</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"sizeof array "</span> &lt;&lt; <span class="built_in">sizeof</span>(array) &lt;&lt; endl;</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"array[0] "</span> &lt;&lt; array[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">num <span class="number">6</span></span><br><span class="line"><span class="keyword">sizeof</span> array <span class="number">24</span></span><br><span class="line">array[<span class="number">0</span>] <span class="number">20</span></span><br></pre></td></tr></tbody></table></figure>
<p>2、访问超过长度的数组下标的值会发生什么？</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> array[<span class="number">10</span>];</span><br><span class="line">    array[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    array[<span class="number">20</span>] = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"sizeof array "</span> &lt;&lt; <span class="built_in">sizeof</span>(array) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"array[3] "</span> &lt;&lt; array[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"array[20] "</span> &lt;&lt; array[<span class="number">20</span>] &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> array <span class="number">40</span></span><br><span class="line">array[<span class="number">3</span>] <span class="number">1</span></span><br><span class="line">array[<span class="number">20</span>] <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="分析">分析</h3>
<p><strong>首先分析问题 1</strong>,
我们平时看书学习过程中总看见说 C++ 的数组长度一定要是常量且不能是变量，
很多资料需要在编译期确定栈帧的大小，
如果是变量就不能在编译器确定栈帧大小，
但上述代码为什么可以正常运行呢？光看不如实践，先看这样一段代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func2a address "</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func2b address "</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func2c address "</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// func1();</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> num)</span> </span>{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func3a address "</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func3b address "</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func3c address "</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func2</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">(<span class="type">int</span> num)</span> </span>{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func4a address "</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func4b address "</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func4c address "</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func3</span>(num);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">func4</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">func4a address <span class="number">0x7ffeb675f418</span></span><br><span class="line">func4b address <span class="number">0x7ffeb675f420</span></span><br><span class="line">func4c address <span class="number">0x7ffeb675f41c</span></span><br><span class="line">func3a address <span class="number">0x7ffeb675f3c8</span></span><br><span class="line">func3b address <span class="number">0x7ffeb675f3d0</span></span><br><span class="line">func3c address <span class="number">0x7ffeb675f3cc</span></span><br><span class="line">func2a address <span class="number">0x7ffeb675f378</span></span><br><span class="line">func2b address <span class="number">0x7ffeb675f380</span></span><br><span class="line">func2c address <span class="number">0x7ffeb675f37c</span></span><br></pre></td></tr></tbody></table></figure>
<p>再看这段代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func2a address "</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func2b address "</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func2c address "</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// func1();</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> num)</span> </span>{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b[num];</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func3a address "</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func3b address "</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func3c address "</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func2</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">(<span class="type">int</span> num)</span> </span>{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func4a address "</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func4b address "</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"func4c address "</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func3</span>(num);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">func4</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">func4a address <span class="number">0x7ffff2c76568</span></span><br><span class="line">func4b address <span class="number">0x7ffff2c76570</span></span><br><span class="line">func4c address <span class="number">0x7ffff2c7656c</span></span><br><span class="line">func3a address <span class="number">0x7ffff2c76510</span></span><br><span class="line">func3b address <span class="number">0x7ffff2c76360</span></span><br><span class="line">func3c address <span class="number">0x7ffff2c76514</span></span><br><span class="line">func2a address <span class="number">0x7ffff2c76328</span></span><br><span class="line">func2b address <span class="number">0x7ffff2c76330</span></span><br><span class="line">func2c address <span class="number">0x7ffff2c7632c</span></span><br></pre></td></tr></tbody></table></figure>
<p>func4a - func3a = 88</p>
<p>func3a - func2a = 488</p>
<p>从上面两段代码其实可以看出 C++ 是支持变量长度的数组的，
说不支持的那是很古老的编译器，在如下链接中也可以找到答案.</p>
<p><a href="https://c-for-dummies.com/blog/?p=3488">https://c-for-dummies.com/blog/?p=3488</a></p>
<p><a href="https://www.drdobbs.com/the-new-cwhy-variable-length-arrays/184401444">https://www.drdobbs.com/the-new-cwhy-variable-length-arrays/184401444</a></p>
<p><a href="https://stackoverflow.com/questions/1887097/why-arent-variable-length-arrays-part-of-the-c-standard">https://stackoverflow.com/questions/1887097/why-arent-variable-length-arrays-part-of-the-c-standard</a></p>
<p>备注：尽管 C++ 目前支持变量长度的数组，但是不建议使用，
因为数组使用的是栈内存，栈内存是有大小限制的，一般是 8192 字节，
既然长度是变量，那就可能是任何值，就有可能超过 8192, 这样就会 stack
overflow, 所以动态内存最好使用堆内存.</p>
<p><strong>再分析问题 2：操作超过数组长度的内存会发生什么？</strong></p>
<p>看下面这段代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> array[<span class="number">10</span>];</span><br><span class="line">    array[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    array[<span class="number">40</span>] = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"sizeof array "</span> &lt;&lt; <span class="built_in">sizeof</span>(array) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"array[3] "</span> &lt;&lt; array[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"array[40] "</span> &lt;&lt; array[<span class="number">40</span>] &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> a[<span class="number">200</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; ++i) {</span><br><span class="line">        a[i] = <span class="number">100</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; ++i) {</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">"====================="</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"====================="</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; ++i) {</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">"====================="</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">root@<span class="number">3</span>eaa9392a3d9:/ubuntu/test_dir# ./a.out</span><br><span class="line"><span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span></span><br><span class="line">=====================</span><br><span class="line"><span class="keyword">sizeof</span> array <span class="number">40</span></span><br><span class="line">array[<span class="number">3</span>] <span class="number">1</span></span><br><span class="line">array[<span class="number">40</span>] <span class="number">3</span></span><br><span class="line">=====================</span><br><span class="line"><span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">3</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span></span><br><span class="line">=====================</span><br></pre></td></tr></tbody></table></figure>
<p>看代码输出，在函数内操作超过数组长度的内存没有什么影响，
但是它却导致了上一级的数组 a [200] 里的内容被改变，因为数组使用的是栈内存，
经过问题 1 的代码输出以及分析可以看出，栈帧内存是向下增长的，
代码中操作了超过数组长度的内存地址，就影响到了之前栈帧的内存数据，
导致之前栈内存数据出现错误，可能就会引发大 bug.</p>
<blockquote>
<p><strong>总结</strong></p>
</blockquote>
<p><strong>summary</strong></p>
<p>C++ 中数组长度可以是变量，但是不建议使用，因为数组使用的是栈内存，
变量可以是个比较大的数，这样会导致 stack overflow, 建议使用堆内存.</p>
<p>操作超过数组长度的内存可以编译通过且表面上看不出来问题，
但是会导致栈内存出现脏写，最终可能会引发难以排查的 bug,
建议数组使用 std::array,
操作超过长度的下标会抛异常有利于开发者及时发现错误.</p>
<p>▼</p>
<p>更多精彩推荐，请关注我们</p>
<p>▼</p>
<p><strong>代码精进之路 </strong></p>
<p>代码精进之路，我们一起成长！</p>
<p><img src="https://secure2.wostatic.cn/static/wtedawzen2SaSyA4ZQ87yB/image.png"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 模板中 typename 与 class 关键字区别</title>
    <url>/posts/81765baa/</url>
    <content><![CDATA[<p>两种方式都可以在模板中使用，但是它们有什么区别呢</p>
<span id="more"></span>
<p>我们都知道，在 STL 中基本上都使用了模板类的声明，即 template.
在模板类的声明中，我们有两种方式：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">template &lt;typename T&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>在这里，class 和 typename 是相同的。也就是说，在声明一个 template
type parameter (模板类型参数) 的时候，class 和 typename 意味着</p>
<p>完全相同的东西.</p>
<p>但是，在 C++ 中，有的时候必须要使用 typename.
下面我们列举下面一个例子.</p>
<p>关键字 typename 被用来作为型别之前的标识符号.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">class MyClass{</span><br><span class="line">    typename T::SubType * ptr;</span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>在这里，typename 指出 SubType 是 class T 中定义的一个类别，因此 ptr
是一个指向 T::SubType 型别的指针。如果没有关键字 typename, SubType
会被当成一个 static 成员，于是</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">T::SubType * ptr</span><br></pre></td></tr></tbody></table></figure>
<p>会被解释为型别 T 内的数值 SubType 与 ptr 的乘积.</p>
<p>SubType 成为一个型别的条件是，任何一个用来取代 T 的型别，
其内部必须有一个内部型别 (inner type) SubType 的定义。例如，将型别 Q 当作
template 的参数.</p>
<p>MyClass x;</p>
<p>必要条件是型别 Q 有如下的内部型别定义：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class Q{</span><br><span class="line">    typedef int SubType;</span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>因此，MyClass 的 ptr 成员应该变成一个指向 int 型别的指针，子型别
SubType 也可以成为抽象</p>
<p>数据型别（例如，class）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class Q{</span><br><span class="line">    class SubType;</span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>注意，如果要把一个 template 中的某个标识符号指定为一种类别，
就算是意图显而易见，关键字 typename 也是不能省略的，因此 <strong>C++
的一般规则是，除了使用 typename 修饰之外，template
内的任何标识符号都被视为一个值而不是一个类别 (对象). </strong></p>
<p><strong>总结：</strong></p>
<ol type="1">
<li>template<typename t=""> 与 template<class t=""> 一般情况下这两个通用，
但有一个特例，就是当 T 是一个类，而这个类又有子类 (假设名为 innerClass)
时，应该用 template<typename>:</typename></class></typename></li>
<li>typename T::innerClass myInnerObject; 这里的 typename 告诉编译器，
T::innerClass 是一个类，程序要声明一个 T::innerClass 类的对象，
而不是声明 T 的静态成员，而 typename 如果换成 class 则语法错误.</li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 的数组不支持多态吗</title>
    <url>/posts/72dbce7b/</url>
    <content><![CDATA[<p>网上好像有人因为这个吵起来了，转载围观一下</p>
<span id="more"></span>
<p>转载</p>
<p>“C++ 的数组不支持多态”？</p>
<p>2013 年 04 月 29 日 陈皓 评论 177 条评论 59,678 人阅读</p>
<p>先是在微博上看到了个微博和云风的评论，
然后我回了 “楼主对 C 的内存管理不了解”.</p>
<p>后来引发了很多人的讨论，大量的人又借机来黑 C++, 比如：</p>
<p>//<span class="citation" data-cites="Baidu-ThursdayWang:这不就c">@Baidu-ThursdayWang: 这不就 c</span>++ 弱爆了的地方吗，
需要记忆太多东西</p>
<p>//<span class="citation" data-cites="编程浪子张发财:这个跟C关系真不大">@编程浪子张发财：这个跟 C 关系真不大</span>.
不过我得验证一下，感觉真的不应该是这样的。如果基类的析构这种情况不能
调用，就太弱了.</p>
<p>//<span class="citation" data-cites="程序元">@程序元</span>：现在看来，
当初由于毅力不够而没有深入纠缠 c++ 语言特性的各种犄角旮旯的坑爹细枝末节，
实是幸事。为现在还沉浸于这些诡异特性并乐此不疲的同志们感到忧伤.</p>
<p>然后，也出现了一些乱七八糟的理解：</p>
<p>//<span class="citation" data-cites="BA5BO">@BA5BO</span>:
数组是基于拷贝的，而多态是基于指针的，
派生类赋值给基类数组只是拷贝复制了一个基类新对象，
当然不需要派生类析构函数</p>
<p>//<span class="citation" data-cites="编程浪子张发财:我突然理解是怎么回事了">@编程浪子张发财：我突然理解是怎么回事了</span> ,
这种情况下数组中各元素都是等长结构体，类型必须一致，的确没法多态.
这跟 C# 和 java 不同。后两者对于引用类型存放的是对象指针.</p>
<p>等等，看来我必需要写一篇博客以正视听了.</p>
<p>因为没有看到上下文，我就猜测讨论的可能会是下面这两种情况之一：</p>
<ol type="1">
<li>一个 Base*[] 的指针数组中，存放了一堆派生类的指针，这样，你 delete []
pBase; 只是把指针数组给删除了，并没有删除指针所指向的对象.
这个是最基础的 C 的问题。你先得 for 这个指针数组，把数据里的对象都 delete 掉，
然后再删除数组。很明显，这和 C++ 没有什么关系.</li>
</ol>
<p>2）第二种可能是：Base *pBase = new Derived [n] 这样的情况。这种情况下，
delete [] pBase 明显不会调用虚析构函数（当然，这并不一定，我后面会说） ,
这就是上面云风回的微博。对此，我觉得如果是这个样子，
这个程序员完全没有搞懂 C 语言中的指针和数组是怎么一回事，也没有搞清楚，
什么是对象，什么是对象的指针和引用，这完全就是 C 语言没有学好.</p>
<p>后来，在看到了 <span class="citation" data-cites="GeniusVczh">@GeniusVczh</span> 的原文
《如何设计一门语言（一）—— 什么是坑 (a)》最后时，才知道了说的是第二种情况.
也就是下面的这个示例（我加了虚的析构函数这样方便编译）：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">B</span>(){ cout &lt;&lt;<span class="string">"B::~B()"</span>&lt;&lt;endl; }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">D</span>() { cout &lt;&lt;<span class="string">"D::D~()"</span>&lt;&lt;endl; }</span><br><span class="line">};</span><br><span class="line">Base* pBase = <span class="keyword">new</span> Derived[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] pBase;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>C 语言补课</p>
<p>我先不说这段 C++ 的程序在什么情况下能正确调用派生类的析构函数，
我还是先来说说 C 语言，这样我在后面说这段代码时你就明白了.</p>
<p>对于上面的：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Base* pBase = <span class="keyword">new</span> Derived[<span class="number">10</span>];</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>这个语言和下面的有什么不同吗？</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Derived d[<span class="number">10</span>];</span><br><span class="line">Base* pBase = d;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>一个是堆内存动态分配，一个是栈内存静态分配.
只是内存的位置和类型不一样，在语法和使用上没有什么不一样的.
（如果你把 Base 和 Derived 想成 struct, 把 new 想成 malloc () ,
你还觉得这和 C++ 有什么关系吗？）</p>
<p>那么，你觉得 pBase 这个指针是指向对象的，是对象的引用，
还是指向一个数组的，是数组的引用？</p>
<p>于是乎，你可以想像一下下面的场景：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pInt; <span class="type">char</span>* pChar;</span><br><span class="line">pInt = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">pChar = (<span class="type">char</span>*)pInt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>对上面的 pInt 和 pChar 指针来说，
pInt [3] 和 pChar [3] 所指向的内容是否一样呢？当然不一样，因为 int 是 4 个字节，
char 是 1 个字节，步长不一样，所以当然不一样.</p>
<p>那么再回到那个把 Derived [] 数组的指针转成 Base 类型的指针 pBase,
那么 pBase [3] 是否会指向正确的 Derrived [3] 呢？</p>
<p>我们来看个纯 C 语言的例程，下面有两个结构体，就像继承一样，
我还别有用心地加了一个 void *vptr, 好像虚函数表一样：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">    <span class="type">void</span> *vptr;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>{</span><br><span class="line">    <span class="type">void</span> *vptr;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">}b[<span class="number">2</span>] ={</span><br><span class="line">    {(<span class="type">void</span>*)<span class="number">0x01</span>, <span class="number">100</span>, <span class="string">'a'</span>, <span class="number">-1</span>},</span><br><span class="line">    {(<span class="type">void</span>*)<span class="number">0x02</span>, <span class="number">200</span>, <span class="string">'A'</span>, <span class="number">-2</span>}</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>注意：我用的是 G++ 编译的，在 64bits 平台上编译的，
其中的 sizeof (void*) 的值是 8.</p>
<p>我们看一下栈上内存分配：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> *pa1 = (<span class="keyword">struct</span> A*)(b);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>用 gdb 我们可以看到下面的情况：(pa1 [1] 的成员的值完全乱掉了)</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">(gdb) p b</span><br><span class="line">$<span class="number">7</span> = {{vptr = <span class="number">0x1</span>, i = <span class="number">100</span>, c = <span class="number">97</span> <span class="string">'a'</span>, j = <span class="number">-1</span>}, {vptr = <span class="number">0x2</span>, i = <span class="number">200</span>, c = <span class="number">65</span> <span class="string">'A'</span>, j = <span class="number">-2</span>}}</span><br><span class="line">(gdb) p pa1[<span class="number">0</span>]</span><br><span class="line">$<span class="number">8</span> = {vptr = <span class="number">0x1</span>, i = <span class="number">100</span>}</span><br><span class="line">(gdb) p pa1[<span class="number">1</span>]</span><br><span class="line">$<span class="number">9</span> = {vptr = <span class="number">0x7fffffffffff</span>, i = <span class="number">2</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>我们再来看一下堆上的情况：（我们动态了 struct B [2], 然后转成 struct A
*, 然后对其成员操作）</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> *pa = (<span class="keyword">struct</span> A*)<span class="built_in">malloc</span>(<span class="number">2</span>*<span class="built_in">sizeof</span>(<span class="keyword">struct</span> B));</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> *pb = (<span class="keyword">struct</span> B*)pa；</span><br><span class="line">pa[<span class="number">0</span>].vptr = (<span class="type">void</span>*) <span class="number">0x01</span>;</span><br><span class="line">pa[<span class="number">1</span>].vptr = (<span class="type">void</span>*) <span class="number">0x02</span>;</span><br><span class="line">pa[<span class="number">0</span>].i = <span class="number">100</span>;</span><br><span class="line">pa[<span class="number">1</span>].i = <span class="number">200</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>用 gdb 来查看一下变量，我们可以看到下面的情况：（pa 没问题，
但是 pb [1] 的内存乱掉了）</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">(gdb) p pa[<span class="number">0</span>]</span><br><span class="line">$<span class="number">1</span> = {vptr = <span class="number">0x1</span>, i = <span class="number">100</span>}</span><br><span class="line">(gdb) p pa[<span class="number">1</span>]</span><br><span class="line">$<span class="number">2</span> = {vptr = <span class="number">0x2</span>, i = <span class="number">200</span>}</span><br><span class="line">(gdb) p pb[<span class="number">0</span>]</span><br><span class="line">$<span class="number">3</span> = {vptr = <span class="number">0x1</span>, i = <span class="number">100</span>, c = <span class="number">0</span> <span class="string">'\000'</span>, j = <span class="number">2</span>}</span><br><span class="line">(gdb) p pb[<span class="number">1</span>]</span><br><span class="line">$<span class="number">4</span> = {vptr = <span class="number">0xc8</span>, i = <span class="number">0</span>, c = <span class="number">0</span> <span class="string">'\000'</span>, j = <span class="number">0</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>可见，这完全就是 C 语言里乱转型造成了内存的混乱，这和 C++ 一点关系都没有.
而且，C++ 的任何一本书都说过，
父类对象和子类对象的转型会带来严重的内存问题.</p>
<p>但是，如果在 64bits 平台下，如果把我们的 structB 改一下，
改成如下（把 struct B 中的 int j 给注释掉）：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">    <span class="type">void</span> *vptr;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>{</span><br><span class="line">    <span class="type">void</span> *vptr;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="comment">//int j; &lt;---注释掉int j</span></span><br><span class="line">}b[<span class="number">2</span>] ={</span><br><span class="line">    {(<span class="type">void</span>*)<span class="number">0x01</span>, <span class="number">100</span>, <span class="string">'a'</span>},</span><br><span class="line">    {(<span class="type">void</span>*)<span class="number">0x02</span>, <span class="number">200</span>, <span class="string">'A'</span>}</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>你就会发现，上面的内存混乱的问题都没有了，因为 struct A 和 struct
B 的 size 是一样的：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">(gdb) <span class="function">p <span class="title">sizeof</span><span class="params">(<span class="keyword">struct</span> A)</span></span></span><br><span class="line"><span class="function">$6 </span>= <span class="number">16</span></span><br><span class="line">(gdb) <span class="function">p <span class="title">sizeof</span><span class="params">(<span class="keyword">struct</span> B)</span></span></span><br><span class="line"><span class="function">$7 </span>= <span class="number">16</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>注：如果不注释 int j, 那么 sizeof (struct B) 的值是 24.</p>
<p>这就是 C 语言中的内存对齐，
内存对齐的原因就是为了更快的存取内存（详见《深入理解 C 语言》）</p>
<p>如果内存对齐了，而且 struct A 中的成员的顺序在 struct
B 中是一样的而且在最前面话，那么就没有问题.</p>
<p>再来看 C++ 的程序</p>
<p>如果你看过我 5 年前写的《C++ 虚函数表解析》以及《C++ 内存对象布局
上篇、下篇》, 你就知道 C++ 的标准会把虚函数表的指针放在类实例的最前面，
你也就知道为什么我别有用心地在 struct A 和 struct B 前加了一个 void *vptr.
C++ 之所以要加在最前面就是为了转型后，不会找不到虚表了.</p>
<p>好了，到这里，我们再来看 C++, 看下面的代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">B</span>(){ cout &lt;&lt;<span class="string">"B::~B()"</span>&lt;&lt;endl; }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B</span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">D</span>() { cout &lt;&lt;<span class="string">"D::~D()"</span>&lt;&lt;endl; }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"sizeB:"</span> &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; <span class="string">" sizeD:"</span>&lt;&lt; <span class="built_in">sizeof</span>(D) &lt;&lt;endl;</span><br><span class="line">    B *pb = <span class="keyword">new</span> D[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">delete</span> [] pb;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码可以正确执行，包括调用子类的虚函数！因为内存对齐了.
在我的 64bits 的 CentOS 上 ——sizeof (B):16 , sizeof (D):16</p>
<p>但是，如果你在 class D 中再加一个 int 成员的问题，这个程序就 Segmentation
fault 了。因为 —— sizeof (B):16 , sizeof (D):24.
pb [1] 的虚表找到了一个错误的内存上，内存乱掉了.</p>
<p>再注：我在 Visual Studio 2010 上做了一下测试，对于 struct 来说，
其表现和 gcc 的是一样的，但对于 class 的代码来说，
其可以 “正确调用到虚函数” 无论父类和子类有没有一样的 size.</p>
<p>然而，在 C++ 的标准中，下面这样的用法是 undefined!
你可以看看 StackOverflow 上的相关问题讨论：《Why is it undefined behavior
to delete [] an array of derived objects via a base pointer?》（同样，
你也可以看看《More Effective C++》中的条款三）</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Base* pBase = <span class="keyword">new</span> Derived[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] pBase;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>所以，微软 C++ 编程译器 define 这个事让我非常不解，
对微软的 C++ 编译器再度失望，看似默默地把其编译对了很漂亮，
实则误导了好多人把这种 undefined 的东西当成 defined 来用，还赞扬做得好，
真是令人无语. （就像微博上的这个贴一样，说 VC 多么牛，还说这是 OO 的特性.
我勒个去！）</p>
<p>现在，你终于知道 Base* pBase = new
Derived [10]; 这个问题是 C 语言的转型的问题，
你也应该知道用于数组的指针是怎么回事了吧？这是一个很奇葩的代码！请你不要像那些人一样在微博上和这里的评论里高呼并和我理论到：“微软的 C++ 编译器支持这个事！”.</p>
<p>最后，我越来越发现，很多说 C++ 难用的人，其实是不懂 C 语言.</p>
<p>（全文完）</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中的可变对象与不可变对象</title>
    <url>/posts/c3f5fb77/</url>
    <content><![CDATA[<p>Python 中只存在 “引用传递” 这一种传递方式，
准确来说应该是<strong>指针传递</strong> ,
通过 <code>id()</code> 函数可以确定，参数传入前和传入后的地址值一样</p>
<p>所谓的对象可变与不可变，其实是看是否提供了修改自身对象的方法</p>
<span id="more"></span>
<p><strong>变量无类型，对象有类型</strong></p>
<p>不可变 (immutable) 对象类型 (指针地址不可变)</p>
<ul>
<li>int</li>
<li>float</li>
<li>decimal</li>
<li>complex</li>
<li>bool</li>
<li>str</li>
<li>tuple</li>
<li>range</li>
<li>frozenset</li>
<li>bytes</li>
</ul>
<p>可变 (mutable) 对象类型</p>
<ul>
<li>list</li>
<li>dict</li>
<li>set</li>
<li>bytearray</li>
</ul>
<p>user-defined classes (unless specifically made immutable)</p>
<p>Python 中的对象类型分为 <strong>可变类型</strong> 和
<strong>不可变类型</strong></p>
<p>例如: Python 中的数字是不可变类型</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a = <span class="number">2</span>    <span class="comment"># 变量 a 指向一个 Number 对象</span></span><br><span class="line">b = <span class="number">2</span>    <span class="comment"># 变量 b 和 a 指向同一个 Number 对象 此时 id(a) == id(b)</span></span><br><span class="line">a = <span class="number">1</span>    <span class="comment"># 变量 a 指向一个新的 Number 对象, 而并不是 a 原本指向的 Number 对象发生了改变！ 此时 id(a) != id(b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样, 函数参数传递时也是如此</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(num))    <span class="comment"># 第一次打印的 id 是与外部的参数的 id 一致 (引用传递, 准确来说是指针传递)</span></span><br><span class="line">    num += <span class="number">2</span>        <span class="comment"># 改变了 num 指向的对象, id(num) 发生了改变, 但不影响外部传入变量的地址</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(num))</span><br><span class="line"></span><br><span class="line">add(a)     <span class="comment"># 传递变量 a 其实是“引用传递”, 也就是将 a 指向的内存地址传递了</span></span><br></pre></td></tr></tbody></table></figure>
<p>即使对于可变类型，其实也是<strong>指针传递</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">lst</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">id</span>(lst)) <span class="comment"># 2263872110464</span></span><br><span class="line">  lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">id</span>(lst)) <span class="comment"># 2263872133184</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  l = [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">id</span>(l)) <span class="comment"># 2263872110464</span></span><br><span class="line">  <span class="built_in">print</span>(l) <span class="comment"># [9, 8, 7]</span></span><br><span class="line">  test(l) <span class="comment"># 函数中改变的</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">id</span>(l)) <span class="comment"># 2263872110464</span></span><br><span class="line">  <span class="built_in">print</span>(l) <span class="comment"># [9, 8, 7]</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>可变类型的 "可变", 体现在下面这种情况</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">lst</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(lst)) <span class="comment"># 2389391376256</span></span><br><span class="line">    lst.append(<span class="number">33</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(lst)) <span class="comment"># 2389391376256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    l = [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(l)) <span class="comment"># 2389391376256</span></span><br><span class="line">    <span class="built_in">print</span>(l) <span class="comment"># [9, 8, 7]</span></span><br><span class="line">    test(l)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(l)) <span class="comment"># 2389391376256</span></span><br><span class="line">    <span class="built_in">print</span>(l) <span class="comment"># [9, 8, 7, 33]</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>参考文章:</p>
<p><a href="https://www.cnblogs.com/shiyublog/p/10809953.html">https://www.cnblogs.com/shiyublog/p/10809953.html</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 临时改变 Path 搜索目录</title>
    <url>/posts/285687f/</url>
    <content><![CDATA[<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">r".\lib"</span>)</span><br><span class="line"><span class="keyword">import</span> mymodule <span class="comment"># lib目录下的自定义模块</span></span><br></pre></td></tr></tbody></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python 处理 C 语言结构</title>
    <url>/posts/669ef2f3/</url>
    <content><![CDATA[<p>Python 可以高效率开发，但涉及到运算密集部分，还是应该交给 C/C++,
这里就涉及到数据交互的结构与格式问题</p>
<span id="more"></span>
<p>//todo 不够详细，例子不具体，内存布局与解析没讲明白</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStruct</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"v1"</span>, c_char),  <span class="comment"># c_byte</span></span><br><span class="line">        (<span class="string">"v2"</span>, c_char),  <span class="comment"># c_byte</span></span><br><span class="line">        (<span class="string">"v1_dire"</span>, c_char),  <span class="comment">#  c_byte</span></span><br><span class="line">        (<span class="string">"v2_dire"</span>, c_char)  <span class="comment">#  c_byte</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mys = MyStruct()</span><br><span class="line">mys.v1 = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(mys.v1))</span><br><span class="line">mys.v2 = <span class="number">30</span></span><br><span class="line">mys.v1_dire = <span class="number">0</span></span><br><span class="line">mys.v2_dire = <span class="number">0</span></span><br><span class="line">msg = struct.pack(<span class="string">'cccc'</span>, mys.v1, mys.v2, mys.v1_dire, mys.v2_dire)  <span class="comment"># BBBB</span></span><br><span class="line"><span class="built_in">print</span>(msg)</span><br><span class="line">ss = struct.unpack(<span class="string">'cccc'</span>, msg)  <span class="comment"># BBBB</span></span><br></pre></td></tr></tbody></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>dumpbin 查看 DLL 导出信息</title>
    <url>/posts/e6310a89/</url>
    <content><![CDATA[<p>dumpbin 是 vs 提供的一个工具，可以用于查看 dll/exe 的信息，32 位还是 64 位，
导出函数等</p>
<span id="more"></span>
<p><a href="https://blog.csdn.net/luoyu510183/article/details/93666808">https://blog.csdn.net/luoyu510183/article/details/93666808</a></p>
<p>如果导入 dll 时发现没有找到该函数，
要根据 dll 的导出约定方式设置对应的导入方式，
否则虽然函数名一样但实际上符号是不同的.</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">dumpbin /exports xxx.dll</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line">    <span class="comment">//extern "C" + _stdcall,函数导出符号为 _CreateNativeManager@0 : _+函数名+@+传参字节数</span></span><br><span class="line">    <span class="comment">//由于_stdcall是被调用方清理堆栈, 所以函数符号里面包含了传参的信息</span></span><br><span class="line">    _declspec(dllexport) <span class="function">NativeManager* _stdcall <span class="title">CreateNativeManager</span><span class="params">()</span></span>;</span><br><span class="line">    _declspec(dllexport) <span class="function"><span class="type">void</span> _stdcall <span class="title">ReleaseNativeManager</span><span class="params">()</span></span>;</span><br><span class="line">    _declspec(dllexport) <span class="built_in">void</span>(_stdcall ExSetLogHandler)(LogHandler handler);</span><br><span class="line">    <span class="comment">//extern "C" + _cdecl,函数导出符号为 ReleaseNativeManager2 : 函数名</span></span><br><span class="line">    <span class="comment">//由于_cdecl是调用方清理堆栈, 所以只需要函数名就可以</span></span><br><span class="line">    _declspec(dllexport) <span class="built_in">void</span>(_cdecl ReleaseNativeManager2)();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//不使用extern的情况下, 是C++的导出方式, 函数符号如下：</span></span><br><span class="line"><span class="comment">//?ReleaseNativeManager1@@YGXH@Z : ?+函数名+@@YG+返回类型+参数1类型...+@Z</span></span><br><span class="line"><span class="comment">//如果是_cdecl @YG变为@YA</span></span><br><span class="line"><span class="comment">//如果没有参数即参数为void,则以Z结尾, 例如：</span></span><br><span class="line"><span class="comment">//?ReleaseNativeManager3@@YAXXZ : ?+函数名+@@YA+返回类型+XZ</span></span><br><span class="line"><span class="comment">//以上 X表示 void类型, H表示int参数类型</span></span><br><span class="line">_declspec(dllexport) <span class="built_in">void</span>(_stdcall ReleaseNativeManager1)(<span class="type">int</span> num);</span><br><span class="line">_declspec(dllexport) <span class="built_in">void</span>(_cdecl ReleaseNativeManager3)();</span><br></pre></td></tr></tbody></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DLL</tag>
      </tags>
  </entry>
  <entry>
    <title>从递归到动态规划</title>
    <url>/posts/22ef0efc/</url>
    <content><![CDATA[<p>如果一个算法可以拆成递归求解，那么它就基本可以使用动态规划求解</p>
<p>动态规划的本质就是缓存之前递归的结果，不让一些小的递归反复执行</p>
<span id="more"></span>
<h2 id="找递推关系式-终止条件">1. 找递推关系式 &amp; 终止条件</h2>
<p>对于有递归关系的问题，首先找出递推关系式，比如斐波那契数列
(下标从 0 开始), 递推关系式如下</p>
<p><span class="math display">\[f(n)=f(n−1)+f(n−2)\]</span></p>
<p>其中 n≥2 (下标从 0 开始), 终止条件就是 n&lt;2 且有</p>
<p><span class="math display">\[f(0)=f(1)=1\]</span></p>
<h2 id="写出递归函数">2. 写出递归函数</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(n - <span class="number">1</span>) + <span class="built_in">func</span>(n - <span class="number">2</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="创建状态转移矩阵">3. 创建状态转移矩阵</h2>
<p>若递归函数有 n 个参数，则定义 n 维数组，数组下标就是参数的取值，
数组中的值就是递归函数的返回值</p>
<h2 id="填写转移矩阵">4. 填写转移矩阵</h2>
<ul>
<li>填边界：将初始已知的值填入矩阵</li>
<li>矩阵其它位置：根据转移方程依次填写</li>
</ul>
<h2 id="注意">5. 注意</h2>
<p>并不是所有的递归都可以转换为矩阵形式，比如当参数个数过多时，
每个参数按照所有可能展开可能形成非常巨大的多维矩阵，
此时可以考虑递归的基础上剪枝，添加缓存等方式加快递归搜索性能</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数据结构&amp;设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>健康生活清单</title>
    <url>/posts/1ef19147/</url>
    <content><![CDATA[<p>现在多少年轻人都莫名其妙的大病或猝死，
不好的生活习惯会让我们的身体一直处于亚健康状态，
后面可能任何一个小的触发点都能是压垮骆驼的最后一根稻草，
比如生个气喝个酒甚至猛然的剧烈运动一下都可能直接人没了</p>
<span id="more"></span>
<p>一份简单的健康生活清单，说着简单，但坚持做下来不简单</p>
<ul>
<li>饮食
<ul>
<li><span style="color: green">多喝水</span></li>
<li><span style="color: green">多吃蔬菜水果</span></li>
<li><span style="color: orange">少吃油炸烧烤腌制</span> (含致癌物)</li>
<li><span style="color: red"> 少吃游离糖，少吃零食，少喝奶茶</span>
(高糖高热量，危害多到写不下)</li>
<li><span style="color: red"> 不饮酒，不喝含酒精饮料</span>
(含酒精饮料为一级致癌物 (与黄曲霉素一个等级))</li>
</ul></li>
<li> 作息
<ul>
<li><span style="color: green">早睡早起</span> (熬夜的危害实在太多了，
都懒得写)</li>
<li><span style="color: green"> 保持午休</span> (30 分钟左右即可，
双相睡眠对身体非常好)</li>
</ul></li>
<li> 活动
<ul>
<li><span style="color: green">保持锻炼</span>
(每周至少 3 次不少于 30 分钟的运动)</li>
<li><span style="color: red"> 不要长时间埋头，电脑垫高</span> (保护颈椎，
出问题时才知道多严重)</li>
</ul></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>向量的点乘与叉乘</title>
    <url>/posts/700389e5/</url>
    <content><![CDATA[<p>基本的代数 / 图形学，向量运算的几何意义</p>
<span id="more"></span>
<h2 id="向量点乘">向量点乘</h2>
<p><span class="math display">\[
\begin {align*} &amp; \vec A = (x_1,\ y_1,\ z_1) \\ &amp; \vec B = (x_2,\
y_2,\ z_2) \\ &amp; \vec A \cdot \vec B = (x_1 * x_2,\ y_1 * y_2,\ z_1 *
z_2) \\ &amp; \vec A \cdot \vec B = \lvert \vec A \rvert * \lvert \vec B
\rvert * \cos (\theta) &amp; (\theta 为两向量夹角)\\ \end {align*}
\]</span></p>
<p>向量点乘的结果是一个<strong>标量</strong> , 根据最后一个公式的定义，
我们可以通过点乘计算夹角角度，
或者计算一个向量在另一个向量上的投影长度</p>
<ul>
<li><p>通过向量点乘可以计算向量 A 在向量 B 方向上的投影长度</p>
<p><span class="math display">\[
\begin{align*} &amp; l = \frac{ \vec A \cdot \vec B } { \lvert \vec B
\rvert } = \frac{ \lvert \vec A \rvert * \lvert \vec B \rvert *
\cos(\theta) } { \lvert \vec B \rvert } = \lvert \vec A \rvert *
\cos(\theta) \end{align*}
\]</span></p></li>
<li><p> 特别的，当向量 B 的模长为 1 时，可以有以下等式</p>
<p><span class="math display">\[
l = \vec A \cdot \vec B
\]</span></p></li>
</ul>
<h3 id="向量点乘的几何意义">向量点乘的几何意义</h3>
<p><strong>粗略判断夹角大小</strong> 当两个向量 A 和 B 的模长都大于 0 时，
其点乘结果与 0 相比可以粗略得出向量夹角的大小 (0° 到 180°) - 点乘值 &gt; 0,
也就是 <span class="math inline">\(\cos(\theta) &gt; 0\)</span>,
夹角为锐角 - 点乘值 = 0, 也就是 <span class="math inline">\(\cos(\theta)
= 0\)</span>, 夹角为直角 - 点乘值 &lt; 0, 也就是 <span class="math inline">\(\cos(\theta) &lt; 0\)</span>, 夹角为钝角</p>
<p><strong>计算夹角的准确大小</strong>
由点乘的计算公式可以计算夹角大小</p>
<p><span class="math display">\[
\theta = \arccos \frac{\vec A \cdot \vec B}{\lvert \vec A \rvert *
\lvert \vec B \rvert}
\]</span></p>
<h2 id="向量叉乘">向量叉乘</h2>
<p>两个向量叉乘的结果是一个向量</p>
<p><span class="math display">\[
\begin{align*} &amp; \vec A \times \vec B = \vec C \\ &amp; \lvert \vec
C \rvert = \lvert \vec A \rvert * \lvert \vec B \rvert * \sin(\theta)
\end{align*}
\]</span></p>
<p>结果 C 向量同时垂直于向量 A 和向量 B,
可以用<strong>右手法则</strong>确定 C 的具体方向，右手四指从 A 转向 B,
大拇指指向的就是 C 的方向；C 的模长如公式所示</p>
<p>注意：由于计算结果是向量，有方向区分，所以向量叉乘不满足交换律</p>
<p><span class="math display">\[
\vec A \times \vec B = - \vec B \times \vec A
\]</span></p>
<p>交换向量 A 和 B 后，其结果向量模长相等，方向相反</p>
<p>向量叉乘的结果可以使用行列式计算，不要去记最终结果，太难记了</p>
<p><span class="math display">\[
\begin{align*} &amp; \vec A &amp;&amp; = (x_1, \ y_1, \ z_1) \\ &amp;
\vec B &amp;&amp; = (x_2, \ y_2, \ z_2) \\ &amp; \vec A \times \vec B
&amp;&amp; = \left| \begin{array}{} \vec x &amp; \vec y &amp; \vec z \\
x_1 &amp; y_1 &amp; z_1 \\ x_2 &amp; y_2 &amp; z_2 \\ \end{array}
\right| \\ &amp; &amp;&amp; = \vec x \left| \begin{array}{} y_1 &amp;
z_1 \\ y_2 &amp; z_2 \end{array} \right| - \vec y \left| \begin{array}{}
x_1 &amp; z_1 \\ x_2 &amp; z_2 \end{array} \right| + \vec z \left|
\begin{array}{} x_1 &amp; y_1 \\ x_2 &amp; y_2 \end{array} \right| \\
&amp; &amp;&amp; = \vec x (y_1z_2 - y_2z_1) + \vec y (x_2z_1 - x_1z_2) +
\vec z (x_1y_2 - x_2y_1) \end{align*}
\]</span></p>
<p>其中，<span class="math inline">\(\vec
x\)</span> 表示 x 轴方向的单位向量，<span class="math inline">\(\vec
y\)</span> 和<span class="math inline"> \(\vec z\)</span> 同理</p>
<p>行列式计算可以参考 <a href="/posts/a4019dcb/" title="行列式的代数余子式计算法">行列式的代数余子式计算法</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>字节序</title>
    <url>/posts/79aef41/</url>
    <content><![CDATA[<p>字节序的问题在不同硬件，系统，或者在网络交互时都需要格外注意</p>
<span id="more"></span>
<h2 id="字节顺序-endian">字节顺序 Endian</h2>
<p>现代计算机系统一般以字节 (Byte, 8bit) 为单位作为逻辑寻址单位，
当数据单位的长度大于 1 字节时，就要区分<strong>字节顺序</strong> ,
常见字节顺序有两种: Big Endian (BE), Little Endian (LE)</p>
<ul>
<li>大端存储 (BE): 低位地址存放高位字节</li>
<li>小端存储 (LE): 低位地址存放低位字节</li>
</ul>
<p>例如: 4 字节无符号整数 0xAB CC DD EF, 最高位字节是 0xAB, 最低位字节是
0xEF</p>
<p>内存: <code>|0x01|0x02|0x03|0x04|</code></p>
<p>若数据存储在内存地址 0x01 的位置上，占用 [0x01, 0x04] 4 个字节</p>
<p>大小端就看低位地址 (0x01) 上存储的是高位字节 (0xAB) 还是低位字节
(0xEF)</p>
<h2 id="常见环境的字节序">常见环境的字节序</h2>
<p>一般操作系统上的字节序是由 CPU 和操作系统决定</p>
<ul>
<li>Intel X86 平台全部采用小端模式</li>
<li> ARM 即可以工作在大端模式，也可以工作在小端模式</li>
<li> STM32 属于小端模式</li>
</ul>
<p>X86 和一般操作系统使用小端模式 (Windows, Linux), 但 MacOS
是大端模式</p>
<p><strong>网络字节序</strong>: TCP/IP 协议中规定的字节序，与环境无关，
<strong>网络字节序采用大端模式 (Big Endian)</strong></p>
<h2 id="编程判断当前环境字节序">编程判断当前环境字节序</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">uint32_t</span> num = <span class="number">0x00'00'00'01</span>; <span class="comment">// C++14开始支持以单引号分隔数字, 若不支持可以删掉</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> b = *(<span class="type">unsigned</span> <span class="type">char</span>*)(&amp;num); <span class="comment">// 低地址取1字节, 解析为unsigned char</span></span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) { <span class="built_in">printf</span>(<span class="string">"Big Endian\n"</span>); }</span><br><span class="line">  <span class="keyword">else</span> { <span class="built_in">printf</span>(<span class="string">"Little Endian\n"</span>); }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>常用设计模式</title>
    <url>/posts/364ea8cc/</url>
    <content><![CDATA[<p>设计模式列表备忘</p>
<span id="more"></span>
<ul>
<li>原则
<ul>
<li><strong>开闭原则</strong> (封装不变，开放变化) 也说成对扩展开放，
对修改关闭</li>
<li><strong>里氏替换</strong>
(任何基类出现的地方一定可以用派生类替换)</li>
<li><strong> 依赖倒置</strong> (针对接口编程，依赖于抽象)</li>
<li><strong> 接口隔离</strong> (使用多个单一功能接口，
比使用单个复杂接口好)</li>
<li><strong> 迪米特法则</strong> (最少知道原则，
一个实体应尽量少地与其他实体之间发生相互关联)</li>
<li><strong> 合成复用</strong> (尽量使用组合，而不是使用继承)</li>
</ul></li>
<li> 池模式
<ul>
<li>对象池 / 内存池 (对象重复利用，减少内存的频繁申请与释放)</li>
<li> 线程池</li>
<li>连接池</li>
</ul></li>
<li>创建型
<ul>
<li>单例模式</li>
<li>简单工厂方法 (一个方法，根据不同参数返回不同对象)</li>
<li> 工厂模式 (每个工厂对应一种产品，
利用一个工厂对象不断生成同类型产品)</li>
<li> 抽象工厂模式 (一个抽象工厂提供多种产品接口，
但每个产品的实际生产依赖不同的实际工厂对象生产的 "零件")</li>
<li> 创建者模式 (分部分，逐步构造复杂对象的各个部分，
最后调用一个 <code>build()</code> 方法构造出复杂对象)</li>
<li> 原型模式</li>
</ul></li>
<li>结构型
<ul>
<li>适配器模式 (不同接口适配)</li>
<li> 代理模式</li>
<li>装饰器模式</li>
<li>外观模式 (繁杂复杂接口封装为简单易用的接口)</li>
<li> 桥接模式 (变化的不同维度分别拆分抽象，再组合起来。书本 1, 书本 2,
颜色 1, 颜色 2, 不应该弄 4 种子类，而是 I 书本包含 I 颜色，书本有两种实现，
颜色有两种实现)</li>
<li> 组合模式 (整体与层次关系，单个对象与组合对象有一致接口。树状结构，
由基本节点可以组合出枝节点，枝节点可以继续组合，
且组合节点与基本节点有完全一样的接口，可以不做区分调用)</li>
<li> 享元模式 (工厂模式该进，有点像对象池的意思，若需要大量相同子对象，
可以在细粒度上构建共享资源，防止过多相同的内存开销；
例如一些语言中的 String 池，相同字符串都指向内存同一地址，
而不是新创建)</li>
</ul></li>
<li> 行为型
<ul>
<li>策略模式 (将处理方法抽象化，
针对不同的选择传入不同的处理方法对象)</li>
<li> 模板方法模式</li>
<li>观察者模式 (订阅 - 通知)</li>
<li> 中介者模式 (将多个对象互相复杂依赖改为星型结构，
每个对象都只与中介者交互依赖)</li>
<li> 状态模式 (将状态封装，对象具有状态，状态可转换，
对象的相同接口在不同状态下有不同表现，接口实现可依赖于状态的实现)</li>
<li> 责任链模式 (收到一个请求:
IP 过滤 -&gt; 授权验证 -&gt; 日志记录 -&gt; 请求处理 -&gt; 页面渲染)</li>
<li> 命令模式 (将控制 / 操作由接口调用改成封装成<code>命令对象</code> ,
可以用于需要 操作历史 / 操作日志 / 撤销重做 的场景)</li>
<li> 备忘录模式 (发起人，备忘录，管理者，
只有发起人可以将自己内部状态存入备忘录对象，或者从中读取内部状态；
管理者管理备忘录对象，但不能读取 / 操作备忘录对象内部内容；
游戏角色在战斗失败后恢复到战前的状态)</li>
<li> 迭代器模式 (iterator)</li>
<li> 访问者模式 (数据对象的类很少改变，但经常需要在此对象上定义新的操作，
定义访问者类封装了对数据类的执行算法，
这样数据对象的执行算法可以随着访问者的改变而改变)</li>
<li> 解释器模式 (符号解析)</li>
</ul></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数据结构&amp;设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>浮点数存储结构</title>
    <url>/posts/6c1bab40/</url>
    <content><![CDATA[<p>浮点数在内存中的存储结构</p>
<span id="more"></span>
<h2 id="基础概念">基础概念</h2>
<ul>
<li>十进制整数转二进制为除 2 取余，逆序排列</li>
<li>十进制小数转二进制为乘 2 取整，顺序排列</li>
<li>二进制转十进制是每位加权求和</li>
</ul>
<p><span class="math display">\[
11.1101_2=1*2^1+1*2^0+1*2^{-1}+1*2^{-2}+0*2^{-3}+1*2^{-4} \]</span></p>
<ul>
<li><p>n 进制的科学计数法 <span class="math inline">\(a*n^b\)</span>
(<span class="math inline">\(0&lt;|a|&lt;n\)</span>) 其中 a 和 b 都是 n
进制数字，类比十进制，b 表示 n 进制指数 (小数点移动的位数)</p>
<p>E. G. 二进制 <span class="math inline">\(10000_2=1*2^{100_2}\)</span>, 指数相当于十进制的
4, 也就是小数点向右移动 4 位</p></li>
</ul>
<h2 id="浮点数国际标准-ieee-754">浮点数国际标准 IEEE 754</h2>
<p>国际标准 IEEE 754 标准使用一个三元组 <span class="math inline">\(\{S,
E, M\}\)</span> 表示一个浮点数 N</p>
<ul>
<li><p><code>S</code> 符号位，0 和 1 分别表示正和负</p></li>
<li><p><code>E</code> 阶码，用移码表示</p></li>
<li><p><code>M</code> 尾码，按照 IEEE 754 标准存储浮点数需要先规格化，
最后的尾码一定是 <span class="math inline">\((1.xxxxx)_2\)</span>
的二进制格式，第一位一定是 1, 因此尾码存储时舍去了第 1 位的 1,
只保存了二进制小数部分，这样可以多表示一位</p></li>
</ul>
<h2 id="浮点数的规格化">浮点数的规格化</h2>
<p>同一个浮点数的表示规格并不统一，比如 <span class="math inline">\((1.11)_2\times 2^0 = (0.111)_2\times 2^1 =
(0.0111)_2\times 2^2\)</span>.</p>
<p>为了数据的表示精度，就必须充分利用尾码的有效位数，IEEE 754
标准中当尾码大小不是 <span class="math inline">\((1.xxxx)_2\)</span>
格式时就左右移动小数点并同时修改阶码大小，直到达到要求，
该过程称为浮点数规格化</p>
<h2 id="浮点数的表示">浮点数的表示</h2>
<p>浮点数中的指数 e 可能有正有负，为了方便表示，将 e
增加一个固定的偏移量得到移码 E 作为阶码</p>
<p>平常使用最多的是单精度 (32 位) 和双精度 (64 位) 浮点数，
尾码部分默认小数点前的一位 1 省去了，后面不再赘述</p>
<h3 id="单精度浮点数">单精度浮点数</h3>
<p>符号位 (S) 1 位，阶码 (E) 8 位，尾码 (M) 23 位</p>
<p>其中阶码偏移量为 127 (0x7F), 尾码仅表示小数部分，
前面的 1 和小数点省略</p>
<p>真值表示: <span class="math inline">\(X=(-1)^S\times (1.M) \times
2^{E - 127}\)</span> <span class="math inline">\(e=E-127\)</span></p>
<p>由于 <span class="math inline">\(2^{23}=8388608\)</span>
最大可表示精度为 7 位，但不能表示所有的 7 位数，可保证 6 位精度</p>
<h3 id="双精度浮点数">双精度浮点数</h3>
<p>符号位 (S) 1 位，阶码 (E) 11 位，尾码 (M) 52 位</p>
<p>其中阶码偏移量为 1023 (0x3FF), 尾码仅表示小数部分，
前面的 1 和小数点省略</p>
<p>真值表示: <span class="math inline">\(X=(-1)^S\times (1.M) \times
2^{E - 1023}\)</span> <span class="math inline">\(e=E-1023\)</span></p>
<p>由于 <span class="math inline">\(2^{52}=4503599627370496\)</span>
最大表示精度为 16 位，不能表示所有 16 位数字，保证精度为 15 位</p>
<h3 id="特殊值">特殊值</h3>
<p>在特殊情况下，浮点数的计算不再按照常规的方式计算，
而是直接表示特殊的真值，以下对于单精度和双精度都一样</p>
<ul>
<li><p>真值 0: 当阶码 E 全 0, 且尾数 M 全 0 时，表示真值 X 为 0, 由于符号位不同，
所以有正负 0 两种表示</p></li>
<li><p>无穷大：当阶码 E 全 1, 且尾码 M 全 0 时，表示真值为无穷大，
符号位不同可以表示正负无穷大</p></li>
<li><p> NaN: 当阶码全 1, 且尾码 M 非全 0 时，全都表示 NaN, NaN 没有正负之分，
符号位 0 或 1 都是 NaN</p></li>
</ul>
<h2 id="编码测试">编码测试</h2>
<p>编写一个函数，用于将数值以二进制打印</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_bin</span><span class="params">(T data)</span> </span>{</span><br><span class="line">  std::string str;</span><br><span class="line">  <span class="type">uint8_t</span>* bytes = (<span class="type">uint8_t</span>*)&amp;data;</span><br><span class="line">  <span class="keyword">auto</span> len = <span class="built_in">sizeof</span>(T);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) {</span><br><span class="line">    <span class="type">uint8_t</span> v = bytes[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">8</span> - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) {</span><br><span class="line">      str.<span class="built_in">append</span>((v &amp; (<span class="number">0x1</span> &lt;&lt; j)) &gt; <span class="number">0</span> ? <span class="string">"1"</span> : <span class="string">"0"</span>);</span><br><span class="line">    }</span><br><span class="line">    str.<span class="built_in">append</span>(<span class="string">" "</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str.<span class="built_in">c_str</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>先看一下 1.0 的结果 <code>print_bin(float(1.0))</code> 结果为
<code>00111111 10000000 00000000 00000000</code></p>
<p>其中 S=0, <span class="math inline">\(E=(01111111)_2=127\)</span>,
M=0</p>
<p>也就是 <span class="math inline">\(1.0=(-1)^S\times (1.M) \times
2^{E-127}=1\times 1.0 \times 2^0\)</span></p>
<p>再试试 0.5, <code>print_bin(float(0.5))</code> 结果为
<code>00111111 00000000 00000000 00000000</code>
与 1.0 的区别仅仅是阶码小了 1</p>
<p>真值计算 <span class="math inline">\(0.5=(-1)^(0)\times (1.0) \times
2^{126-127}=1\times 1.0 \times 2^{-1}\)</span></p>
<p>再验证一下特殊值是否如我们所想</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>());</span><br><span class="line"><span class="built_in">print_bin</span>(std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, -std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>());</span><br><span class="line"><span class="built_in">print_bin</span>(-std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">quiet_NaN</span>());</span><br><span class="line"><span class="built_in">print_bin</span>(std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">quiet_NaN</span>());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, -std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">quiet_NaN</span>());</span><br><span class="line"><span class="built_in">print_bin</span>(-std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">quiet_NaN</span>());</span><br><span class="line"><span class="type">float</span> nan = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line">*(<span class="type">uint32_t</span>*)(&amp;nan) |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, nan);</span><br><span class="line"><span class="built_in">print_bin</span>(nan);</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果如下 </p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">inf</span><br><span class="line">01111111 10000000 00000000 00000000</span><br><span class="line">-inf</span><br><span class="line">11111111 10000000 00000000 00000000</span><br><span class="line">nan</span><br><span class="line">01111111 11000000 00000000 00000000</span><br><span class="line">nan</span><br><span class="line">11111111 11000000 00000000 00000000</span><br><span class="line">nan</span><br><span class="line">01111111 10000000 00000000 00001000</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>可以发现，对于无穷大，printf 以字符串 inf 表示了，
<code>quiet_NaN()</code> 获取的 NaN 值是阶码全 1, 尾码的第一位设置为 1,
改变符号位依然是 NaN, 我试了一下在无穷大的基础上，
将尾码倒数第 4 位 (随机一位) 设置为 1, 输出为 NaN, 符合预期</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>浮点数</tag>
      </tags>
  </entry>
  <entry>
    <title>行列式的代数余子式计算法</title>
    <url>/posts/a4019dcb/</url>
    <content><![CDATA[<p>行列式的代数余子式计算方法，大学学过又忘了</p>
<span id="more"></span>
<h2 id="二阶行列式">二阶行列式</h2>
<p>二阶行列式的计算，<strong>主对角线乘积减去副对角线乘积</strong> <span class="math display"> \[
\left|
    \begin{array}{}
        a &amp; b \\
        c &amp; d
    \end{array}
\right|
= a * d - b * c
\]</span></p>
<h2 id="基础概念">基础概念</h2>
<ul>
<li><span class="math inline">\(a_{ij}\)</span>
表示行列式的第 i 行第 j 列的元素 (行列下标从 1 开始)</li>
<li><span class="math inline">\(M_{ij}\)</span> 为行列式<span class="math inline"> \(D_n\)</span> 去掉第 i 行和第 j 列后的 n-1 阶行列式，
称作<span class="math inline"> \(a_{ij}\)</span> 对应的<strong>余子式</strong></li>
<li><span class="math inline"> \(A_{ij}\)</span> 为<span class="math inline"> \(a_{ij}\)</span> 对应的代数余子式，也就是<span class="math inline"> \(M_{ij}\)</span> 加上正负符号，也就是乘以<span class="math inline"> \((-1)^{i+j}\)</span> <span class="math display">\[
A_{ij}=(-1)^{i+j} * M_{ij} \]</span></li>
</ul>
<h2 id="行列式计算">行列式计算</h2>
<p>命题: <strong>n 阶行列式<span class="math inline"> \(D_n\)</span> 等于它任意一行 (列) 的所有元素与其对应的代数余子式的乘积之和</strong></p>
<p><span class="math display">\[
\begin{align*}
D_n &amp;= \sum_{j=1}^n a_{ij}*A_{ij} = \sum_{j=1}^n
(-1)^{i+j}*a_{ij}*M_{ij} \\
D_n &amp;= \sum_{i=1}^n a_{ij}*A_{ij} = \sum_{i=1}^n
(-1)^{i+j}*a_{ij}*M_{ij} \\
\end{align*}
\]</span></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>添加糖 - 甜蜜杀手</title>
    <url>/posts/90d1f41c/</url>
    <content><![CDATA[<p>让人上瘾，又伤心、伤脑…… 这味调料家家都有，但劝你别多吃！</p>
<p>2022-03-01 14:00 来源： CCTV 回家吃饭</p>
<p>　　糖果、冰激凌、蛋糕、饼干、巧克力…… 甜食让不少人欲罢不能，
情绪不好时来一口，感觉整个世界都明媚了；时下的网红饮品奶茶，
更是被戏称为 “肥宅快乐水”, 深受年轻人的喜爱～</p>
<p>　　殊不知，大快朵颐的同时，甜食更像是一位隐形的 “甜蜜杀手”,
不仅会让人慢慢 “上瘾”, 还会悄悄摧毁着你的身体！</p>
<span id="more"></span>
<h2 id="长期吃太多糖-从上到下毁全身">长期吃太多糖，从上到下毁全身</h2>
<p>　　2012 年 2 月，
发表在国际顶级学术刊物《Nature》杂志的一篇题为《公共卫生：糖的毒性真相》的文章指出：糖就像烟草和酒精一样，
而且糖的危害远在脂肪和卡路里之上！</p>
<h3 id="糖-会诱发多种癌症">1 糖，会诱发多种癌症</h3>
<p>　　长期高糖摄入会导致肥胖和胰岛素抵抗，
造成内氧化应激、内分泌紊乱及免疫功能障碍，
从而导致肿瘤的发生风险增加.</p>
<p>　　2020 年刊发在《美国临床营养学杂志》的一项研究，
对 10 万余人进行了长达 5.9 年的随访，通过饮食记录大家吃糖的情况.
结果发现：</p>
<p>　　①总糖摄入量与较高的总癌症风险相关，且这种联系主要来自乳腺癌；</p>
<p>　　②添加糖、蔗糖、含糖饮料中的糖等与癌症风险的增加显著相关性.</p>
<p>　　另外，瑞典科学家花 9 年时间对 8 万人进行了跟踪调查，结果显示，
经常过量摄取甜食、果酱等高糖食物的人，
患胰腺癌的风险要比其他人高出 70%~90%.</p>
<p>　　而除了人人敬而远之的癌症，吃糖过多还会带来以下危害：</p>
<h3 id="形成龋齿">2 形成龋齿</h3>
<p>　　摄入过多糖分食物，容易导致龋齿产生.
因为在口腔中残留的糖分非常容易被细菌分解并发酵，从而产生酸性的物质，
损坏牙釉质.</p>
<h3 id="加速皮肤老化">3 加速皮肤老化</h3>
<p>　　摄入太多糖分时，不仅容易使皮肤松弛，滋生皱纹，
肤色暗黄且没有光泽；也会使得酪氨酸酶异常活跃，加快黑色素沉淀速度，
使得皮肤暗沉，容易长斑；甚至易堵塞毛孔而形成痤疮.</p>
<h3 id="伤大脑">4 伤大脑</h3>
<p>　　吃太多糖，会伤害脑细胞，降低记忆力，
简单来说就是吃糖过多会让人变笨.</p>
<h3 id="诱发心脏病">5 诱发心脏病</h3>
<p>　　进食含糖量过高的食品会使血液中的甘油三酯升高，
从而增加患心血管疾病的风险.</p>
<p>　　另外，
一项针对 11.8 万美国人的 34 年随访研究显示：每天饮用 2 次以上含糖饮料的人，
死于心血管疾病的风险上升 31%.</p>
<h2 id="控糖-控的是添加糖">控糖，控的是 “添加糖”</h2>
<p>　　糖类是人体必须的三大营养物质之一，应该均衡地摄入.
<strong>真正需要限制摄入的是 “添加糖”（游离糖）</strong>：</p>
<p>　　①添加在加工食品中的白糖、冰糖、红糖、黑糖.
它们的主要成分都是蔗糖，加工原料均为甘蔗或甜菜，只是加工工艺不同.</p>
<p>　　②各种添加了果葡糖浆、葡萄糖浆、麦芽糖浆、淀粉糖浆的含糖饮品.</p>
<p>　　③水果汁和蜂蜜也属于要限制的糖类.
水果榨汁过程中会损失大量膳食纤维，
消化吸收会加快；蜂蜜主要是果糖和葡萄糖，属于应该控制的糖类.</p>
<p>　　世界卫生组织建议要终生控制游离糖摄入，
但是现实中又很难做到完全不吃。所以，
我们最好将每天的游离糖摄入量控制在 25g 以内.</p>
<h3 id="代糖-也别吃过量">代糖，也别吃过量</h3>
<p>　　现在不少商家会选择用糖醇或人工甜味剂替代添加糖，不牺牲风味的同时，
实现限糖.</p>
<ol type="1">
<li>糖醇</li>
</ol>
<p>　　糖醇养型合成甜味剂，
我们在配料表中看到的赤藓糖醇、山梨糖醇、麦芽糖醇、甘露醇、木糖醇等配料，
就是糖醇家族的成员，优势也非常明显：</p>
<p>　　①提供甜味的同时，提供的热量大多远低于蔗糖；</p>
<p>　　②摄入后不会引起血糖大幅度升高；</p>
<p>　　③在口腔中也不受微生物作用，不会引起龋齿.</p>
<ol start="2" type="1">
<li>人工甜味剂</li>
</ol>
<p>　　人工甜味剂属于非营养型甜味剂，
我们在配料表中看到的糖精、安赛蜜、阿斯巴甜等配料就属于这个类别.</p>
<p>　　和糖醇一样，
人工甜味剂也能在一定程度上帮助人们降低热量和糖分的摄入，
但是它绝不是放心之选 —— 其能起打开食欲的作用，
在心理上反而会对那些又甜、又实际存在热量的食物产生更强烈的依赖，
这样一来可能会间接促成食物和能量摄入超标的结局.</p>
<p>　　总的来说，不管是糖醇还是人工甜味剂，
日常可以以少量、低频次的节奏去摄入，但不能毫无节制的食用.</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
